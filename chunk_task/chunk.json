{
    "docs": [
        {
            "doc": {
                "doc": "**Tema I Algoritmización\n# Asignatura: Introducción a la Programación\n\n## Ingeniería Informática\n\n**Guía de Aprendizaje**\n\n**Tema:** Algoritmización\n\n**Unidad didáctica:** Algoritmo. Técnicas para representar algoritmos.\n\n## 1. Objetivos de la unidad didáctica:\n\n- Caracterizar un algoritmo.\n- Caracterizar y emplear técnicas para representar algoritmos.\n\n## 2. Introducción a la unidad didáctica:\n\nSiempre que vamos a resolver un problema nos enfrentamos con la dificultad de tener que encontrar precisamente eso: Una Solución. Pocas veces nos detenemos a pensar que existe un camino estructural que nos permite resolver cualquier problema (en términos generales) teniendo, como es obvio, que entrar en la minucia del detalle dependiendo del problema.\n\nCuál es el primer paso que debemos dar cuando nos enfrentamos a un problema...? Lo primero que debemos tener muy pero muy muy claro es Cual es el problema. Es evidente que no podemos avanzar hacia la casa de un amigo nuestro que no sabemos en donde vive porque las posibilidades de que lleguemos son casi nulas. De manera que lo primero a conocer muy bien es el problema como tal que en nuestros términos lo vamos a ver no como un problema sino como un objetivo.\n\nTener claro el objetivo nos va a permitir obtener dos beneficios que a la postre serán mas grandes de lo que podemos pensar:\n\n- Tener claro el objetivo nos permite saber hacia donde vamos.\n- Tener claro el objetivo nos permite saber hasta donde debemos llegar.\n\nEstas dos definiciones parecieran ser lo mismo pero en el fondo no lo son. Usted puede tener muy claro hacia donde va pero puede no saber hasta donde debe llegar o, dicho en otras palabras, no saber en donde debe parar ó podría saber en donde debe para pero no tener ni idea por cual ruta llegar. El objetivo se ha de convertir en la razón de ser en la solución de un problema.\n\nEn nuestro caso, y mas que nunca, podemos decir que para llegar a la solución de un problema la clave de ello está en Tener muy claro cuál es el objetivo y No perderlo nunca de Vista. Tal vez usted tendrá alguna inquietud en cuanto a la insistencia de este tópico pero la realidad es que muchas veces creemos tener claro el objetivo y solo cuando nos empeñamos en lograrlo vemos que no era así.\n\nTener claro el objetivo nos permite algo adicional. Aquí voy a utilizar una frase que, aunque un poco romántica, nos va a ilustrar a que me refiero: El objetivo es el faro que solo cuando está bien claro nos ilumina el camino para lograrlo. Cuando el objetivo está suficientemente claro podemos vislumbrar un camino lógico para llegar hasta él. Ese camino lógico va a tener un nombre dado y ese nombre es algoritmo.\n\nQué es un Algoritmo...? Es un conjunto de pasos secuenciales y ordenados que permiten lograr un objetivo. Que sean pasos secuenciales significa que deben ser ejecutados uno después de otro y que sean pasos ordenados quiere decir que deben llevar un orden quasi-obligatorio (u obligatorio en la mayoría de los casos). Como puede notar el algoritmo permite lograr un objetivo. O sea que éste es el camino que necesitamos para lograrlo.\n\n## 3. Orientaciones para el estudio:\n\n1. Le sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\n2. Cree hábitos de estudio sistemático; para esto:\n   - Planifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\n   - Calendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\n3. Utilice técnicas de estudio:\n   - Elija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan.\n   - Estudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\n   - Reflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\n4. Interactúe con los materiales de estudio en tres fases:\n   - **Fase de aproximación:** Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\n   - **Fase de lectura profunda:** Aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\n   - **Fase de evaluación:** Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n\n## 4. Requisitos Previos:\n\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedi",
                "metadata": {
                    "file_name": "Asignatura__Introducción_a_la_Programación.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\n   - Reflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\n4. Interactúe con los materiales de estudio en tres fases:\n   - **Fase de aproximación:** Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\n   - **Fase de lectura profunda:** Aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\n   - **Fase de evaluación:** Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n\n## 4. Requisitos Previos:\n\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n## 5. Actividades de auto-aprendizajes:\n\n1. Consulte la bibliografía citada en esta guía y clasifique los diferentes tipos de algoritmos.\n   - a. Caracterice cada una de las clasificaciones de algoritmo.\n   - b. Mencione tres ejemplos de cada clasificación de algoritmo.\n2. Una de las clasificaciones de los algoritmos es los algoritmos computacionales. Lo mismo presentan una metodología organizada en pasos para su elaboración. De cada paso:\n   - a. Mencione su nombre\n   - b. Caracterice dicho paso\n3. Para representar los algoritmos computacionales existen tres técnicas para representarlo. Mencione dichas técnicas y establezca un cuadro comparativo entre ambas técnicas con sus ventajas y desventajas según su criterio. Dicho cuadro comparativo de quedar de la siguiente manera:\n\nTécnicas Ventajas Desventajas\n\nSeudocódigo\n\nDiagrama de flujo\n\nDiagrama de rectangulares\n\nestructurado\n\n## 6. Actividades de evaluación:\n\n1. Diseñe un algoritmo que permita elaborar una tortilla. Para eso cuenta con huevo, fogón de gas, fósforos, sartén, plato, espumadera, sal y tenedor. Utilice una de las técnicas para representar algoritmo que sea mas de su agrado.\n2. Diseñe un algoritmo que permita calcular el valor del discriminante y mostrarlo por pantalla de una función de la forma ax²+bx+c. Tenga en cuenta que el algoritmo debe solicitar o pedir los valores de los coeficientes por pantalla. Utilice una de las técnicas para representar algoritmo que sea mas de su agrado.\n3. Diseñe un algoritmo que permita calcular la cantidad de soluciones reales y mostrarlo por pantalla de una función de la forma ax²+bx+c. Tenga en cuenta que el algoritmo debe solicitar o pedir los valores de los coeficientes por pantalla. Utilice una de las técnicas para representar algoritmo que sea mas de su agrado.\n4. Diseñe un algoritmo que permita calcular y mostrar por pantalla el factorial de un número natural N. Tenga en cuenta que el algoritmo debe solicitar o pedir el valor N por pantalla. Utilice una de las técnicas para representar algoritmo que sea mas de su agrado.\n5. Diseñe el algoritmo del juego del adivinador. El juego del adivinador consiste en que una persona piensa un número natural en el rango de 1 a 100 incluyendo los extremos mientras la otra persona (en este caso la computadora apoyándose en el algoritmo) le hará la siguiente pregunta \"El número pensado es mayor o igual que X\" donde X es un número cualquiera que está en el rango de 1 a 100. La persona siempre va responder Si o No en dependencia de que se cumpla la siguiente relación N >= X siendo N el número pensado. El algoritmo debe adivinar el número pensado por la persona realizando no mas de 7 veces la pregunta \"El número pensado es mayor o igual que X\". Una vez adivinado el número debe mostrarse por pantalla.\n6. Busque e instale en su móvil la aplicación SoloLearn, descargue el curso del lenguaje de programación de Java. Cree su perfil con los datos correctos (nombre y apellidos). En la tabla de posiciones o puntuación (Local/Todo) busque al usuario Luis Andrés Valido Fajardo y comiencen a seguirlo.\n\n## 7. Resumen:\n\nLos algoritmos son un conjunto de pasos secuenciales y ordenados que permiten lograr un objetivo. Que sean pasos secuenciales significa que deben ser ejecutados uno después de otro y que sean pasos ordenados quiere decir que deben llevar un orden quasi-obligatorio (u obligatorio en la mayoría de los casos). Como puede notar el algoritmo permite lograr un objetivo. O sea que éste es el camino que necesitamos para lograrlo. Los mismos se pueden clasificar atendiendo a varios criterios en nuestro caso los vamos a clasificar en informales y computacionales.\n\nPara los algoritmos computacionales existe un metodología para su diseño y técnicas de representarlos. Definir que técnica de representación es mejor es un gran dilema cada una tiene ",
                "metadata": {
                    "file_name": "Asignatura__Introducción_a_la_Programación.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "descargue el curso del lenguaje de programación de Java. Cree su perfil con los datos correctos (nombre y apellidos). En la tabla de posiciones o puntuación (Local/Todo) busque al usuario Luis Andrés Valido Fajardo y comiencen a seguirlo.\n\n## 7. Resumen:\n\nLos algoritmos son un conjunto de pasos secuenciales y ordenados que permiten lograr un objetivo. Que sean pasos secuenciales significa que deben ser ejecutados uno después de otro y que sean pasos ordenados quiere decir que deben llevar un orden quasi-obligatorio (u obligatorio en la mayoría de los casos). Como puede notar el algoritmo permite lograr un objetivo. O sea que éste es el camino que necesitamos para lograrlo. Los mismos se pueden clasificar atendiendo a varios criterios en nuestro caso los vamos a clasificar en informales y computacionales.\n\nPara los algoritmos computacionales existe un metodología para su diseño y técnicas de representarlos. Definir que técnica de representación es mejor es un gran dilema cada una tiene sus ventajas y desventajas. La utilización de una de estas va depender en gran medida de estos dos factores:\n\n- La complejidad algoritmo que se desea diseñar.\n- La facilidad de transcripción que tenga el programador del llevar el algoritmo representado en con una determinada técnica a un lenguaje de programación compresible por el computador.\n\n## 8. Glosario de términos:\n\nConsulte la bibliografía y define los siguientes conceptos\n\n- **Algoritmo:**\n- **Algoritmo computacional:**\n\n## 9. Bibliografía:\n\nLa Esencia de la Lógica de Programación-Básico. Omar Ivan Trejos Buriticá. Cap 2 pag 19. Cap 4 pag 45.\n\n## 10. Recursos educativos digitales RED:\n\n## 11. Próxima unidad:\n\nTranscripción de algoritmos a lenguaje de programación Java. Entrada y salida. Tipos de datos. Operadores aritméticos.\n",
                "metadata": {
                    "file_name": "Asignatura__Introducción_a_la_Programación.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema I Algoritmización\n# UNIVERSIDAD DE MATANZAS\n\n## INTRODUCCIÓN A LA SOLUCIÓN DE PROBLEMAS POR MEDIO DE COMPUTADORAS\n\n**Septiembre / 2019**\n\n**INTRODUCCIÓN A LA PROGRAMACIÓN**\n\n**INGENIERÍA EN INFORMÁTICA**\n\n**Presentación de la Asignatura IP**\n\n**Tema I: Algoritmización**\n\n- Solución de problemas mediante algoritmos informales.\n\n**Tema II: Estructuras de control**\n\n- Tipos de datos, variables, constantes.\n- Asignación, expresiones.\n- Estructuras de control alternativas y repetitivas.\n- Funciones.\n\n**Tema III: Arreglos**\n\n- Arreglos unidimensionales y bidimensionales.\n- Algoritmos básicos sobre arreglos.\n\n**Sistema de Evaluación**\n\nTipo de Evaluación Semana\n\nEvaluaciones frecuentes Todas las semanas\n\n1ra PP\n\n1da PP\n\nTarea extraclase\n\nExamen Final\n\n**Objetivos**\n\n- Caracterizar el proceso de construcción de un programa computacional.\n\n**Sumario**\n\n- Definición de Computadora.\n- Definición de Programa.\n- Definición de Lenguaje de Programación.\n- Definición de Algoritmo.\n- Etapas en la solución de un problema computacional.\n\n**Bibliografía**\n\n- La Esencia de la Lógica de Programación\n- Manual de Introducción a la Programación\n\n**Computadora**\n\nEs un dispositivo electrónico utilizado para procesar información y obtener resultados. Los datos y la información se pueden introducir en la computadora como entrada (input) y a continuación se procesan para producir una salida (output).\n\n**Componentes de una computadora**\n\n- **Hardware**\n\n**Programa**\n\nConjunto de instrucciones que van a ser procesadas por la computadora con el objetivo de efectuar determinadas acciones a fin de resolver un problema.\n\nEste conjunto de instrucciones debe ser escrito en algún lenguaje que la computadora pueda entender.\n\n**Lenguaje de programación**\n\nContiene:\n\n- Símbolos y palabras claves.\n- Reglas gramaticales para construir instrucciones sintáctica y semánticamente correctas.\n\n**Sintaxis**\n\nConjunto de normas que determinan cómo escribir las instrucciones del lenguaje.\n\n**Semántica**\n\nInterpretación de las instrucciones del lenguaje. Indica el significado de las mismas.\n\n**Clasificación**\n\n- Por su nivel de abstracción:\n  - Lenguajes bajo nivel\n  - Lenguajes de alto nivel\n- Por su ejecución:\n  - Compilados\n  - Interpretados\n\n**Algoritmo**\n\nEs un conjunto finito de instrucciones (pasos u órdenes) que indican una secuencia de operaciones a ejecutar para alcanzar un resultado que soluciona un problema dado. Pueden incluir secuencias, decisiones e iteraciones.\n\nMuchas veces existe más de un posible algoritmo para resolver efectivamente un problema.\n\n**Formas de representación**\n\n- Lenguaje natural\n- Pseudocódigo\n- Diagrama de flujo\n- Diagrama de actividades o bloques\n- Lenguaje de programación\n\n**Características**\n\nTodo algoritmo tiene tres partes: entrada, proceso y salida, y sus pasos describen la transformación de la entrada en la salida.\n\n- Finalidad\n- Orden\n- Finitud\n- Precisión y claridad\n- Entorno\n\n**Clasificación**\n\n- Algoritmo computacional\n- Algoritmo no computacional\n\nUn algoritmo es independiente tanto del lenguaje de programación en que se exprese como de la computadora en la que se ejecute.\n\n**Clasificación según los datos que procesa**\n\n- Particulares\n- Generales\n\n**Clasificación según la estructura de sus instrucciones o pasos**\n\n1. Lineal\n   - Secuencial\n   - Alternativo\n2. Iterativo\n   - Iterativo\n   - Recursivo\n\n**Etapas para resolver problemas computacionales**\n\n1. Comprensión y análisis del problema.\n2. Diseño y análisis del algoritmo.\n3. Implementación del algoritmo en un lenguaje de programación (Programa)\n4. Ejecución y validación del programa\n\n**Comprensión y análisis del problema**\n\n- Delimitar y entender el problema.\n- Determinar datos de entrada y salida.\n- Verificar restricciones de esos datos de E/S\n- Determinar si existe suficiente información para encontrar una solución\n\n**Diseño y análisis del algoritmo**\n\n- Hacer una figura, un diagrama.\n- Buscar fórmula.\n- Dividir el problema en varios subproblemas.\n- Ser ingenioso.\n\n**Ejecución y validación del programa**\n\n- Conocer un lenguaje de programación, las reglas que lo conforman y las particularidades del lenguaje.\n\n**Implementación del algoritmo en un lenguaje de programación**\n\n- Seleccionar juegos de datos adecuados.\n- Probar el programa.\n- Corregir e ir a la etapa 1 en caso de dar errores.\n\n**Conclusiones**\n\n- ¿Qué es un algoritmo?\n- ¿De qué formas pueden ser representados algoritmos?\n- ¿Qué características tienen los algoritmos?\n\nLas computadoras no son realmente tan inteligentes. Estas solamente siguen instrucciones, y si no son claras probablemente no funcionen como deben. En la próxima actividad comenzaremos a solucionar problemas mediante algoritmos.\n\n**Estudio independiente**\n\n1. Desarrolle un algoritmo que permita freír un huevo.\n2. Desarrollar un algoritmo para insertar una tarjeta SIM en un teléfono móvil.\n   - Entrada: tarjeta SIM, teléfono móvil.\n   - Acciones: quitar tapa, insertar tarjeta SIM, poner tapa.\n3. Genere un algoritmo para determi",
                "metadata": {
                    "file_name": "Guia de Aprendizaje 1.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "jecución y validación del programa**\n\n- Conocer un lenguaje de programación, las reglas que lo conforman y las particularidades del lenguaje.\n\n**Implementación del algoritmo en un lenguaje de programación**\n\n- Seleccionar juegos de datos adecuados.\n- Probar el programa.\n- Corregir e ir a la etapa 1 en caso de dar errores.\n\n**Conclusiones**\n\n- ¿Qué es un algoritmo?\n- ¿De qué formas pueden ser representados algoritmos?\n- ¿Qué características tienen los algoritmos?\n\nLas computadoras no son realmente tan inteligentes. Estas solamente siguen instrucciones, y si no son claras probablemente no funcionen como deben. En la próxima actividad comenzaremos a solucionar problemas mediante algoritmos.\n\n**Estudio independiente**\n\n1. Desarrolle un algoritmo que permita freír un huevo.\n2. Desarrollar un algoritmo para insertar una tarjeta SIM en un teléfono móvil.\n   - Entrada: tarjeta SIM, teléfono móvil.\n   - Acciones: quitar tapa, insertar tarjeta SIM, poner tapa.\n3. Genere un algoritmo para determinar el saldo de un celular.\n   - Entrada: Celular.\n   - Acciones: Desbloquear o bloquear teléfono, marcar un dígito, marcar un símbolo, llamar o colgar teléfono.\n\nFIN\n\nUNIVERSIDAD DE MATANZAS\n\ncosechando el saber for content.\n",
                "metadata": {
                    "file_name": "Guia de Aprendizaje 1.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema II Introducción al lenguaje de programación Java\n**Presentación: Tipos de Datos, Variables, Constantes, Identificadores**\n\n**Diapositiva 1: Título**\n*   **Página 1:** Es la **portada** de la presentación. Muestra el logo de la Universidad de Matanzas, el título principal \"TIPOS DE DATOS, VARIABLES, CONSTANTES, IDENTIFICADORES\", el contexto \"INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA\" y la fecha \"Julio / 2019\".\n\n**Diapositiva 2: Objetivos (Parte 1)**\n*   **Página 2:**  Presenta los dos primeros **objetivos** de la presentación: comprender las \"variables\" como parte esencial de la programación y entender los \"tipos de datos\" en el desarrollo de programas.\n\n**Diapositiva 3: Objetivos (Parte 2)**\n*   **Página 3:**  Continúa con los **objetivos**, ahora enfocándose en caracterizar los \"identificadores\" y las \"constantes\", también elementos importantes en la programación.\n\n**Diapositiva 4: Sumario**\n*   **Página 4:**  Muestra un **resumen** de los temas principales que se abordarán en la presentación: \"Variables\", \"Tipos de datos\", \"Constantes\" e \"Identificadores\".\n\n**Diapositiva 5: Bibliografía**\n*   **Página 5:**  Lista las **referencias** o libros utilizados para crear la presentación: \"La Esencia de la Lógica de Programación\", \"Manual algoritmos\" y \"Aprenda Java como si estuviera en primero\".\n\n**Diapositiva 6: Variables (Definición)**\n*   **Página 6:** Explica qué son las **variables** de forma informal (algo que cambia) y técnica (ubicación en memoria que se puede modificar).\n\n**Diapositiva 7: Variables (Declaración)**\n*   **Página 7:** Describe que las variables necesitan **declararse con un tipo de dato** antes de usarse, comparándolas con \"cajas\" de diferente tamaño en la memoria.\n\n**Diapositiva 8: Variables (Tipo y Nombre)**\n*   **Página 8:** Define cómo se construye una variable, combinando un **tipo de dato** y un **nombre**. Las variables pueden ser de tipos primitivos o referencias a objetos.\n\n**Diapositiva 9: Variables (Inicialización Implícita)**\n*   **Página 9:**  Indica que si no se asigna valor a una variable, esta se **inicializa** automáticamente con cero (primitivas) o `null` (referencia).\n\n**Diapositiva 10: Variables (Ejemplos)**\n*   **Página 10:** Muestra **ejemplos de código** de declaración e inicialización de variables (enteros, arreglos y arreglos con valores iniciales).\n\n**Diapositiva 11: Variables (Visibilidad)**\n*   **Página 11:** Introduce el concepto de la **visibilidad** o \"scope\" de las variables, que es la parte del programa donde se pueden utilizar.\n\n**Diapositiva 12: Variables (Visibilidad - Regla)**\n*   **Página 12:** Indica que, generalmente, las variables dentro de llaves `{}` solo son **visibles** dentro de esas llaves.\n\n**Diapositiva 13: Tipo de Datos (Introducción)**\n*   **Página 13:** Explica que todos los datos tienen un **tipo de dato** asociado, el cual define los valores y las operaciones posibles con la variable.\n\n**Diapositiva 14: Tipo de Datos (Jerarquía)**\n*   **Página 14:** Organiza los tipos de datos en una **jerarquía**, dividiéndolos en \"simples\" (numéricos, lógicos, carácter, cadena) y \"estructurados\" (arreglos, clases, TADs).\n\n**Diapositiva 15: Tipo de Datos - Numéricos (Introducción)**\n*   **Página 15:** Define los tipos de datos **numéricos** como los que representan valores escalares y permiten operaciones aritméticas.\n\n**Diapositiva 16: Tipo de Datos - Numéricos (Enteros)**\n*   **Página 16:** Describe los **enteros** como números sin decimales y que las operaciones no resultan en decimales. (Ej: 25, -96, 0).\n\n**Diapositiva 17: Tipo de Datos - Numéricos (Reales)**\n*   **Página 17:** Describe los **reales** como números con punto decimal y que las operaciones pueden resultar en decimales. (Ej: 12.3, -78.56, 45.0).\n\n**Diapositiva 18: Tipo de Datos - Lógicos**\n*   **Página 18:** Explica los tipos de datos **lógicos** (booleanos), que solo pueden ser \"verdadero\" o \"falso\".\n\n**Diapositiva 19: Tipo de Datos - Carácter**\n*   **Página 19:** Indica que los tipos de datos **carácter** son equivalentes al código ASCII para representar letras y símbolos.\n\n**Diapositiva 20: Tipo de Datos - Cadena de Caracteres (Introducción)**\n*   **Página 20:** Describe las **cadenas de caracteres** como texto, incluyendo nombres y direcciones.\n\n**Diapositiva 21: Tipo de Datos - Cadena de Caracteres (Limitaciones)**\n*   **Página 21:** Aclara que los números en cadenas pierden sus propiedades matemáticas y que estas se escriben entre comillas.\n\n**Diapositiva 22: Tipos de Datos - Java (Parte 1)**\n*   **Página 22:** Muestra una **tabla con tipos primitivos de Java** y sus rangos: `boolean`, `byte`, `short`, `int`, y `long`.\n\n**Diapositiva 23: Tipos de Datos - Java (Parte 2)**\n*   **Página 23:** Continúa la **tabla con tipos primitivos y referencias de Java**, mostrando: `float`, `double`, `char` y `String`.\n\n**Diapositiva 24: Constantes (Definición)**\n*   **Página 24:** Define las **constantes** como valores que no cambian durante la ejecución del programa.\n\n**Dia",
                "metadata": {
                    "file_name": "Conferencia II-TIPOS DE DATOS, VARIABLES,.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "s de datos **carácter** son equivalentes al código ASCII para representar letras y símbolos.\n\n**Diapositiva 20: Tipo de Datos - Cadena de Caracteres (Introducción)**\n*   **Página 20:** Describe las **cadenas de caracteres** como texto, incluyendo nombres y direcciones.\n\n**Diapositiva 21: Tipo de Datos - Cadena de Caracteres (Limitaciones)**\n*   **Página 21:** Aclara que los números en cadenas pierden sus propiedades matemáticas y que estas se escriben entre comillas.\n\n**Diapositiva 22: Tipos de Datos - Java (Parte 1)**\n*   **Página 22:** Muestra una **tabla con tipos primitivos de Java** y sus rangos: `boolean`, `byte`, `short`, `int`, y `long`.\n\n**Diapositiva 23: Tipos de Datos - Java (Parte 2)**\n*   **Página 23:** Continúa la **tabla con tipos primitivos y referencias de Java**, mostrando: `float`, `double`, `char` y `String`.\n\n**Diapositiva 24: Constantes (Definición)**\n*   **Página 24:** Define las **constantes** como valores que no cambian durante la ejecución del programa.\n\n**Diapositiva 25: Constantes (Almacenamiento)**\n*   **Página 25:**  Explica que las constantes ocupan un espacio **fijo en la memoria**.\n\n**Diapositiva 26: Constantes (Java)**\n*   **Página 26:**  Muestra que en Java, la palabra reservada `final` define una **constante**. (Ej: `final double PI`).\n\n**Diapositiva 27: Identificadores (Definición)**\n*   **Página 27:**  Define los **identificadores** como los nombres que se usan para referirse a las variables, constantes, funciones, etc.\n\n**Diapositiva 28: Identificadores (Reglas - Longitud)**\n*   **Página 28:** Indica que los identificadores no pueden tener más de **31 caracteres**.\n\n**Diapositiva 29: Identificadores (Reglas - Sensibilidad a Mayúsculas)**\n*   **Página 29:** Indica que los identificadores **distinguen** entre mayúsculas y minúsculas (case-sensitive).\n\n**Diapositiva 30: Identificadores (Reglas - Primer Carácter)**\n*   **Página 30:** Aclara que el primer carácter debe ser una **letra o `_`** (guion bajo), no un número.\n\n**Diapositiva 31: Identificadores (Reglas - Caracteres Válidos)**\n*   **Página 31:**  Enumera los **caracteres válidos** en un identificador: letras minúsculas (a-z), mayúsculas (A-Z), dígitos (0-9) y guion bajo (`_`).\n\n**Diapositiva 32: Identificadores (Reglas - Caracteres Inválidos)**\n*   **Página 32:** Indica que **no se permiten** espacios en blanco ni caracteres especiales como `#`, `$`, `%`, `*`, `&`.\n\n**Diapositiva 33: Identificadores (Palabras Reservadas)**\n*   **Página 33:**  Advierte que hay **palabras reservadas** en el lenguaje que no pueden usarse como identificadores.\n\n**Diapositiva 34: Identificadores (Ejemplos)**\n*   **Página 34:**  Lista ejemplos de **palabras reservadas**: `class`, `private`, `public`, etc.\n\n**Diapositiva 35: Identificadores (Buenas Prácticas)**\n*   **Página 35:**  Recomienda que los identificadores tengan **nombres claros** que describan lo que representan en el código.\n\n**Diapositiva 36: Conclusiones**\n*   **Página 36:**  Resume las **conclusiones** principales: declarar variables requiere tipo de dato e identificador, y variables con el mismo nombre solo pueden existir en distintos alcances.\n\n**Diapositiva 37: Estudio Independiente**\n*   **Página 37:**  Propone un **ejercicio** para definir el tipo de dato e identificador para almacenar datos de personas.\n\n**Diapositiva 38: Fin**\n*   **Página 38:** Es la diapositiva de **cierre**, con el logo de la Universidad y el lema \"cosechando el saber\".\n",
                "metadata": {
                    "file_name": "Conferencia II-TIPOS DE DATOS, VARIABLES,.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "\nTema II Introducción al lenguaje de programación Java\n1972\n\nUNIVERSIDAD\n\nDE MATANZAS\n\nTIPOS DE DATOS, VARIABLES, CONSTANTES, IDENTIFICADORES\n\nJulio / 2019\n\nINTRODUCCI ÓN A LA PROGRAMACI ÓN\n\nINGENIERÍA EN INFORMÁTICA\n\nObjetivos I Caracterizar las variables como parte de la construcción de un programa computacional. \n\nI Caracterizar los tipos de datos como parte de la construcción de un programa computacional. \n\nObjetivos I Caracterizar los identificadores como parte de la construcción de un programa computacional. \n\nI Caracterizar las constantes como parte de la construcción de un programa computacional. \n\nSumario I Variables. \n\nI Tipos de datos. \n\nI Constantes. \n\nI Identificadores. \n\nBibliografia I La Esencia de la Lógica de Programación. \n\nI Manual algoritmos. \n\nI Aprenda Java como si estuviera en primero. \n\nVariables Informalmente algo variable es algo que puede cambiar de un momento a otro. \n\nTécnicamente una variable es un campo de memoria al que se le puede cambiar su contenido cuantas veces sea necesario. \n\nVariables Para poder utilizar variables en el desarrollo de un programa de computador se debe primero decir qué tipo de dato van a almacenar pues las variables son como unas cajitas de diferentes tama˜\n\nnos y por tal motivo\n\nse deben declarar previamente para que el computador las dimensiones de acuerdo a las necesidades. \n\nVariables Una variable se define especificando el tipo y el nombre de dicha variable. Estas variables pueden ser tanto de tipos primitivos como referencias a objetos de alguna clase perteneciente al API de Java o generada por el programador. \n\nVariables Si no se especifica un valor en su declaración, las variable primitivas se inicializan a cero \\(salvo boolean y char\\). Análogamente las variables de tipo referencia son inicializadas por defecto a un valor especial: null. \n\nVariables Ejemplos\n\nint x ; /\\* D e c l a r a c i o n de la v a r i a b l e p r i m i t i v a x\n\n. Se i n i c i a l i z a a 0 \\*/\n\nint y = 5; /\\* D e c l a r a c i o n de la v a r i a b l e p r i m i t i v a y . Se i n i c i a l i z a a 5 \\*/\n\nint \\[\\] v e c t o r ; /\\* D e c l a r a c i o n n de un a r r a y . Se i n i c i a l i z a a n u l l \\*/\n\nv e c t o r = new int \\[ 1 0 \\] ; /\\*\n\nV e c t o r de 10 enteros , i n i c i a l i z a d o s a 0 \\*/\n\nd o u b l e \\[\\] v = \\{1.0 , 2.65 , 3 . 1 \\} ; /\\* D e c l a r a c i o n e i n i c i a l i z a c i o n de un v e c t o r de 3 e l e m e n t o s con los v a l o r e s e n t r e l l a v e s \\*/\n\nVariables Visibilidad\n\nSe entiende por visibilidad, ámbito o scope de una variable, la parte de la aplicación donde dicha variable es accesible y por lo tanto puede ser utilizada en una expresión. \n\nVariables Visibilidad\n\nEn general las variables declaradas dentro de unas llaves \\{\\}, es decir dentro de un bloque, son visibles y existen dentro de estas llaves. \n\nTipo de datos Todos los datos o variables tienen un tipo asociado con ellos. El tipo de dato determina la naturaleza del conjunto de valores que puede tomar una variable y las posibles operaciones que puede soportar. \n\n\n\nTipo de datos\n\nTipo de datos Númericos\n\nPermiten representar valores escalares de forma numérica, esto incluye a los números enteros y los reales. Este tipo de datos permiten realizar operaciones aritméticas comunes. \n\nTipo de datos Númericos\n\nUn dato de tipo entero es un número que no tiene punto decimal, por lo tanto en sus operaciones jamás va a generar decimales. \n\nPor ejemplo 25, -96 y 0. \n\nTipo de datos Númericos\n\nUn dato de tipo real es un número que tiene punto decimal, por lo tanto en sus operaciones puede generar decimales. Por ejemplo 12.3, -78.56 o 45.0. \n\nTipo de datos Lógicos\n\nSon aquellos que solo pueden tener dos valores \\(cierto o falso\\) ya que representan el resultado de una comparación entre otros datos \\(numéricos o alfanuméricos\\). \n\nTipo de datos Cáracter\n\nUn dato tipo carácter es un equivalente del Código ASCII\\(American Standard Code for Interchange Information\\). El código ASCII es el Código Internacional de equivalencias Internas en el Sistema Binario. \n\nTipo de datos Cadena de caracteres\n\nEs una secuencia de caracteres alfanuméricos que permiten representar valores identificables de forma descriptiva, esto incluye nombres de personas, direcciones, etc. \n\nTipo de datos Cadena de caracteres\n\nEs posible representar números como alfanuméricos, pero estos pierden su propiedad matemática, es decir no es posible hacer operaciones con ellos. Este tipo de datos se representan encerrados entre comillas. \n\nTipo de datos Java\n\nboolean true - false\n\nbyte\n\n\\[-128 .. 127\\]\n\nshort\n\n\\[-32,768 .. 32,767\\]\n\nint\n\n\\[-231 .. 231-1\\]\n\nlong\n\n\\[-263 .. 263-1\\]\n\nTipo de datos Java\n\nfloat\n\n\\[±3,4 ∗ 10−38 .. ±3,4 ∗ 1038\\]\n\ndouble\n\n\\[±1,7 ∗ 10−308 .. ±1,7 ∗ 10308\\]\n\nchar\n\n\\[ú0000’.. úffff’\\] o \\[0 .. 65.535\\]\n\nString\n\nSecuencia de carácteres\n\nConstantes En programación, una constante es un valor que no puede ser alterado/modificado durante la ejecución de un programa, únicamente puede ser le´ıdo. \n\nCo",
                "metadata": {
                    "file_name": "Conferencia II-TIPOS DE DATOS, VARIABLES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ternacional de equivalencias Internas en el Sistema Binario. \n\nTipo de datos Cadena de caracteres\n\nEs una secuencia de caracteres alfanuméricos que permiten representar valores identificables de forma descriptiva, esto incluye nombres de personas, direcciones, etc. \n\nTipo de datos Cadena de caracteres\n\nEs posible representar números como alfanuméricos, pero estos pierden su propiedad matemática, es decir no es posible hacer operaciones con ellos. Este tipo de datos se representan encerrados entre comillas. \n\nTipo de datos Java\n\nboolean true - false\n\nbyte\n\n\\[-128 .. 127\\]\n\nshort\n\n\\[-32,768 .. 32,767\\]\n\nint\n\n\\[-231 .. 231-1\\]\n\nlong\n\n\\[-263 .. 263-1\\]\n\nTipo de datos Java\n\nfloat\n\n\\[±3,4 ∗ 10−38 .. ±3,4 ∗ 1038\\]\n\ndouble\n\n\\[±1,7 ∗ 10−308 .. ±1,7 ∗ 10308\\]\n\nchar\n\n\\[ú0000’.. úffff’\\] o \\[0 .. 65.535\\]\n\nString\n\nSecuencia de carácteres\n\nConstantes En programación, una constante es un valor que no puede ser alterado/modificado durante la ejecución de un programa, únicamente puede ser le´ıdo. \n\nConstantes Una constante corresponde a una longitud fija de un área reservada en la memoria principal del ordenador, donde el programa almacena valores fijos. \n\nConstantes Java\n\nUna variable final tiene como caracter´ıstica el que su valor no puede ser modificado, o lo que es lo mismo, es una constante. Ejemplo: f i n a l d o u b l e PI = 3 . 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 ; \n\nIdentificadores El identificador es una secuencia de caracteres que sirve para nombrar entidades del lenguaje. Algunas de las de entidades que un identificador puede denotar son las variables, las constantes, los tipos de datos, las constantes, los métodos y los paquetes. \n\nIdentificadores Existen reglas para formar un identificador, y que no pueden ser violadas porque ocasionar´ıa errores en el proceso de compilación del programa: I La longitud puede ser hasta de 31\n\ncaracteres. \n\nIdentificadores I Se hace distinción entre letras mayúsculas y minúsculas. As´ı, Masa es considerado como un identificador distinto de masa y de MASA. \n\nIdentificadores I El primer carácter de un identificador debe ser siempre una letra o un \\( \\), es decir,no puede ser un d´ıgito. \n\nIdentificadores I Los caracteres admitidos en un identificador son las letras minúsculas de la a a la z, las letras mayúsculas de la A a la Z, los d´ıgitos del 0 al 9 y el carácter subrayado o underscore\\( \\). \n\nIdentificadores I Un identificador no puede contener espacios en blanco, ni otros caracteres distintos de los citados, como por ejemplo \\(\\#, $, %, \\*, &, etc.\\). \n\nIdentificadores Existen palabras que tienen un significado predefinido en el lenguaje, son las llamadas palabras reservadas y no pueden ser utilizadas como identificadores. \n\nIdentificadores Ejemplos: class, private, public, void, int, float, char, long, short, unsigned, signed, break, continues, if, else, for, while, do, const, return. \n\nIdentificadores Los identificadores deben no solo ser válidos sino que deben autodocumentar el programa, es decir, tener nombres que permitan conocer a simple vista qué representan, utilizando para ello tantos caracteres como sean necesarios. \n\nConclusiones I Para declarar una variable se necesita definir su tipo de dato e identificador. \n\nI En un programa puede existir varias variables del mismo tipo de dato, pero no con el mismo identificador \\(exceptuando aquellas que tengan un ámbito de vida diferente\\). \n\nEstudio independiente I Defina el tipo de dato y el identificador de las variables para almacenar los siguientes datos de una persona. \n\nI CI. \n\nI Nombre. \n\nI Edad. \n\nI Estatura. \n\nI Color de piel. \n\nUNIVERSIDAD\n\nDE MATANZAS\n\ncosechando el saber\n\n**FIN**\n\n\n# Document Outline\n\n+ Objetivos \n+ Sumario \n+ Biliografía \n+ Variables \n+ Tipos de datos \n+ Constantes \n+ Identificadores \n+ Conclusiones \n+ Estudio Independiente\n\n\n\n",
                "metadata": {
                    "file_name": "Conferencia II-TIPOS DE DATOS, VARIABLES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema II Introducción al lenguaje de programación Java\n**Presentación: Operadores y Expresiones**\n\n**1. Diapositiva: Título (Página 1)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Título: OPERADORES Y EXPRESIONES.\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Julio / 2019.\n*   **Descripción:** Esta es la **portada** de la presentación, presentando el tema y el contexto académico. Muestra la institución, el título principal y la fecha de la presentación.\n\n**2. Diapositiva: Objetivos (Página 2)**\n\n*   **Información:**\n    *   Objetivo 1: Caracterizar los operadores como parte de la construcción de un programa computacional.\n    *   Objetivo 2: Caracterizar las expresiones como parte de la construcción de un programa computacional.\n*   **Descripción:** Esta diapositiva define los **objetivos principales** de la presentación: comprender el rol de los operadores y las expresiones en el desarrollo de programas.\n\n**3. Diapositiva: Sumario (Página 3)**\n\n*   **Información:**\n    *   Temas: Operadores y Expresiones.\n*   **Descripción:** Ofrece un **resumen** conciso de los temas centrales de la presentación, indicando que se centrará en \"Operadores\" y \"Expresiones\".\n\n**4. Diapositiva: Bibliografía (Página 4)**\n\n*   **Información:**\n    *   Referencias: La Esencia de la Lógica de Programación, Manual algoritmos, Aprenda Java como si estuviera en primero.\n*   **Descripción:** Lista las **fuentes de consulta** que se utilizaron para preparar la presentación, proporcionando un contexto académico y de referencia.\n\n**5. Diapositiva: Operadores (Definición) (Página 5)**\n\n*   **Información:**\n    *   Definición: Los operadores son signos que nos permiten expresar relaciones entre variables y/o constantes, de las cuales normalmente se desprende un resultado.\n*   **Descripción:** Introduce el concepto general de **operadores**, definiéndolos como los símbolos que permiten establecer relaciones y obtener resultados a partir de variables y constantes.\n\n**6. Diapositiva: Operadores (Clasificación - Parte 1) (Página 6)**\n\n*   **Información:**\n    *   Clasificación: Operadores aritméticos, Operadores de asignación, Operadores unarios, Operador instanceof.\n*   **Descripción:** Comienza la **clasificación de los operadores**, presentando los aritméticos, de asignación, unarios y el operador instanceof.\n\n**7. Diapositiva: Operadores (Clasificación - Parte 2) (Página 7)**\n\n*   **Información:**\n    *   Clasificación: Operadores incrementales, Operadores relacionales, Operadores lógicos.\n*   **Descripción:** Continúa la **clasificación de los operadores**, mostrando los incrementales, relacionales y lógicos.\n\n**8. Diapositiva: Operadores (Clasificación - Parte 3) (Página 8)**\n\n*   **Información:**\n    *   Clasificación: Operadores que actúan a nivel de bits, Operador condicional ?:, Operador de concatenación de cadenas de caracteres (+).\n*   **Descripción:** Finaliza la **clasificación de los operadores**, presentando los operadores a nivel de bits, el condicional y el de concatenación.\n\n**9. Diapositiva: Operadores (Aritméticos) (Página 9)**\n\n*   **Información:**\n    *   Definición: Son operadores binarios que realizan las operaciones aritméticas habituales: suma (+), resta (-), multiplicación (*), división (/) y resto de la división (%).\n*   **Descripción:** Describe los **operadores aritméticos**, indicando que son binarios y presentan las operaciones básicas matemáticas.\n\n**10. Diapositiva: Operadores (Asignación - Introducción) (Página 10)**\n\n*   **Información:**\n    *   Definición: Los operadores de asignación permiten asignar un valor a una variable. El operador de asignación por excelencia es el operador igual (=). Forma general: `variable = expression;`\n*   **Descripción:** Introduce los **operadores de asignación**, explicando su propósito principal (asignar un valor) e indicando el operador principal, el igual (=).\n\n**11. Diapositiva: Operadores (Asignación - Abreviados) (Página 11)**\n\n*   **Información:**\n    *   Explicación: Java dispone de versiones abreviadas del operador (=) que realizan operaciones \"acumulativas\" sobre una variable.\n*   **Descripción:** Presenta los **operadores de asignación abreviados** como una forma más corta de realizar ciertas operaciones sobre una variable.\n\n**12. Diapositiva: Operadores (Asignación - Tabla Introducción) (Página 12)**\n\n*   **Información:**\n    *   Texto: La siguiente tabla muestra estos operadores y su equivalencia con el uso del operador igual (=).\n*   **Descripción:** Introducción a las tablas de **operadores de asignación abreviados** y su equivalencia al operador de asignación base (=)\n\n**13. Diapositiva: Operadores (Asignación - Tabla Parte 1) (Página 13)**\n\n*   **Información:**\n    *   Tabla de operadores: +=, -=, *=  y su equivalencia.\n*   **Descripción:** Muestra los primeros **operadores de asignación abreviados**, indicando su uso y la expresión equivalente usando el operador igual (=).\n\n**14. ",
                "metadata": {
                    "file_name": "Conferencia III-OPERADORES Y EXPRESIONES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": ") (Página 11)**\n\n*   **Información:**\n    *   Explicación: Java dispone de versiones abreviadas del operador (=) que realizan operaciones \"acumulativas\" sobre una variable.\n*   **Descripción:** Presenta los **operadores de asignación abreviados** como una forma más corta de realizar ciertas operaciones sobre una variable.\n\n**12. Diapositiva: Operadores (Asignación - Tabla Introducción) (Página 12)**\n\n*   **Información:**\n    *   Texto: La siguiente tabla muestra estos operadores y su equivalencia con el uso del operador igual (=).\n*   **Descripción:** Introducción a las tablas de **operadores de asignación abreviados** y su equivalencia al operador de asignación base (=)\n\n**13. Diapositiva: Operadores (Asignación - Tabla Parte 1) (Página 13)**\n\n*   **Información:**\n    *   Tabla de operadores: +=, -=, *=  y su equivalencia.\n*   **Descripción:** Muestra los primeros **operadores de asignación abreviados**, indicando su uso y la expresión equivalente usando el operador igual (=).\n\n**14. Diapositiva: Operadores (Asignación - Tabla Parte 2) (Página 14)**\n\n*   **Información:**\n    *   Tabla de operadores: /=, %=  y su equivalencia.\n*  **Descripción:** Continúa la tabla de **operadores de asignación abreviados**, mostrando otros como `/=` y `%=`, indicando su uso y su equivalencia.\n\n**15. Diapositiva: Operadores (Unarios) (Página 15)**\n\n*   **Información:**\n    *   Definición: Los operadores más (+) y menos (-) unarios sirven para mantener o cambiar el signo de una variable, constante o expresión numérica.\n*   **Descripción:** Explica la funcionalidad de los **operadores unarios**, + y -, para cambiar el signo de los valores.\n\n**16. Diapositiva: Operadores (instanceof) (Página 16)**\n\n*   **Información:**\n    *   Definición: El operador instanceof permite saber si un objeto pertenece o no a una determinada clase. Devuelve true o false según el objeto pertenezca o no a la clase.\n    *   Forma general: `objectName instanceof ClassName`\n*   **Descripción:** Define el **operador `instanceof`**, mostrando cómo se utiliza para verificar la pertenencia de un objeto a una clase específica.\n\n**17. Diapositiva: Operadores (Incrementales - Introducción) (Página 17)**\n\n*   **Información:**\n    *   Definición: Java dispone del operador incremento (++) y decremento (--). El operador (++) incrementa en una unidad la variable, mientras que (--) la reduce en una unidad.\n*   **Descripción:** Presenta los **operadores incrementales** (`++`) y decrementales (`--`), explicando cómo aumentan o disminuyen el valor de una variable en uno.\n\n**18. Diapositiva: Operadores (Incrementales - Precediendo) (Página 18)**\n\n*   **Información:**\n    *   Uso: Cuando precede a la variable (ej: ++i), primero se incrementa la variable y luego se utiliza en la expresión.\n*   **Descripción:** Explica cómo funcionan los operadores incrementales cuando **preceden a la variable**, primero incrementan y luego se utiliza el valor.\n\n**19. Diapositiva: Operadores (Incrementales - Siguiendo) (Página 19)**\n\n*   **Información:**\n    *   Uso: Cuando sigue a la variable (ej: i++), primero se utiliza la variable en la expresión (con el valor anterior) y luego se incrementa.\n*   **Descripción:** Explica cómo funcionan los operadores incrementales cuando **siguen a la variable**, primero se utiliza el valor y luego se incrementa.\n\n**20. Diapositiva: Operadores (Relacionales - Introducción) (Página 20)**\n\n*   **Información:**\n    *   Definición: Sirven para realizar comparaciones de igualdad, desigualdad y relación de menor o mayor. El resultado siempre es un valor boolean (true o false).\n*   **Descripción:** Introduce los **operadores relacionales** como aquellos que permiten realizar comparaciones, cuyo resultado es siempre un valor booleano.\n\n**21. Diapositiva: Operadores (Relacionales - Tabla Parte 1) (Página 21)**\n\n*   **Información:**\n     *  Tabla de operadores: `>`, `<`, `>=`, su uso y cuando la comparación es cierta.\n*   **Descripción:** Muestra algunos **operadores relacionales**, su uso y la condición para que la comparación sea verdadera.\n\n**22. Diapositiva: Operadores (Relacionales - Tabla Parte 2) (Página 22)**\n\n*   **Información:**\n    *   Tabla de operadores lógicos: `&& (AND)`, `|| (OR)` y su uso y resultado.\n*  **Descripción:**  Muestra la tabla con los **operadores lógicos AND y OR** indicando cuando resulta verdadero.\n\n**23. Diapositiva: Operadores (Relacionales - Tabla Parte 3) (Página 23)**\n\n*  **Información:**\n     * Tabla de operadores lógicos: `! (negación)` y `& (AND)` con su uso y resultado.\n*   **Descripción:** Muestra la tabla con la **negación** y el operador AND que hace evaluación completa,  indicando su uso y cuando resulta verdadero.\n\n**24. Diapositiva: Operadores (Relacionales - Tabla Parte 4) (Página 24)**\n\n*  **Información:**\n     * Tabla del operador lógico: `| (OR)` con su uso y resultado.\n*   **Descripción:** Muestra la tabla con el operador OR que hace evaluación completa, indicando su uso y cuando resulta verdadero.\n\n**25. Diapos",
                "metadata": {
                    "file_name": "Conferencia III-OPERADORES Y EXPRESIONES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " su uso y la condición para que la comparación sea verdadera.\n\n**22. Diapositiva: Operadores (Relacionales - Tabla Parte 2) (Página 22)**\n\n*   **Información:**\n    *   Tabla de operadores lógicos: `&& (AND)`, `|| (OR)` y su uso y resultado.\n*  **Descripción:**  Muestra la tabla con los **operadores lógicos AND y OR** indicando cuando resulta verdadero.\n\n**23. Diapositiva: Operadores (Relacionales - Tabla Parte 3) (Página 23)**\n\n*  **Información:**\n     * Tabla de operadores lógicos: `! (negación)` y `& (AND)` con su uso y resultado.\n*   **Descripción:** Muestra la tabla con la **negación** y el operador AND que hace evaluación completa,  indicando su uso y cuando resulta verdadero.\n\n**24. Diapositiva: Operadores (Relacionales - Tabla Parte 4) (Página 24)**\n\n*  **Información:**\n     * Tabla del operador lógico: `| (OR)` con su uso y resultado.\n*   **Descripción:** Muestra la tabla con el operador OR que hace evaluación completa, indicando su uso y cuando resulta verdadero.\n\n**25. Diapositiva: Operadores (Lógicos) (Página 25)**\n\n*   **Información:**\n    *   Definición: Los operadores lógicos se utilizan para construir expresiones lógicas, combinando valores lógicos (true y/o false) o los resultados de los operadores relacionales.\n*   **Descripción:**  Introduce los **operadores lógicos**, explicando que se usan para combinar resultados booleanos y crear expresiones más complejas.\n\n**26. Diapositiva: Operadores (A Nivel de Bits - Introducción) (Página 26)**\n\n*   **Información:**\n    *   Definición: Es un conjunto de operadores que actúan a nivel de bits. Las operaciones de bits se utilizan para definir señales o flags.\n*   **Descripción:** Explica los **operadores a nivel de bits**, indicando que se usan para la manipulación de bits individuales y la definición de flags.\n\n**27. Diapositiva: Operadores (A Nivel de Bits - Desplazamiento Derecho) (Página 27)**\n\n*   **Información:**\n    *   Operador: `>>`.\n    *   Resultado: Desplaza los bits de op1 a la derecha una distancia op2.\n*   **Descripción:** Describe el **operador de desplazamiento a la derecha `>>`**, indicando cómo modifica los bits.\n\n**28. Diapositiva: Operadores (A Nivel de Bits - Desplazamiento Izquierdo) (Página 28)**\n\n*   **Información:**\n    *   Operador: `<<`.\n    *   Resultado: Desplaza los bits de op1 a la izquierda una distancia op2.\n*   **Descripción:** Describe el **operador de desplazamiento a la izquierda `<<`**, indicando cómo modifica los bits.\n\n**29. Diapositiva: Operadores (A Nivel de Bits - Desplazamiento Derecho Sin Signo) (Página 29)**\n\n*   **Información:**\n    *   Operador: `>>>`.\n    *   Resultado: Desplaza los bits de op1 a la derecha una distancia op2 (positiva).\n*   **Descripción:** Describe el **operador de desplazamiento a la derecha sin signo `>>>`**, indicando cómo modifica los bits (rellenando con ceros a la izquierda)\n\n**30. Diapositiva: Operadores (A Nivel de Bits - AND y OR) (Página 30)**\n\n*   **Información:**\n    *   Operadores: `& (AND)`, `| (OR)`.\n    *   Resultados: Operador AND y OR a nivel de bits.\n*   **Descripción:** Describe los operadores AND y OR a nivel de bit.\n\n**31. Diapositiva: Operadores (A Nivel de Bits - XOR y Complemento) (Página 31)**\n\n*   **Información:**\n    *  Operadores: `^ (XOR)` y `~ (Complemento)`.\n    * Resultados: Operador XOR a nivel de bits y operador complemento (invierte el valor de cada bit)\n*   **Descripción:** Describe los operadores XOR y complemento a nivel de bit.\n\n**32. Diapositiva: Operadores (A Nivel de Bits - Asignación 1) (Página 32)**\n\n*   **Información:**\n   * Tabla de operadores de asignación a nivel de bits: `&=`, `|=`, `^=`, y `<<=` y su equivalencia.\n*   **Descripción:** Muestra los operadores de asignación a nivel de bits, indicando su uso y equivalencia.\n\n**33. Diapositiva: Operadores (A Nivel de Bits - Asignación 2) (Página 33)**\n\n*   **Información:**\n   * Tabla de operadores de asignación a nivel de bits: `>>>=` y `>>=` y su equivalencia.\n*   **Descripción:** Continua con los operadores de asignación a nivel de bits, indicando su uso y equivalencia.\n\n**34. Diapositiva: Operadores (Condicional ?:) (Página 34)**\n\n*   **Información:**\n    *   Definición: Permite realizar bifurcaciones condicionales sencillas. Forma general: `booleanExpression ? res1 : res2`.\n*   **Descripción:** Explica el **operador condicional `?:`**, mostrando cómo realiza bifurcaciones basadas en una expresión booleana.\n\n**35. Diapositiva: Operadores (Concatenación de Cadenas +) (Página 35)**\n\n*   **Información:**\n    *   Definición: El operador más (+) se utiliza también para concatenar cadenas de caracteres.\n*  **Descripción:** Explica la funcionalidad del **operador + para la concatenación de cadenas**, mostrando un ejemplo de uso.\n\n**36. Diapositiva: Operadores (Precedencia) (Página 36)**\n\n*   **Información:**\n    *   Explicación: El orden en que se realizan las operaciones es fundamental. (Referencia a la página 24 de \"Aprenda Java como si estuviera en primero\").\n*   **Descripción:** Enfatiza ",
                "metadata": {
                    "file_name": "Conferencia III-OPERADORES Y EXPRESIONES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "s de asignación a nivel de bits, indicando su uso y equivalencia.\n\n**34. Diapositiva: Operadores (Condicional ?:) (Página 34)**\n\n*   **Información:**\n    *   Definición: Permite realizar bifurcaciones condicionales sencillas. Forma general: `booleanExpression ? res1 : res2`.\n*   **Descripción:** Explica el **operador condicional `?:`**, mostrando cómo realiza bifurcaciones basadas en una expresión booleana.\n\n**35. Diapositiva: Operadores (Concatenación de Cadenas +) (Página 35)**\n\n*   **Información:**\n    *   Definición: El operador más (+) se utiliza también para concatenar cadenas de caracteres.\n*  **Descripción:** Explica la funcionalidad del **operador + para la concatenación de cadenas**, mostrando un ejemplo de uso.\n\n**36. Diapositiva: Operadores (Precedencia) (Página 36)**\n\n*   **Información:**\n    *   Explicación: El orden en que se realizan las operaciones es fundamental. (Referencia a la página 24 de \"Aprenda Java como si estuviera en primero\").\n*   **Descripción:** Enfatiza la importancia de la **precedencia de operadores** para la evaluación correcta de expresiones, y referencia un material de estudio.\n\n**37. Diapositiva: Sentencias o Expresiones (Definición de Expresión) (Página 37)**\n\n*   **Información:**\n    *   Definición: Una expresión es un conjunto variables unidos por operadores. Son órdenes que se le dan al computador.\n*   **Descripción:** Define una **expresión** como una combinación de variables y operadores, que indican una operación a realizar por el ordenador.\n\n**38. Diapositiva: Sentencias o Expresiones (Definición de Sentencia) (Página 38)**\n\n*   **Información:**\n    *   Definición: Una sentencia es una expresión que acaba en punto y coma (;). Se permite incluir varias sentencias en una línea.\n*   **Descripción:** Define una **sentencia** como una expresión que finaliza con un punto y coma, que también funciona como una orden completa.\n\n**39. Diapositiva: Sentencias o Expresiones (Clasificación) (Página 39)**\n\n*   **Información:**\n     * Clasificación: Aritméticas, relacionales, lógicas\n*   **Descripción:** Clasifica las **expresiones** según el tipo de dato que manipulan en: aritméticas, relacionales y lógicas.\n\n**40. Diapositiva: Conclusiones (Página 40)**\n\n*   **Información:**\n     *  Conclusión 1: Los operadores relacionales se utilizan con mucha frecuencia en las bifurcaciones y en los bucles.\n     * Conclusión 2: Un programa puede constar desde una expresión o sentencia hasta miles ellas.\n*   **Descripción:** Presenta las **conclusiones** principales de la presentación, resaltando el uso de los operadores relacionales y la cantidad de sentencias en un programa.\n\n**41. Diapositiva: Estudio Independiente (Página 41)**\n\n*   **Información:**\n    *   Ejercicio: Fragmento de código con operaciones. Pregunta: ¿Qué valores quedan en las variables a, b y c?\n*  **Descripción:** Propone un **ejercicio** para que los estudiantes apliquen los conocimientos sobre operadores, determinando los valores de variables después de una serie de operaciones.\n\n**42. Diapositiva: Fin (Página 42)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva de **cierre** de la presentación, con el logo de la universidad, su lema y la palabra \"FIN\".\n",
                "metadata": {
                    "file_name": "Conferencia III-OPERADORES Y EXPRESIONES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema II Introducción al lenguaje de programación Java\n**Presentación: Captura y Salida de Datos en Java (Teclado y Pantalla)**\n\n**1. Diapositiva: Título (Página 1)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Título: CAPTURA Y SALIDA DE DATOS EN JAVA (TECLADO Y PANTALLA).\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Agosto / 2019.\n*   **Descripción:** Esta diapositiva es la **portada** de la presentación, presentando el tema y el contexto de la misma. Incluye el logo de la Universidad de Matanzas, el título principal y la fecha.\n\n**2. Diapositiva: Objetivos (Página 2)**\n\n*   **Información:**\n    *   Objetivo 1: Caracterizar la captura de datos como parte de la construcción de un programa computacional.\n    *   Objetivo 2: Caracterizar la salida de datos como parte de la construcción de un programa computacional.\n*   **Descripción:** Esta diapositiva define los **objetivos** de la presentación, que son: comprender el proceso de captura de datos y comprender el proceso de salida de datos, como partes fundamentales en la construcción de un programa.\n\n**3. Diapositiva: Sumario (Página 3)**\n\n*   **Información:**\n    *   Temas: Captura de datos por teclado con Java. Salida de datos por pantalla con Java.\n*   **Descripción:**  Presenta un **resumen** de los temas principales que se abordarán en la presentación: la captura de datos a través del teclado y la salida de datos hacia la pantalla, ambos en Java.\n\n**4. Diapositiva: Bibliografía (Página 4)**\n\n*   **Información:**\n    *   Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*  **Descripción:** Lista las **fuentes bibliográficas** que fueron utilizadas para la creación de esta presentación.\n\n**5. Diapositiva: Flujo (Introducción) (Página 5)**\n\n*   **Información:**\n    *   Definición: Por lo general, las operaciones de entrada y salida de datos se llevan a cabo con flujos, los cuales son secuencias de bytes.\n*   **Descripción:** Introduce el concepto de **flujo (stream)** como la forma general de manejar operaciones de entrada y salida, donde la información se maneja como secuencias de bytes.\n\n**6. Diapositiva: Flujo (Entrada) (Página 6)**\n\n*   **Información:**\n    *   Definición: En las operaciones de entrada, los bytes fluyen de un dispositivo (como un teclado, una unidad de disco, una conexión de red) a la memoria principal.\n*   **Descripción:** Describe el **flujo en las operaciones de entrada**, que ocurre cuando los bytes se transfieren desde un dispositivo externo a la memoria principal.\n\n**7. Diapositiva: Flujo (Salida) (Página 7)**\n\n*  **Información:**\n    * Definición: En las operaciones de salida, los bytes fluyen de la memoria principal a un dispositivo (como una pantalla, una impresora, una unidad de disco, una conexión de red).\n*  **Descripción:** Describe el **flujo en las operaciones de salida**, que ocurre cuando los bytes se transfieren desde la memoria principal a un dispositivo externo.\n\n**8. Diapositiva: Flujo (Conexiones Automáticas) (Página 8)**\n\n*  **Información:**\n    * Definición: Cuando empieza la ejecución de un programa, tres flujos se conectan a éste de manera automática.\n*  **Descripción:** Explica que al iniciar la ejecución de un programa, **tres flujos se conectan automáticamente** para la entrada, la salida y los errores.\n\n**9. Diapositiva: Flujo (Flujos Estándar) (Página 9)**\n\n*   **Información:**\n    *   Definición: El flujo de entrada estándar se conecta al teclado, y el flujo de salida estándar se conecta a la pantalla. El flujo de error estándar (System.err), se conecta generalmente a la pantalla.\n*  **Descripción:** Indica los **flujos estándar** utilizados por defecto: teclado para la entrada, pantalla para la salida y también para los errores.\n\n**10. Diapositiva: Clases de Java para Lectura y Escritura de Datos (Página 10)**\n\n*   **Información:**\n    *   Definición: El package `java.io` contiene las clases necesarias para la comunicación del programa con el exterior. Existen dos familias de jerarquías distintas para la entrada/salida de datos.\n*  **Descripción:** Introduce el **package `java.io`**, que contiene las clases necesarias para la comunicación entre un programa y el exterior, y las familias de jerarquías que existen para la entrada/salida de datos.\n\n**11. Diapositiva: Captura de Datos (Introducción) (Página 11)**\n\n*   **Información:**\n    *   Definición: En Java, la entrada desde teclado está regulado a través de la clase `System`. `System.in` es un objeto de la clase `InputStream` para recibir datos.\n*   **Descripción:** Inicia la sección sobre **captura de datos**, indicando que la clase `System` es la que maneja la entrada, y el objeto `System.in` es de la clase `InputStream`.\n\n**12. Diapositiva: Captura de Datos (InputStream.read()) (Página 12)**\n\n*   **Información:**\n    *   Definición: Para leer desde teclado se puede utilizar el método `System.in.read()` de la clase `InputStream`.\n*   **Descripc",
                "metadata": {
                    "file_name": "Conferencia IV-CAPTURA Y SALIDA DE DATOS EN.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "cación del programa con el exterior. Existen dos familias de jerarquías distintas para la entrada/salida de datos.\n*  **Descripción:** Introduce el **package `java.io`**, que contiene las clases necesarias para la comunicación entre un programa y el exterior, y las familias de jerarquías que existen para la entrada/salida de datos.\n\n**11. Diapositiva: Captura de Datos (Introducción) (Página 11)**\n\n*   **Información:**\n    *   Definición: En Java, la entrada desde teclado está regulado a través de la clase `System`. `System.in` es un objeto de la clase `InputStream` para recibir datos.\n*   **Descripción:** Inicia la sección sobre **captura de datos**, indicando que la clase `System` es la que maneja la entrada, y el objeto `System.in` es de la clase `InputStream`.\n\n**12. Diapositiva: Captura de Datos (InputStream.read()) (Página 12)**\n\n*   **Información:**\n    *   Definición: Para leer desde teclado se puede utilizar el método `System.in.read()` de la clase `InputStream`.\n*   **Descripción:** Presenta el método `read()` de la clase `InputStream` como una forma de **leer datos desde el teclado**.\n\n**13. Diapositiva: Captura de Datos (InputStream.read() - Conversión) (Página 13)**\n\n*   **Información:**\n    *   Definición: Este método lee un carácter por cada Ilamada y retorna un `int`. Si se espera otro tipo hay que hacer una conversión explícita mediante un `cast`.\n    *   Ejemplo: `char c = (char)System.in.read();`\n*   **Descripción:**  Explica cómo el método `read()` lee un carácter y retorna un `int`, y cómo debe realizarse un `cast` para convertir el resultado a un `char`.\n\n**14. Diapositiva: Captura de Datos (Lectura de Cadenas - Bucle) (Página 14)**\n\n*   **Información:**\n    *   Definición: Para leer datos más largos que un simple carácter es necesario emplear un bucle `while` o `for` y unir los caracteres.\n   *  Ejemplo de código:\n    ```java\n        char c;\n        String frase = new String(\"\");\n        while((c=System.in.read()) != '\\n')\n            frase = frase + c; // frase.append(c);\n    ```\n*   **Descripción:** Muestra la necesidad de usar un **bucle para leer cadenas de caracteres**, uniendo los caracteres leídos.\n\n**15. Diapositiva: Captura de Datos (BufferedReader - Introducción) (Página 15)**\n\n*   **Información:**\n    *   Definición: Para facilitar la lectura de teclado se puede conseguir que se lea una línea entera con una sola orden si se utiliza un objeto `BufferedReader`.\n*  **Descripción:** Presenta una alternativa para facilitar la lectura de texto, usando un objeto `BufferedReader`, que permite leer líneas enteras.\n\n**16. Diapositiva: Captura de Datos (BufferedReader - readLine()) (Página 16)**\n\n*   **Información:**\n    *   Definición: El método String `readLine()` perteneciente a `BufferedReader` lee todos los caracteres hasta encontrar un '\\n' o '\\r' y los devuelve como un `String` (sin incluir '\\n' ni '\\r').\n*   **Descripción:** Describe el funcionamiento del método `readLine()` de la clase `BufferedReader`, que lee caracteres hasta encontrar un salto de línea y devuelve un `String`.\n\n**17. Diapositiva: Captura de Datos (BufferedReader - Ejemplo) (Página 17)**\n\n*   **Información:**\n    * Ejemplo de código:\n     ```java\n      InputStreamReader isr = new InputStreamReader(System.in);\n      BufferedReader br = new BufferedReader(isr);\n      //o en una linea:\n      //BufferedReader br2 = new BufferedReader(new InputStreamReader(System.in));\n      String frase = br2.readLine();\n      // Se lee la linea con una llamada\n     ```\n*   **Descripción:** Muestra un **ejemplo de código** para leer una línea completa de la entrada, usando `BufferedReader` con diferentes constructores.\n\n**18. Diapositiva: Captura de Datos (StringTokenizer) (Página 18)**\n\n*  **Información:**\n   *   Definición: La clase `java.util.StringTokenizer` da la posibilidad de separar una cadena de caracteres en las \"palabras\" (tokens) que la forman. Cuando sea preciso se pueden convertir las \"palabras\" en números.\n*  **Descripción:**  Introduce la clase `StringTokenizer`, que se utiliza para **dividir una cadena en tokens** o palabras.\n\n**19. Diapositiva: Captura de Datos (StringTokenizer - Referencia) (Página 19)**\n\n*   **Información:**\n    *   Referencia: En el libro \"Aprenda Java como si estuviera en primero\" página 154 están los métodos más prácticos de la clase StringTokenizer.\n*   **Descripción:** Indica una **referencia en el libro** \"Aprenda Java como si estuviera en primero\" donde se pueden encontrar los métodos de la clase `StringTokenizer`.\n\n**20. Diapositiva: Captura de Datos (Scanner - Introducción) (Página 20)**\n\n*   **Información:**\n    *   Definición: Otra variante para la lectura de datos en Java es utilizando la clase `Scanner`. La clase `Scanner` está disponible a partir de Java 5 y facilita la lectura de datos en los programas Java.\n*  **Descripción:** Introduce la clase `Scanner` como otra **alternativa para leer datos** desde la entrada estándar (teclado), disponible desde Java 5.\n\n**21. Diapositiva: ",
                "metadata": {
                    "file_name": "Conferencia IV-CAPTURA Y SALIDA DE DATOS EN.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ce la clase `StringTokenizer`, que se utiliza para **dividir una cadena en tokens** o palabras.\n\n**19. Diapositiva: Captura de Datos (StringTokenizer - Referencia) (Página 19)**\n\n*   **Información:**\n    *   Referencia: En el libro \"Aprenda Java como si estuviera en primero\" página 154 están los métodos más prácticos de la clase StringTokenizer.\n*   **Descripción:** Indica una **referencia en el libro** \"Aprenda Java como si estuviera en primero\" donde se pueden encontrar los métodos de la clase `StringTokenizer`.\n\n**20. Diapositiva: Captura de Datos (Scanner - Introducción) (Página 20)**\n\n*   **Información:**\n    *   Definición: Otra variante para la lectura de datos en Java es utilizando la clase `Scanner`. La clase `Scanner` está disponible a partir de Java 5 y facilita la lectura de datos en los programas Java.\n*  **Descripción:** Introduce la clase `Scanner` como otra **alternativa para leer datos** desde la entrada estándar (teclado), disponible desde Java 5.\n\n**21. Diapositiva: Captura de Datos (Scanner - Import) (Página 21)**\n\n*   **Información:**\n    *   Instrucción: `import java.util.Scanner;`\n*   **Descripción:** Explica que, para usar la clase `Scanner`, es necesario incluir la instrucción `import java.util.Scanner;` al inicio del programa.\n\n**22. Diapositiva: Captura de Datos (Scanner - Import) (Página 22)**\n\n*   **Información:**\n    *   Instrucción: `import java.util.Scanner;`\n*   **Descripción:** Muestra nuevamente la instrucción `import java.util.Scanner;` que debe agregarse al inicio del programa para poder usar la clase `Scanner`\n\n**23. Diapositiva: Captura de Datos (Scanner - Creación de Objeto) (Página 23)**\n\n*   **Información:**\n    *   Instrucción: `Scanner sc = new Scanner(System.in);`\n*   **Descripción:** Explica cómo **crear un objeto** de la clase `Scanner` asociado a la entrada estándar.\n\n**24. Diapositiva: Captura de Datos (Scanner - Métodos nextXxx()) (Página 24)**\n\n*   **Información:**\n    *   Definición: Para leer datos podemos usar el método `nextXxx()` donde Xxx indica en tipo, por ejemplo `nextInt()` para leer un entero, `nextDouble()` para leer un double, etc.\n*   **Descripción:**  Describe los **métodos `nextXxx()`** de la clase `Scanner` para leer datos específicos (enteros, double, etc.) desde el teclado.\n\n**25. Diapositiva: Salida de Datos (Introducción) (Página 25)**\n\n*   **Información:**\n    *   Definición: En Java, la salida a pantalla está regulado a través de la clase `System`. `System.out` es un objeto de la clase `PrintStream` que imprimirá los datos.\n*   **Descripción:**  Inicia la sección sobre **salida de datos**, explicando que la salida a la pantalla se maneja a través de la clase `System`, con el objeto `System.out` de la clase `PrintStream`.\n\n**26. Diapositiva: Salida de Datos (System.out - print()) (Página 26)**\n\n*   **Información:**\n    *   Definición: Con la función `print()` imprime en pantalla el argumento que se le pase. Puede recibir cualquier tipo primitivo de variable de Java.\n    *   Ejemplo: `System.out.print(\"Hola, Mundo!\");`\n*   **Descripción:** Explica el método `print()` de la clase `System.out`, indicando que imprime en la pantalla el argumento, que puede ser de cualquier tipo primitivo.\n\n**27. Diapositiva: Salida de Datos (System.out - println()) (Página 27)**\n\n*  **Información:**\n    *  Definición: Con la función `println()` imprime en pantalla el argumento que se le pase. Puede recibir cualquier tipo primitivo de variable de Java. Añadiendo `\\n` al final.\n    * Ejemplo: `System.out.println(\"Hola, Mundo!\");`\n*  **Descripción:**  Explica el método `println()` de la clase `System.out`, similar a `print()` pero añadiendo un salto de línea al final.\n\n**28. Diapositiva: Salida de Datos (System.out - Limitaciones) (Página 28)**\n\n*  **Información:**\n    * Explicación: Aunque imprime las variables de un modo legible, no permiten dar a la salida un formato (un valor real imprimir una cantidad determinada de lugares después de la coma) a medida. El programador no puede especificar un formato distinto al disponible por defecto.\n*  **Descripción:** Menciona una **limitación de `print()` y `println()`**: que no permiten personalizar el formato de la salida, como indicar la cantidad de decimales para números reales.\n\n**29. Diapositiva: Salida de Datos (System.out - printf() - Introducción) (Página 29)**\n\n*   **Información:**\n    *   Definición: Con `printf` podemos lograr un formato preciso en la salida.\n*   **Descripción:** Introduce el método `printf()` como una opción para obtener un **formato preciso** en la salida de datos.\n\n**30. Diapositiva: Salida de Datos (System.out - printf() - Prototipo) (Página 30)**\n\n*   **Información:**\n    *   Definición: La función `printf()` imprime el texto, las constantes y variables que se indiquen. Su prototipo: `System.out.printf(\"cadena_de_control\", arg1, arg2, ..., argn);`\n*   **Descripción:** Presenta el **prototipo del método `printf()`**, que incluye una cadena de control y argumentos.\n\n**31. Diapositiva: S",
                "metadata": {
                    "file_name": "Conferencia IV-CAPTURA Y SALIDA DE DATOS EN.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "de especificar un formato distinto al disponible por defecto.\n*  **Descripción:** Menciona una **limitación de `print()` y `println()`**: que no permiten personalizar el formato de la salida, como indicar la cantidad de decimales para números reales.\n\n**29. Diapositiva: Salida de Datos (System.out - printf() - Introducción) (Página 29)**\n\n*   **Información:**\n    *   Definición: Con `printf` podemos lograr un formato preciso en la salida.\n*   **Descripción:** Introduce el método `printf()` como una opción para obtener un **formato preciso** en la salida de datos.\n\n**30. Diapositiva: Salida de Datos (System.out - printf() - Prototipo) (Página 30)**\n\n*   **Información:**\n    *   Definición: La función `printf()` imprime el texto, las constantes y variables que se indiquen. Su prototipo: `System.out.printf(\"cadena_de_control\", arg1, arg2, ..., argn);`\n*   **Descripción:** Presenta el **prototipo del método `printf()`**, que incluye una cadena de control y argumentos.\n\n**31. Diapositiva: Salida de Datos (System.out - printf() - Funcionamiento) (Página 31)**\n\n*  **Información:**\n    * Definición: La función `printf()` imprime el texto contenido en `cadena_de_control` junto con el valor de los otros argumentos, de acuerdo con los formatos incluidos en `cadena_de_control`.\n*   **Descripción:** Explica cómo el método `printf()` imprime texto y valores de argumentos basándose en el formato indicado en la `cadena_de_control`.\n\n**32. Diapositiva: Salida de Datos (System.out - printf() - Ejemplo) (Página 32)**\n\n*  **Información:**\n   *   Ejemplo:\n    ```java\n       int i=1;\n       double tiempo=2.4;\n       float masa=100.56;\n       System.out.printf(\"Resultado no: %d. En el instante %lf la masa vale %.4f\\n\",i, tiempo, masa);\n    ```\n*  **Descripción:** Muestra un **ejemplo** de cómo usar `printf()` con especificadores de formato, mostrando como imprimir diferentes tipos de datos.\n\n**33. Diapositiva: Salida de Datos (System.out - printf() - Referencia) (Página 33)**\n\n*   **Información:**\n    *   Referencia: Para conocer acerca de este aspecto puede consultar el libro \"Cómo programar en Java\" página 1276.\n*   **Descripción:** Indica una **referencia** para obtener mayor información sobre el uso del método `printf()`, remitiendo a la página 1276 del libro \"Cómo programar en Java\".\n\n**34. Diapositiva: Conclusiones (Captura de Datos) (Página 34)**\n\n*   **Información:**\n    *   Conclusiones sobre la Captura de datos:\n        1.  System.in\n        2.  BufferedReader + StringTokenizer\n        3.  Scanner\n*   **Descripción:**  Presenta un **resumen de las formas de captura de datos**, indicando las tres opciones principales vistas en la presentación: el uso directo de `System.in`, la combinación de `BufferedReader` y `StringTokenizer`, y la clase `Scanner`.\n\n**35. Diapositiva: Conclusiones (Salida de Datos) (Página 35)**\n\n*  **Información:**\n    * Conclusiones sobre la Salida de datos:\n         *   System.out\n             *   print()\n             *   println()\n             *   printf()\n     *    Texto: Existen otras variantes pero con lo anterior es suficiente por ahora.\n*   **Descripción:**  Presenta un **resumen de las formas de salida de datos** con los métodos `print()`, `println()` y `printf()` del objeto `System.out`, indicando que existen otras variantes.\n\n**36. Diapositiva: Estudio Independiente (Página 36)**\n\n*   **Información:**\n    *   Ejercicios: Realizar los ejercicios A+B y Harder A+B de Athens Online Judge (aoj.umcc.cu).\n*   **Descripción:**  Propone un **ejercicio práctico** para que los estudiantes utilicen los conceptos de entrada y salida de datos en el contexto de ejercicios publicados en el Athens Online Judge.\n\n**37. Diapositiva: Fin (Página 37)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:**  Esta diapositiva indica el **final de la presentación**, con el logo de la universidad, su lema y la palabra \"FIN\".\n",
                "metadata": {
                    "file_name": "Conferencia IV-CAPTURA Y SALIDA DE DATOS EN.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema II Introducción al lenguaje de programación Java\n**Presentación: Bucles o Sentencias Repetitivas**\n\n**1. Diapositiva: Título (Página 1)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Título: BUCLES O SENTENCIAS REPETITIVAS.\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Septiembre / 2019.\n*   **Descripción:** Esta diapositiva es la **portada** de la presentación. Muestra el logo de la Universidad de Matanzas, el título principal, el subtítulo con el contexto de la presentación y la fecha.\n\n**2. Diapositiva: Objetivos (Parte 1) (Página 2)**\n\n*   **Información:**\n    *   Objetivo: Caracterizar los bucles o sentencias repetitivas como parte de la construcción de un programa computacional.\n*   **Descripción:** Esta diapositiva presenta el primer **objetivo** principal de la presentación: entender el papel de los bucles o sentencias repetitivas en el proceso de desarrollo de programas.\n\n**3. Diapositiva: Objetivos (Parte 2) (Página 3)**\n\n*   **Información:**\n    *   Objetivo: Identificar el tipo de bucle o sentencia repetitiva a utilizar en la construcción de un programa computacional.\n*   **Descripción:**  Presenta el segundo **objetivo** de la presentación: saber cómo elegir qué tipo de bucle es el más adecuado para un determinado programa.\n\n**4. Diapositiva: Sumario (Página 4)**\n\n*   **Información:**\n    *   Temas: Sentencia `for`, Sentencia `while`, Sentencia `do ... while`, Sentencia `break` y `continue`.\n*   **Descripción:**  Ofrece un **resumen** de los temas principales que se tratarán: los distintos tipos de bucles y sentencias relacionadas.\n\n**5. Diapositiva: Bibliografía (Página 5)**\n\n*   **Información:**\n    *   Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*   **Descripción:** Lista las **fuentes bibliográficas** utilizadas para la elaboración de la presentación.\n\n**6. Diapositiva: Bucle (Definición) (Página 6)**\n\n*   **Información:**\n    *   Definición: Un bucle se utiliza para realizar un proceso repetidas veces. Se denomina también lazo o loop. El código se ejecuta mientras se cumpla una condición.\n*   **Descripción:** Define el concepto general de **bucle**, como una herramienta para repetir un proceso un número determinado de veces, indicando también que se conoce como lazo o loop.\n\n**7. Diapositiva: Bucle (Instrucción de Repetición) (Página 7)**\n\n*   **Información:**\n     *Definición: Una instrucción de repetición permite al programador especificar que un programa debe repetir una acción mientras cierta condición sea verdadera.\n*   **Descripción:** Define los bucles como **instrucciones de repetición**, donde un programa repite una acción mientras cierta condición sea verdadera.\n\n**8. Diapositiva: Bucle while (Introducción y Seudocódigo) (Página 8)**\n\n*   **Información:**\n    *   Definición: Es una instrucción de repetición que permite repetir ciertas instrucciones mientras cierta condición sea verdadera.\n    *   Seudocódigo: \"Mientras tenga artículos en la lista de compras, Comprar el artículo y Quitarlo de mi lista\".\n*   **Descripción:** Introduce el **bucle `while`**, explicando que repite instrucciones mientras una condición sea verdadera y presenta un ejemplo de pseudocódigo para ejemplificar su uso.\n\n**9. Diapositiva: Bucle while (Sintaxis) (Página 9)**\n\n*   **Información:**\n    *   Sintaxis: `while (booleanExpression) { statements; }`.  Donde si la `booleanExpression` devuelve verdadero se ejecutará el grupo de instrucciones.\n*   **Descripción:** Presenta la **sintaxis del bucle `while`**, detallando cómo se utiliza una expresión booleana para controlar la ejecución del bloque de código.\n\n**10. Diapositiva: Bucle while (Ejemplo) (Página 10)**\n\n*   **Información:**\n     * Ejemplo:\n     ```java\n           int producto = 3;\n           while ( producto <= 100 ){\n               producto = 3 * producto;\n           }\n     ```\n     * Texto:  Un segmento de programa diseñado para encontrar la primera potencia de 3 que sea mayor a 100.\n*   **Descripción:**  Muestra un **ejemplo de código del uso del bucle `while`** para encontrar la primera potencia de 3 que sea mayor que 100.\n\n**11. Diapositiva: Bucle for (Introducción y Seudocódigo) (Página 11)**\n\n*   **Información:**\n    *   Definición: Java también cuenta con la instrucción de repetición `for`, que especifica los detalles de la repetición controlada por contador en una sola línea de código.\n    *   Seudocódigo: \"Asignar variable factorial el valor 0. Para cada `x` en \\[1, 100] con paso 1, Asignar a factorial el valor de factorial * x\".\n*   **Descripción:**  Introduce el **bucle `for`**, explicando que permite especificar los detalles de repetición controlada por contador en una sola línea de código, y muestra un ejemplo de pseudocódigo.\n\n**12. Diapositiva: Bucle for (Sintaxis y Equivalencia) (Página 12)**\n\n*   **Información:**\n    *  Sintaxis:\n    ```java\n       for(initialization; booleanExpression; increment){\n          statement",
                "metadata": {
                    "file_name": "Conferencia V -BUCLES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "encia de 3 que sea mayor a 100.\n*   **Descripción:**  Muestra un **ejemplo de código del uso del bucle `while`** para encontrar la primera potencia de 3 que sea mayor que 100.\n\n**11. Diapositiva: Bucle for (Introducción y Seudocódigo) (Página 11)**\n\n*   **Información:**\n    *   Definición: Java también cuenta con la instrucción de repetición `for`, que especifica los detalles de la repetición controlada por contador en una sola línea de código.\n    *   Seudocódigo: \"Asignar variable factorial el valor 0. Para cada `x` en \\[1, 100] con paso 1, Asignar a factorial el valor de factorial * x\".\n*   **Descripción:**  Introduce el **bucle `for`**, explicando que permite especificar los detalles de repetición controlada por contador en una sola línea de código, y muestra un ejemplo de pseudocódigo.\n\n**12. Diapositiva: Bucle for (Sintaxis y Equivalencia) (Página 12)**\n\n*   **Información:**\n    *  Sintaxis:\n    ```java\n       for(initialization; booleanExpression; increment){\n          statements;\n       }\n    ```\n    *   Texto: Es equivalente a utilizar while en la siguiente forma:\n        ```java\n           initialization;\n           while (booleanExpression) {\n              statements;\n              increment;\n           }\n        ```\n*   **Descripción:**  Presenta la **sintaxis del bucle `for`** y su equivalencia utilizando un bucle `while`, mostrando sus tres componentes principales: inicialización, condición y modificación de variable.\n\n**13. Diapositiva: Bucle for (Explicación) (Página 13)**\n\n*   **Información:**\n    *  Explicación: La sentencia o sentencias initialization se ejecuta al comienzo del for, e increment después de statements. La booleanExpression se evalúa al comienzo de cada iteración; el bucle termina cuando la expresión de comparación toma el valor false.\n*   **Descripción:** Explica la **secuencia de ejecución** de un bucle `for`: inicialización, condición, cuerpo del bucle y luego el incremento de la variable.\n\n**14. Diapositiva: Bucle for (Componentes del Encabezado) (Página 14)**\n\n*  **Información:**\n    * Muestra los diferentes componentes del encabezado de la instrucción `for`\n*  **Descripción:** Muestra de manera visual la estructura del encabezado del bucle `for`, separando cada componente para su fácil entendimiento.\n\n**15. Diapositiva: Bucle for (Flexibilidad y Ejemplo) (Página 15)**\n\n*   **Información:**\n    *   Definición: Cualquiera de las tres partes puede estar vacía. La initialization y el increment pueden tener varias expresiones separadas por comas.\n    *   Ejemplo de código:\n     ```java\n       for(int i=1,j=i+10;i<5;i++,j=2*i){\n          System.out.println(\"i=\"+i+\" j= \"+j);\n       }\n     ```\n*   **Descripción:** Explica que todas las partes del encabezado `for` son opcionales y ofrece un **ejemplo** donde varias expresiones pueden estar separadas por comas.\n\n**16. Diapositiva: Bucle do ... while (Introducción) (Página 16)**\n\n*   **Información:**\n    *   Definición: Es similar al bucle while pero con la particularidad de que el control está al final del bucle (lo que hace que el bucle se ejecute al menos una vez).\n*   **Descripción:**  Introduce el **bucle `do...while`**, explicando que es similar al `while` pero con la diferencia de que su condición se evalúa al final del bucle.\n\n**17. Diapositiva: Bucle do ... while (Funcionamiento) (Página 17)**\n\n*   **Información:**\n     *  Definición: Una vez ejecutados los statements, se evalúa la condición: si resulta true se vuelven a ejecutar las sentencias incluidas en el bucle, mientras que si la condición se evalúa a false finaliza el bucle.\n*   **Descripción:** Describe el **funcionamiento del bucle `do...while`**, indicando que el bloque de código se ejecuta al menos una vez y luego la condición se evalúa para las siguientes iteraciones.\n\n**18. Diapositiva: Bucle do ... while (Seudocódigo) (Página 18)**\n\n*   **Información:**\n   * Seudocódigo:\n   ```java\n      Hacer:\n      Comprar el artículo\n      Quitarlo de mi lista\n      Mientras tenga artículos en la lista de compras\n   ```\n*   **Descripción:**  Presenta un **ejemplo de pseudocódigo** para el uso del bucle `do...while`.\n\n**19. Diapositiva: Bucle do ... while (Sintaxis y Ejemplo) (Página 19)**\n\n*   **Información:**\n    *   Sintaxis:\n    ```java\n        do {\n           statements;\n         } while (booleanExpression);\n    ```\n    * Ejemplo:\n     ```java\n        int contador = 1;\n        do {\n          System.out.printf(\"%d \",contador);\n          ++contador;\n         } while ( contador <= 10 );\n        System.out.println();\n      ```\n*   **Descripción:**  Presenta la **sintaxis** del bucle `do...while` con un ejemplo de código.\n\n**20. Diapositiva: Sentencia break (Página 20)**\n\n*   **Información:**\n    *   Definición: La sentencia `break` es válida tanto para las bifurcaciones como para los bucles. Hace que se salga inmediatamente del bucle o bloque.\n*   **Descripción:** Explica la **sentencia `break`**, cuyo propósito es finalizar la ejecución de un bloque de código o un bucle",
                "metadata": {
                    "file_name": "Conferencia V -BUCLES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " en la lista de compras\n   ```\n*   **Descripción:**  Presenta un **ejemplo de pseudocódigo** para el uso del bucle `do...while`.\n\n**19. Diapositiva: Bucle do ... while (Sintaxis y Ejemplo) (Página 19)**\n\n*   **Información:**\n    *   Sintaxis:\n    ```java\n        do {\n           statements;\n         } while (booleanExpression);\n    ```\n    * Ejemplo:\n     ```java\n        int contador = 1;\n        do {\n          System.out.printf(\"%d \",contador);\n          ++contador;\n         } while ( contador <= 10 );\n        System.out.println();\n      ```\n*   **Descripción:**  Presenta la **sintaxis** del bucle `do...while` con un ejemplo de código.\n\n**20. Diapositiva: Sentencia break (Página 20)**\n\n*   **Información:**\n    *   Definición: La sentencia `break` es válida tanto para las bifurcaciones como para los bucles. Hace que se salga inmediatamente del bucle o bloque.\n*   **Descripción:** Explica la **sentencia `break`**, cuyo propósito es finalizar la ejecución de un bloque de código o un bucle.\n\n**21. Diapositiva: Sentencia continue (Página 21)**\n\n*   **Información:**\n    *   Definición: La sentencia `continue` se utiliza en los bucles. Finaliza la iteración actual y vuelve al comienzo del bucle para continuar con la siguiente iteración.\n*   **Descripción:** Describe la **sentencia `continue`**, que permite saltarse las instrucciones restantes en una iteración de un bucle y continuar con la siguiente iteración.\n\n**22. Diapositiva: Conclusiones (Bucle do...while) (Página 22)**\n\n*  **Información:**\n    *   Conclusión: El do while se utiliza con frecuencia para controlar la satisfacción de una determinada condición de error o de convergencia.\n*  **Descripción:** Presenta una **conclusión** sobre la aplicación del bucle do...while, explicando en que tipo de situación se utiliza con mayor frecuencia.\n\n**23. Diapositiva: Conclusiones (Bucles Infinitos) (Página 23)**\n\n*   **Información:**\n    *   Conclusión: Prestar especial atención a los bucles infinitos, hecho que ocurre cuando la condición de finalizar el bucle no se llega a cumplir nunca.\n*   **Descripción:**  Advierte sobre los **bucles infinitos**, que ocurren cuando la condición de terminación nunca se cumple.\n\n**24. Diapositiva: Conclusiones (Tipos de Estructuras de Control) (Página 24)**\n\n*   **Información:**\n    *   Conclusión: Java sólo tiene tres tipos de estructuras de control: Secuencia, Selección (4 tipos) y Repetición (3 tipos).\n*   **Descripción:**  Resume los **tres tipos de estructuras de control** de Java: secuencial, selectiva y repetitiva.\n\n**25. Diapositiva: Conclusiones (Combinación de Instrucciones) (Página 25)**\n\n*   **Información:**\n    *   Conclusión: Cada programa se forma combinando tantas instrucciones de secuencia, selección y repetición como sea apropiado para el algoritmo que implemente el programa.\n*  **Descripción:** Explica que los programas se forman utilizando una **combinación de instrucciones** de secuencia, selección y repetición.\n\n**26. Diapositiva: Fin (Página 26)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva final, indicando el **cierre de la presentación**.",
                "metadata": {
                    "file_name": "Conferencia V -BUCLES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema II Introducción al lenguaje de programación Java\n**Presentación: Bifurcaciones o Sentencias Condicionales**\n\n**1. Diapositiva: Título (Página 1)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Título: BIFURCACIONES O SENTENCIAS CONDICIONALES.\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Septiembre / 2019.\n*   **Descripción:**  Esta es la diapositiva de **portada** de la presentación. Contiene el logo de la Universidad de Matanzas, el título de la presentación, el subtítulo que especifica el contexto y la fecha.\n\n**2. Diapositiva: Objetivos (Parte 1) (Página 2)**\n\n*   **Información:**\n    *   Objetivo: Caracterizar las bifurcaciones o sentencias condicionales como parte de la construcción de un programa computacional.\n*  **Descripción:**  Presenta el primer **objetivo** de la presentación: entender el papel de las bifurcaciones (sentencias condicionales) en la construcción de un programa.\n\n**3. Diapositiva: Objetivos (Parte 2) (Página 3)**\n\n*  **Información:**\n    * Objetivo: Identificar el tipo de bifuración o sentencias condicionales a utilizar en la construcción de un programa computacional.\n*  **Descripción:**  Presenta el segundo **objetivo** de la presentación, que es identificar el tipo de sentencia condicional adecuada para construir un programa.\n\n**4. Diapositiva: Objetivos (Parte 3) (Página 4)**\n\n*   **Información:**\n    *   Objetivo: Utilizar el tipo de bifurcación o sentencias condicionales para elegir entre distintas acciones alternativas.\n*  **Descripción:** Presenta el tercer **objetivo** de la presentación:  cómo utilizar las sentencias condicionales para elegir entre diferentes acciones.\n\n**5. Diapositiva: Sumario (Página 5)**\n\n*  **Información:**\n    *   Temas: Bifurcación `if`, Bifurcación `if else`, Bifurcación `if elseif else`, Sentencia `switch`.\n*  **Descripción:** Presenta un **resumen** de los temas principales que se tratarán en la presentación:  los distintos tipos de sentencias condicionales.\n\n**6. Diapositiva: Bibliografía (Página 6)**\n\n*  **Información:**\n    *   Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*   **Descripción:**  Lista las **fuentes bibliográficas** utilizadas para la preparación de la presentación.\n\n**7. Diapositiva: Estructura de Control (Ejecución Secuencial) (Página 7)**\n\n*   **Información:**\n    * Definición: Generalmente, en un programa las instrucciones se ejecutan una después de otra, en el orden en que están escritas. Este proceso se conoce como ejecución secuencial.\n*  **Descripción:** Explica la **ejecución secuencial**, que es el comportamiento por defecto de los programas, donde las instrucciones se ejecutan en orden.\n\n**8. Diapositiva: Estructura de Control (Transferencia de Control) (Página 8)**\n\n*   **Información:**\n    *   Definición: Varias instrucciones en Java permiten al programador especificar que la siguiente instrucción a ejecutarse tal vez no sea la siguiente en la secuencia. Esto se conoce como transferencia de control.\n*  **Descripción:** Introduce el concepto de **transferencia de control**, donde el orden de ejecución de las instrucciones puede variar.\n\n**9. Diapositiva: Estructura de Control (Tipos) (Página 9)**\n\n*   **Información:**\n    *   Tipos de estructuras de control en Java: La instrucción de secuencia, Las instrucciones de selección, Las instrucciones de repetición.\n*   **Descripción:**  Indica que Java cuenta con **tres tipos de estructuras de control**: secuenciales, selectivas y repetitivas.\n\n**10. Diapositiva: Bifurcación (Definición) (Página 10)**\n\n*   **Información:**\n    *  Definición: Las bifurcaciones permiten ejecutar una de entre varias acciones en función del valor de una expresión lógica o relacional.\n*   **Descripción:** Define el concepto general de **bifurcación**, como la capacidad de un programa para elegir entre diferentes acciones basándose en el valor de una expresión.\n\n**11. Diapositiva: Bifurcación (Tipos) (Página 11)**\n\n*   **Información:**\n    *  Definición: Son las encargadas de controlar el flujo de ejecución de un programa. Existen dos bifurcaciones diferentes: `if` y `switch`.\n*   **Descripción:**  Explica que las bifurcaciones son **estructuras de control del flujo del programa**, y menciona las dos formas más importantes: `if` y `switch`.\n\n**12. Diapositiva: Bifurcación if (Introducción) (Página 12)**\n\n*   **Información:**\n    *   Definición: Permite ejecutar un conjunto de sentencias en función del valor que tenga la expresión de comparación (se ejecuta si es `true`).\n*   **Descripción:** Introduce el **bucle `if`**, explicando que permite ejecutar un bloque de código solo si la expresión booleana asociada se evalúa como verdadera.\n\n**13. Diapositiva: Bifurcación if (Sintaxis) (Página 13)**\n\n*  **Información:**\n    *  Sintaxis:\n        ```java\n            if (booleanExpression) {\n               statements;\n            }\n        ```\n     * Texto: Las llaves `{}` sirven para agrupa",
                "metadata": {
                    "file_name": "Conferencia VI-BIFURACIONES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Página 11)**\n\n*   **Información:**\n    *  Definición: Son las encargadas de controlar el flujo de ejecución de un programa. Existen dos bifurcaciones diferentes: `if` y `switch`.\n*   **Descripción:**  Explica que las bifurcaciones son **estructuras de control del flujo del programa**, y menciona las dos formas más importantes: `if` y `switch`.\n\n**12. Diapositiva: Bifurcación if (Introducción) (Página 12)**\n\n*   **Información:**\n    *   Definición: Permite ejecutar un conjunto de sentencias en función del valor que tenga la expresión de comparación (se ejecuta si es `true`).\n*   **Descripción:** Introduce el **bucle `if`**, explicando que permite ejecutar un bloque de código solo si la expresión booleana asociada se evalúa como verdadera.\n\n**13. Diapositiva: Bifurcación if (Sintaxis) (Página 13)**\n\n*  **Información:**\n    *  Sintaxis:\n        ```java\n            if (booleanExpression) {\n               statements;\n            }\n        ```\n     * Texto: Las llaves `{}` sirven para agrupar en un bloque las sentencias que se han de ejecutar, y no son necesarias si sólo hay una sentencia dentro del if.\n*  **Descripción:**  Muestra la **sintaxis del `if`**, explicando que las llaves se utilizan para agrupar múltiples sentencias y son opcionales si hay una sola instrucción.\n\n**14. Diapositiva: Bifurcación if (Ejemplo) (Página 14)**\n\n*  **Información:**\n    *   Seudocódigo: \"Si la calificación es mayor o igual a 3, Imprimir Aprobado\".\n    *   Código:\n    ```java\n      if ( calificacion >= 3 ) {\n           System.out.println( \"Aprobado\" );\n      }\n    ```\n*   **Descripción:** Muestra un **ejemplo sencillo** de cómo utilizar la instrucción `if` en un programa de Java.\n\n**15. Diapositiva: Bifurcación if else (Introducción) (Página 15)**\n\n*  **Información:**\n    *   Definición: Análoga a la anterior, de la cual es una ampliación. Las sentencias incluidas en el `else` se ejecutan en el caso de no cumplirse la expresión de comparación (false).\n*  **Descripción:** Introduce la bifurcación `if else`, una **extensión del `if`** donde se especifica un bloque de código alternativo a ejecutar cuando la condición es falsa.\n\n**16. Diapositiva: Bifurcación if else (Sintaxis) (Página 16)**\n\n*  **Información:**\n    *  Sintaxis:\n     ```java\n         if (booleanExpression) {\n             statements1;\n          } else {\n            statements2;\n         }\n     ```\n*  **Descripción:** Muestra la **sintaxis de `if else`**, donde un bloque de código (`statements1`) se ejecuta si la condición es verdadera y un bloque alternativo (`statements2`) se ejecuta si la condición es falsa.\n\n**17. Diapositiva: Bifurcación if else (Ejemplo - Seudocódigo) (Página 17)**\n\n*   **Información:**\n    *   Seudocódigo: \"Si la calificación es mayor o igual a 3, Imprimir Aprobado. Sino, Imprimir Reprobado\".\n*   **Descripción:**  Presenta el **pseudocódigo** de un ejemplo de como utilizar la instrucción `if else`\n\n**18. Diapositiva: Bifurcación if else (Ejemplo - Código) (Página 18)**\n\n*  **Información:**\n   * Ejemplo:\n    ```java\n     if ( calificacion >= 3 ) {\n       System.out.println( \"Aprobado\" );\n      } else {\n       System.out.println( \"Reprobado\" );\n      }\n    ```\n*  **Descripción:**  Muestra un **ejemplo de código** utilizando `if else` para imprimir un mensaje diferente si una calificación es aprobatoria o no.\n\n**19. Diapositiva: Bifurcación if elseif else (Introducción) (Página 19)**\n\n*   **Información:**\n    *  Definición: Permite introducir más de una expresión de comparación. Si la primera condición no se cumple, se compara la segunda y así sucesivamente.\n*  **Descripción:** Introduce la bifurcación `if elseif else`, explicando que permite **introducir múltiples condiciones** que serán evaluadas secuencialmente.\n\n**20. Diapositiva: Bifurcación if elseif else (Sintaxis) (Página 20)**\n\n*  **Información:**\n    * Sintaxis:\n    ```java\n        if (booleanExpression1) {\n           statements1;\n         } else if (booleanExpression2) {\n           statements2;\n         } else if (booleanExpression3) {\n             statements3;\n         } else {\n             statements4;\n        }\n     ```\n*  **Descripción:**  Presenta la **sintaxis del `if elseif else`**, mostrando cómo se encadenan múltiples condiciones y la forma de incluir un `else` opcional al final.\n\n**21. Diapositiva: Bifurcación if elseif else (Ejemplo - Seudocódigo) (Página 21)**\n\n*   **Información:**\n    * Seudocódigo:\n    ```java\n         Si la calificación es mayor o igual a 5, Imprimir Excelente\n         Sino, si la calificación es mayor o igual a 4, Imprimir Bien\n         Sino, si la calificación es mayor o igual a 3, Imprimir Regular\n         Sino, Imprimir Mal\n    ```\n*  **Descripción:** Presenta el **pseudocódigo** de un ejemplo de como utilizar la instrucción `if elseif else`.\n\n**22. Diapositiva: Bifurcación if elseif else (Ejemplo - Código) (Página 22)**\n\n*  **Información:**\n  * Ejemplo:\n    ```java\n       if ( calificacionEstudiante >= 5 )\n        System.out.println( \"Excelente\" );\n ",
                "metadata": {
                    "file_name": "Conferencia VI-BIFURACIONES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "else if (booleanExpression3) {\n             statements3;\n         } else {\n             statements4;\n        }\n     ```\n*  **Descripción:**  Presenta la **sintaxis del `if elseif else`**, mostrando cómo se encadenan múltiples condiciones y la forma de incluir un `else` opcional al final.\n\n**21. Diapositiva: Bifurcación if elseif else (Ejemplo - Seudocódigo) (Página 21)**\n\n*   **Información:**\n    * Seudocódigo:\n    ```java\n         Si la calificación es mayor o igual a 5, Imprimir Excelente\n         Sino, si la calificación es mayor o igual a 4, Imprimir Bien\n         Sino, si la calificación es mayor o igual a 3, Imprimir Regular\n         Sino, Imprimir Mal\n    ```\n*  **Descripción:** Presenta el **pseudocódigo** de un ejemplo de como utilizar la instrucción `if elseif else`.\n\n**22. Diapositiva: Bifurcación if elseif else (Ejemplo - Código) (Página 22)**\n\n*  **Información:**\n  * Ejemplo:\n    ```java\n       if ( calificacionEstudiante >= 5 )\n        System.out.println( \"Excelente\" );\n       else if ( calificacionEstudiante >= 4 )\n        System.out.println( \"Bien\" );\n       else if ( calificacionEstudiante >= 3 )\n        System.out.println( \"Regular\" );\n       else\n        System.out.println( \"Mal\" );\n    ```\n*  **Descripción:** Muestra un **ejemplo en código** del uso de `if elseif else` para clasificar una calificación en distintas categorías.\n\n**23. Diapositiva: Sentencia switch (Introducción) (Página 23)**\n\n*   **Información:**\n    *   Definición: Es una alternativa a la bifurcación if elseif else cuando se compara la misma expresión con distintos valores.\n*   **Descripción:** Introduce la **sentencia `switch`**, como una alternativa a `if elseif else` cuando se necesita comparar una expresión con diferentes valores concretos.\n\n**24. Diapositiva: Sentencia switch (Sintaxis) (Página 24)**\n\n*   **Información:**\n    * Sintaxis:\n    ```java\n    switch (expression) {\n          case value1: statements1; break;\n          case value2: statements2; break;\n          case value3: statements3; break;\n          case value4: statements4; break;\n          case value5: statements5; break;\n          default: statements6; break;\n      }\n    ```\n*   **Descripción:** Presenta la **sintaxis general** de la sentencia `switch`, mostrando cómo se utilizan `case` y `default`.\n\n**25. Diapositiva: Sentencia switch (Características - case) (Página 25)**\n\n*   **Información:**\n    *  Definición: Cada sentencia case se corresponde con un único valor de expresión. No se pueden establecer rangos sino que se debe comparar con valores concretos.\n*   **Descripción:** Explica que en `switch`, cada `case` corresponde a un valor específico y que no se pueden comparar rangos.\n\n**26. Diapositiva: Sentencia switch (Características - default) (Página 26)**\n\n*   **Información:**\n    *   Definición: Los valores no comprendidos en ninguna sentencia case se pueden gestionar en default, que es opcional.\n*   **Descripción:**  Explica la funcionalidad de `default`, que es un `case` opcional que se ejecuta si ningún valor coincide en los `case`.\n\n**27. Diapositiva: Sentencia switch (Características - break) (Página 27)**\n\n*   **Información:**\n    *   Definición: En ausencia de `break`, cuando se ejecuta una sentencia case se ejecutan también todas las case que van a continuación, hasta que se llega a un `break` o hasta que se termina el switch.\n*  **Descripción:**  Indica el comportamiento de `switch` cuando **no se incluye la sentencia `break`**, donde se ejecutan todos los `case` a partir del que coincide.\n\n**28. Diapositiva: Sentencia switch (Ejemplo - Explicación) (Página 28)**\n\n*   **Información:**\n    * Ejemplo con explicación:\n    ```java\n    char c = (char)(Math.random()%26+'a'); /* Generar\n       una letra minusculas*/\n    System.out.println(\"La letra \" + c);\n    switch (c) {\n       case 'a': // Se compara con la letra a\n       case 'e': // Se compara con la letra e\n       case 'i': // Se compara con la letra i\n       case 'o': // Se compara con la letra o\n       case 'u': // Se compara con la letra u\n          System.out.println(\" Es una vocal \"); break;\n       default:\n           System.out.println(\" Es una consonante \");\n      }\n    ```\n*  **Descripción:** Muestra un **ejemplo** donde se utiliza la sentencia switch para determinar si una letra generada aleatoriamente es una vocal o no, mostrando las consecuencias de la falta de `break`.\n\n**29. Diapositiva: Sentencia switch (Ejemplo - Calificaciones) (Página 29)**\n\n*   **Información:**\n   * Ejemplo:\n    ```java\n        switch ( calificacion ){\n           case 5 : System.out.println(\"Excelente\");break;\n           case 4 : System.out.println(\"Bien\");break;\n           case 3 : System.out.println(\"Regular\");break;\n           case 2 : System.out.println(\"Mal\");break ;\n           default : System.out.println(\"Nota no valida \");\n          }\n    ```\n*   **Descripción:**  Presenta un **ejemplo de código** de cómo utilizar la sentencia `switch` para clasificar una calificación.\n\n**30. Diapositiva: Buen",
                "metadata": {
                    "file_name": "Conferencia VI-BIFURACIONES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "case 'u': // Se compara con la letra u\n          System.out.println(\" Es una vocal \"); break;\n       default:\n           System.out.println(\" Es una consonante \");\n      }\n    ```\n*  **Descripción:** Muestra un **ejemplo** donde se utiliza la sentencia switch para determinar si una letra generada aleatoriamente es una vocal o no, mostrando las consecuencias de la falta de `break`.\n\n**29. Diapositiva: Sentencia switch (Ejemplo - Calificaciones) (Página 29)**\n\n*   **Información:**\n   * Ejemplo:\n    ```java\n        switch ( calificacion ){\n           case 5 : System.out.println(\"Excelente\");break;\n           case 4 : System.out.println(\"Bien\");break;\n           case 3 : System.out.println(\"Regular\");break;\n           case 2 : System.out.println(\"Mal\");break ;\n           default : System.out.println(\"Nota no valida \");\n          }\n    ```\n*   **Descripción:**  Presenta un **ejemplo de código** de cómo utilizar la sentencia `switch` para clasificar una calificación.\n\n**30. Diapositiva: Buenas Prácticas (Sangría) (Página 30)**\n\n*  **Información:**\n    * Recomandación: Utilice sangría en ambos cuerpos de instrucciones de una estructura `if...else`. Si hay varios niveles de sangría, en cada nivel debe aplicarse la misma cantidad de espacio adicional.\n*   **Descripción:**  Recomienda utilizar **sangría** para mejorar la legibilidad del código en las estructuras `if...else`.\n\n**31. Diapositiva: Buenas Prácticas (Llaves) (Página 31)**\n\n*  **Información:**\n    *   Recomendación: Colocar siempre las llaves en una instrucción `if...else` ayuda a evitar que se omitan de manera accidental, en especial, cuando posteriormente se agregan instrucciones a una cláusula `if` o `else`.\n*   **Descripción:**  Recomienda el uso de **llaves** en las estructuras `if...else` para evitar errores cuando se agreguen sentencias posteriormente.\n\n**32. Diapositiva: Buenas Prácticas (Bloques) (Página 32)**\n\n*  **Información:**\n   * Recomendación: Para evitar que esto suceda, algunos programadores prefieren escribir la llave inicial y la final de los bloques antes de escribir las instrucciones individuales dentro de ellas.\n*  **Descripción:**  Recomienda **escribir primero las llaves** de apertura y cierre de un bloque antes de escribir las sentencias del mismo.\n\n**33. Diapositiva: Operador condicional(?:) (Introducción) (Página 33)**\n\n*   **Información:**\n    *   Definición: Java cuenta con el operador condicional `(?:)`, que en ocasiones puede utilizarse en lugar de una instrucción `if...else`. Éste es el único operador ternario en Java.\n*   **Descripción:**  Introduce el **operador condicional `(?:)`**, que es un operador ternario, o sea, que opera con tres operandos.\n\n**34. Diapositiva: Operador condicional(?:) (Estructura 1) (Página 34)**\n\n*  **Información:**\n    *   Definición: En conjunto, los operandos y el símbolo ?: forman una expresión condicional. El primer operando (a la izquierda del ? ) es una expresión booleana.\n*  **Descripción:** Explica que el operador condicional `(?:)` requiere **tres operandos** y que el primero de ellos debe ser una expresión booleana.\n\n**35. Diapositiva: Operador condicional(?:) (Estructura 2) (Página 35)**\n\n*   **Información:**\n   *   Definición: El segundo operando (entre el ? y :) es el valor de la expresión condicional si la expresión booleana es verdadera.\n*   **Descripción:** Explica que el **segundo operando** del operador condicional `(?:)` es el valor que retornará si la condición es `true`.\n\n**36. Diapositiva: Operador condicional(?:) (Estructura 3 y Ejemplo) (Página 36)**\n\n*   **Información:**\n    *  Definición: El tercer operando (a la derecha de :) es el valor de la expresión condicional si la expresión booleana se evalúa como `false`.\n    *  Ejemplo:\n         ```java\n             System.out.println(calificacion >=3 ? \"Aprobado\":\"Reprobado\");\n        ```\n*   **Descripción:**  Explica que el **tercer operando** del operador condicional `(?:)` es el valor que retornará si la condición es `false` y presenta un ejemplo.\n\n**37. Diapositiva: Estudio Independiente (Página 37)**\n\n*  **Información:**\n    * Ejercicios:\n        *   Leer tres números enteros y determinar cuál es el mayor. Usar solamente dos variables.\n        *   Leer un número entero y determinar si tiene 3 dígitos.\n        *   Leer un número entero y determinar si es múltiplo de 7.\n*  **Descripción:** Propone una serie de **ejercicios** que los estudiantes pueden utilizar para aplicar los conceptos aprendidos.\n\n**38. Diapositiva: Fin (Página 38)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva final, indicando el **cierre** de la presentación.\n",
                "metadata": {
                    "file_name": "Conferencia VI-BIFURACIONES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "mplo.\n\n**37. Diapositiva: Estudio Independiente (Página 37)**\n\n*  **Información:**\n    * Ejercicios:\n        *   Leer tres números enteros y determinar cuál es el mayor. Usar solamente dos variables.\n        *   Leer un número entero y determinar si tiene 3 dígitos.\n        *   Leer un número entero y determinar si es múltiplo de 7.\n*  **Descripción:** Propone una serie de **ejercicios** que los estudiantes pueden utilizar para aplicar los conceptos aprendidos.\n\n**38. Diapositiva: Fin (Página 38)**\n\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva final, indicando el **cierre** de la presentación.\n",
                "metadata": {
                    "file_name": "Conferencia VI-BIFURACIONES O SENTENCIAS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema III Programación funcional\n**Presentación: Métodos y Funciones**\n\n**1. Diapositiva: Título (Página 1)**\n*   **Información:**\n    * Logo de la Universidad de Matanzas.\n    *   Título: MÉTODOS Y FUNCIONES.\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Octubre / 2019.\n*   **Descripción:** Esta es la **portada** de la presentación, presentando el tema \"Métodos y Funciones\" y su contexto dentro del curso.\n\n**2. Diapositiva: Objetivos (Parte 1) (Página 2)**\n*   **Información:**\n    *   Objetivo: Caracterizar los métodos y funciones como parte de la construcción de un programa computacional.\n*   **Descripción:**  Presenta el primer **objetivo** de la presentación: comprender la importancia y rol de los métodos y funciones en la construcción de programas.\n\n**3. Diapositiva: Objetivos (Parte 2) (Página 3)**\n*   **Información:**\n     * Objetivo: Utilizar los métodos comunes de `Math` disponibles en la API de Java.\n*  **Descripción:** Define el segundo **objetivo**: aprender a utilizar los métodos de la clase `Math` de Java.\n\n**4. Diapositiva: Objetivos (Parte 3) (Página 4)**\n*  **Información:**\n    *   Objetivo: Comprender los mecanismos para pasar información entre métodos.\n*  **Descripción:**  Presenta el tercer **objetivo** de la presentación, que es entender los mecanismos para el intercambio de información entre métodos.\n\n**5. Diapositiva: Objetivos (Parte 4) (Página 5)**\n*   **Información:**\n    *   Objetivo: Comprender cómo se soporta el mecanismo de llamada/retorno de los métodos mediante la pila de llamadas a métodos y los registros de activación.\n*   **Descripción:**  Presenta el cuarto **objetivo** de la presentación: entender el funcionamiento interno de la llamada a métodos.\n\n**6. Diapositiva: Sumario (Página 6)**\n*  **Información:**\n    * Temas: Módulos de programas en Java, Métodos (Declaración, Invocación), Métodos de la clase `Math`.\n*  **Descripción:**  Resume los temas principales de la presentación: módulos, métodos, su declaración e invocación, y la clase `Math`.\n\n**7. Diapositiva: Bibliografía (Página 7)**\n*   **Información:**\n    *   Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*   **Descripción:**  Lista las **referencias bibliográficas** utilizadas para la creación de la presentación.\n\n**8. Diapositiva: Introducción (Programas Extensos) (Página 8)**\n*   **Información:**\n    *  Definición: La mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta el momento.\n*   **Descripción:**  Comienza la **introducción** indicando que los programas reales son más extensos que los creados hasta el momento.\n\n**9. Diapositiva: Introducción (Divide y Vencerás) (Página 9)**\n\n*   **Información:**\n    *  Definición: La mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos. A esta técnica se le llama divide y vencerás.\n*   **Descripción:** Explica la importancia de usar la técnica **\"divide y vencerás\"**, que consiste en construir programas a partir de módulos más pequeños.\n\n**10. Diapositiva: Módulos (Tipos) (Página 10)**\n*   **Información:**\n    *  Tipos de módulos: Métodos, Clases, Paquetes.\n*   **Descripción:** Enumera los **tres tipos de módulos** utilizados en Java: métodos, clases y paquetes.\n\n**11. Diapositiva: Métodos (Definición) (Página 11)**\n*  **Información:**\n   * Definición: Los métodos (también conocidos como funciones o procedimientos en otros lenguajes) permiten al programador dividir un programa en módulos.\n*  **Descripción:** Define qué son los **métodos**, como una forma de dividir los programas en tareas autónomas.\n\n**12. Diapositiva: Métodos (Divide y Vencerás) (Página 12)**\n*  **Información:**\n    * Explicación: Una razón para dividir un programa en módulos mediante los métodos es la metodología divide y vencerás, que hace que el desarrollo de programas sea más fácil de administrar.\n*  **Descripción:** Explica que una razón para dividir programas en módulos es la metodología **divide y vencerás**.\n\n**13. Diapositiva: Métodos (Reutilización) (Página 13)**\n*   **Información:**\n    *   Definición: Otra razón es la reutilización de software (usar los métodos existentes como bloques de construcción para crear nuevos programas).\n*   **Descripción:**  Menciona la **reutilización de código** como otra ventaja de utilizar métodos, ya que estos pueden usarse como componentes en nuevos programas.\n\n**14. Diapositiva: Métodos (Invocación y Retorno) (Página 14)**\n*  **Información:**\n    *  Definición: Un método se invoca mediante una llamada, y cuando el método que se llamó completa su tarea, devuelve un resultado, o simplemente el control al método que lo llamó.\n*  **Descripción:**  Explica que los métodos se activan mediante una llamada y al finalizar pueden retornar un resultado o devolver el control.\n\n**15. Diapositiva: Métodos (Objetos Específicos) (Página 15)*",
                "metadata": {
                    "file_name": "Conferencia VII-Métodos y funciones.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "dministrar.\n*  **Descripción:** Explica que una razón para dividir programas en módulos es la metodología **divide y vencerás**.\n\n**13. Diapositiva: Métodos (Reutilización) (Página 13)**\n*   **Información:**\n    *   Definición: Otra razón es la reutilización de software (usar los métodos existentes como bloques de construcción para crear nuevos programas).\n*   **Descripción:**  Menciona la **reutilización de código** como otra ventaja de utilizar métodos, ya que estos pueden usarse como componentes en nuevos programas.\n\n**14. Diapositiva: Métodos (Invocación y Retorno) (Página 14)**\n*  **Información:**\n    *  Definición: Un método se invoca mediante una llamada, y cuando el método que se llamó completa su tarea, devuelve un resultado, o simplemente el control al método que lo llamó.\n*  **Descripción:**  Explica que los métodos se activan mediante una llamada y al finalizar pueden retornar un resultado o devolver el control.\n\n**15. Diapositiva: Métodos (Objetos Específicos) (Página 15)**\n\n*  **Información:**\n    * Definición: Aunque la mayoría de los métodos se ejecutan en respuesta a las llamadas a métodos en objetos específicos, éste no es siempre el caso. Algunas veces un método realiza una tarea que no depende del contenido de ningún objeto.\n*   **Descripción:** Explica que algunos métodos, conocidos como **métodos de clase o métodos estáticos**, se aplican a toda la clase y no a objetos específicos de ella.\n\n**16. Diapositiva: Métodos (Static) (Página 16)**\n\n*   **Información:**\n    *   Definición: Dicho método se aplica a la clase en la que está declarado como un todo, y se conoce como método static o método de clase.\n*   **Descripción:** Describe en más detalle los **métodos `static`**, explicando que no requieren una instancia de la clase para ser llamados.\n\n**17. Diapositiva: Métodos (Sintaxis de Declaración - Introducción) (Página 17)**\n*   **Información:**\n     *  Sintaxis: `<visibilidad> static <TDR> <nombre> (<argumentos >) { <Conjuntos de Instrucciones> }`\n    *   Texto:  Analicemos cada una de las partes de forma detallada.\n*   **Descripción:**  Introduce la **sintaxis general de la declaración de métodos** en Java, indicando sus partes principales y que se van a analizar en detalle.\n\n**18. Diapositiva: Métodos (Sintaxis - Visibilidad) (Página 18)**\n*   **Información:**\n    *  Definición: `<visibilidad>`: Hace referencia a la visibilidad que tenga el método con respecto al resto de los módulos que participan en el programa.\n*  **Descripción:** Explica qué representa la parte `<visibilidad>` de la declaración de un método y su significado.\n\n**19. Diapositiva: Métodos (Sintaxis - Visibilidad - Valores) (Página 19)**\n\n*   **Información:**\n    *   Definición: `<visibilidad>`: Los posibles valores son las palabras reservadas del lenguaje `private`, `protected` o `public`.\n*   **Descripción:** Enumera los **valores posibles** que puede tomar la parte `<visibilidad>` en la declaración de un método.\n\n**20. Diapositiva: Métodos (Sintaxis - static) (Página 20)**\n*   **Información:**\n    * Definición: `static`: Da la posibilidad que el método sea invoca o llamado sin tener que crear un objeto o instancia de la clase donde fue declarado previamente.\n*  **Descripción:** Explica el significado de la palabra reservada `static` en la declaración de un método y cómo afecta la forma en la que se puede invocar al método.\n\n**21. Diapositiva: Métodos (Sintaxis - static - Opcional) (Página 21)**\n*  **Información:**\n     * Definición: `static`: Puede ser omitido de la declaración pero entonces para usar o llamar el método sería a través de una instancia u objeto de la clase.\n*  **Descripción:** Aclara que la palabra reservada `static` es **opcional** y que, si se omite, la invocación del método requiere una instancia u objeto de la clase.\n\n**22. Diapositiva: Métodos (Sintaxis - Tipo de Dato de Retorno) (Página 22)**\n*  **Información:**\n    *   Definición: `<TDR>`: Tipo de dato de retorno hace referencia al tipo de dato que va devolver el método una vez terminadas sus operaciones u instrucciones.\n*  **Descripción:**  Explica la parte `<TDR>` de la declaración, que indica el **tipo de dato del valor** que devuelve el método tras su ejecución.\n\n**23. Diapositiva: Métodos (Sintaxis - return) (Página 23)**\n\n*   **Información:**\n    *   Definición: `<TDR>`: Los métodos para retornar o devolver algún valor, dato o variable hace uso de la instrucción `return`.\n*  **Descripción:**  Indica que la sentencia `return` es la que utiliza un método para **retornar o devolver un valor**.\n\n**24. Diapositiva: Métodos (Sintaxis - Tipo de Dato y void) (Página 24)**\n*   **Información:**\n    *  Definición: `<TDR>`: El tipo de dato debe coincidir con el tipo de dato del valor, dato o variable que se va retornar. En caso de que no se retorne nada el valor debe ser `void`.\n*  **Descripción:**  Aclara que el **tipo de dato de retorno** debe coincidir con el valor devuelto y que `void` se utiliza si el método no devuelve valor.\n\n**25. Diaposit",
                "metadata": {
                    "file_name": "Conferencia VII-Métodos y funciones.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "el método una vez terminadas sus operaciones u instrucciones.\n*  **Descripción:**  Explica la parte `<TDR>` de la declaración, que indica el **tipo de dato del valor** que devuelve el método tras su ejecución.\n\n**23. Diapositiva: Métodos (Sintaxis - return) (Página 23)**\n\n*   **Información:**\n    *   Definición: `<TDR>`: Los métodos para retornar o devolver algún valor, dato o variable hace uso de la instrucción `return`.\n*  **Descripción:**  Indica que la sentencia `return` es la que utiliza un método para **retornar o devolver un valor**.\n\n**24. Diapositiva: Métodos (Sintaxis - Tipo de Dato y void) (Página 24)**\n*   **Información:**\n    *  Definición: `<TDR>`: El tipo de dato debe coincidir con el tipo de dato del valor, dato o variable que se va retornar. En caso de que no se retorne nada el valor debe ser `void`.\n*  **Descripción:**  Aclara que el **tipo de dato de retorno** debe coincidir con el valor devuelto y que `void` se utiliza si el método no devuelve valor.\n\n**25. Diapositiva: Métodos (Sintaxis - Nombre) (Página 25)**\n*   **Información:**\n    *   Definición: `<nombre>`: Va a ser el identificador del método y para su elaboración se cumple con las mismas reglas que para la conformación de los identificadores de las variables.\n*  **Descripción:** Describe la parte `<nombre>`, que es el **identificador del método** y debe seguir las mismas reglas que las variables.\n\n**26. Diapositiva: Métodos (Sintaxis - Argumentos - Opcionales) (Página 26)**\n\n*   **Información:**\n    *  Definición: `<argumentos>`: Este término puede ser nulo en caso que para realizar sus instrucciones el método no necesite información extra.\n*  **Descripción:** Explica que la parte `<argumentos>` es **opcional**, si un método no requiere datos adicionales para su ejecución.\n\n**27. Diapositiva: Métodos (Sintaxis - Argumentos - Requisitos) (Página 27)**\n*   **Información:**\n    *  Definición: `<argumentos>`: Pero a menudo los métodos requieren más de un dato de información para realizar sus instrucciones.\n*   **Descripción:**  Aclara que **a menudo los métodos requieren datos adicionales** para su ejecución.\n\n**28. Diapositiva: Métodos (Sintaxis - Argumentos - Múltiples) (Página 28)**\n*  **Información:**\n    *  Definición: `<argumentos>`: Por cada dato que se necesite pasar al método se debe especificar el tipo de dato y el identificador. Si hay mas de un dato separarlos por coma.\n*  **Descripción:**  Explica que para cada argumento se debe indicar su tipo e identificador, y que se separan con una coma cuando hay varios.\n\n**29. Diapositiva: Métodos (Ejemplo - Argumentos y Retorno) (Página 29)**\n*  **Información:**\n     * Ejemplo de código:\n    ```java\n     // devuelve el maximo de sus tres parametros int\n     public static int maximo ( int x, int y, int z){\n       int valorMaximo = x;\n       if(y>valorMaximo){\n         valorMaximo=y;\n       }\n       if(z>valorMaximo) {\n        valorMaximo=z;\n       }\n       return valorMaximo;\n     }\n    ```\n*  **Descripción:** Muestra un **ejemplo de método** que recibe tres argumentos y devuelve un valor (el máximo).\n\n**30. Diapositiva: Métodos (Ejemplo - Sin Argumentos y Sin Retorno) (Página 30)**\n*   **Información:**\n     * Ejemplo de código:\n    ```java\n     public static void determinarMaximo(){\n       Scanner entrada = new Scanner(System.in );\n       System.out.print(\"Escriba tres valores enteros, separados\n       por espacios: \");\n       int nu1 = entrada.nextInt();\n       int nu2 = entrada.nextInt();\n       int nu3 = entrada.nextInt();\n        /*determina el valor maximo llamando al metodo\n         anterior asumiendo que ambos metodos estan\n           declarado en la misma clase*/\n        int resultado=maximo(nul, nu2,nu3);\n        System.out.println( \"El maximo es: \"+resultado);\n    }\n    ```\n*   **Descripción:** Muestra un **ejemplo de método** que no recibe argumentos ni retorna un valor (void) y hace una llamada al método `maximo` del ejemplo anterior.\n\n**31. Diapositiva: Métodos (Sintaxis de Declaración - Flexibilidad) (Página 31)**\n*  **Información:**\n    *  Texto: Lo anterior no es una camisa de fuerza porque pueden existir: Métodos con retorno y con argumentos. Métodos sin retorno y con argumentos. Métodos con retorno y sin argumentos. Métodos sin retorno y sin argumentos.\n*  **Descripción:**  Indica que la declaración de métodos es flexible y **puede combinarse** con o sin argumentos y con o sin tipo de retorno.\n\n**32. Diapositiva: Métodos (Sintaxis de Invocación - Introducción) (Página 32)**\n\n*  **Información:**\n    * Definición: Puede llamar a cualquier método static especificando el nombre de la clase, seguido de un punto y el nombre del método.\n    * Sintaxis: `<NombreClase>.<nombreMetodo>(<argumentos>)`\n     * Texto: Analicemos cada una de las partes de forma detallada.\n*   **Descripción:**  Introduce la **sintaxis de invocación** de un método `static`, explicando la estructura básica y el uso del punto (`.`).\n\n**33. Diapositiva: Métodos (Sintaxis de Invocación - Nombre de Cla",
                "metadata": {
                    "file_name": "Conferencia VII-Métodos y funciones.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " Flexibilidad) (Página 31)**\n*  **Información:**\n    *  Texto: Lo anterior no es una camisa de fuerza porque pueden existir: Métodos con retorno y con argumentos. Métodos sin retorno y con argumentos. Métodos con retorno y sin argumentos. Métodos sin retorno y sin argumentos.\n*  **Descripción:**  Indica que la declaración de métodos es flexible y **puede combinarse** con o sin argumentos y con o sin tipo de retorno.\n\n**32. Diapositiva: Métodos (Sintaxis de Invocación - Introducción) (Página 32)**\n\n*  **Información:**\n    * Definición: Puede llamar a cualquier método static especificando el nombre de la clase, seguido de un punto y el nombre del método.\n    * Sintaxis: `<NombreClase>.<nombreMetodo>(<argumentos>)`\n     * Texto: Analicemos cada una de las partes de forma detallada.\n*   **Descripción:**  Introduce la **sintaxis de invocación** de un método `static`, explicando la estructura básica y el uso del punto (`.`).\n\n**33. Diapositiva: Métodos (Sintaxis de Invocación - Nombre de Clase) (Página 33)**\n*  **Información:**\n    *   Definición: `<NombreClase>`: Se va nombrar el nombre de la clase donde está el método que queremos invocar.\n*  **Descripción:**  Explica que en la invocación se especifica el **nombre de la clase** donde está declarado el método.\n\n**34. Diapositiva: Métodos (Sintaxis de Invocación - Nombre de Clase - Opcional) (Página 34)**\n*  **Información:**\n   *   Definición: `<NombreClase>`: En caso de que queramos invocar un método que esta en la misma clase (class) no es necesario ponerla ni el punto (.) pero no esta mal hacerlo de hecho el lenguaje lo reconoce.\n*   **Descripción:** Indica que el nombre de la clase es **opcional** en la invocación de métodos de la misma clase.\n\n**35. Diapositiva: Métodos (Sintaxis de Invocación - Argumentos - Opcional) (Página 35)**\n*  **Información:**\n    *   Definición: `<argumentos>`: De igual que sucede en la declaración esto puede ser nulo en caso que el método no necesite datos adicionales.\n*   **Descripción:**  Explica que la parte de los **argumentos en la invocación también es opcional** si el método no los necesita.\n\n**36. Diapositiva: Métodos (Sintaxis de Invocación - Argumentos - Uso) (Página 36)**\n*  **Información:**\n     * Definición: `<argumentos>`: En caso que necesite datos adicionales los mismo se ponen separados por comas pero sin especificar el tipo de dato como si se hace en la declaración.\n*  **Descripción:** Explica que en la invocación, si se necesitan argumentos, se escriben separados por comas pero sin especificar el tipo de dato.\n\n**37. Diapositiva: Métodos (Sintaxis de Invocación - Argumentos - Orden) (Página 37)**\n*   **Información:**\n    * Definición: `<argumentos>`: Si es importante que los datos que se les pase en la invocación coincidan en ese mismo orden con los tipos de datos de los argumentos de la declaración.\n*  **Descripción:** Explica que en la invocación, el **orden de los argumentos** debe coincidir con el orden de sus tipos en la declaración del método.\n\n**38. Diapositiva: Métodos (Ejemplo - Invocación con Math.sqrt - 1) (Página 38)**\n*   **Información:**\n   * Ejemplo de código:\n    ```java\n       Math.sqrt( 900.0 );\n       /*Pero tambien pudo ser*/\n       double a=25;\n       Math.sqrt(a);\n    ```\n*   **Descripción:** Muestra **ejemplos de cómo invocar el método `sqrt`** de la clase `Math` directamente con una constante o con el valor de una variable.\n\n**39. Diapositiva: Métodos (Ejemplo - Invocación con Math.sqrt - 2) (Página 39)**\n\n*   **Información:**\n      * Ejemplo: La expresiónes anteriores se evalúan como 30.0 para 900 y 5.0 para a.\n     *Definición: El método `sqrt` (halla la raíz cuadrada) recibe un argumento de tipo double y devuelve un resultado del mismo tipo.\n*  **Descripción:** Explica los **resultados de la evaluación del ejemplo de la diapositiva anterior** e indica el tipo de argumento y retorno del método `sqrt`.\n\n**40. Diapositiva: Métodos (Ejemplo - Invocación en println) (Página 40)**\n*   **Información:**\n    * Ejemplo: `System.out.println(Math.sqrt(900.0));`\n    *Texto: En esta instrucción, el valor que devuelve sqrt se convierte en el argumento para el método println.\n*  **Descripción:** Muestra cómo **invocar el método `sqrt` e imprimir su resultado** utilizando `System.out.println`.\n\n**41. Diapositiva: Clase Math (Introducción) (Página 41)**\n*   **Información:**\n     *   Definición: La clase `Math` cuenta con una colección de métodos y constantes que nos permiten realizar cálculos matemáticos comunes.\n*   **Descripción:**  Introduce la **clase `Math`**, que cuenta con una colección de métodos y constantes para realizar cálculos matemáticos.\n\n**42. Diapositiva: Clase Math (Métodos - Parte 1) (Página 42)**\n*   **Información:**\n    *   Tabla con los métodos: `abs(x)`, `ceil(x)`, `cos(x)`, `exp(x)`, y sus descripciones.\n*  **Descripción:** Presenta una tabla con algunos **métodos de la clase `Math` y su descripción**.\n\n**43. Diapositiva: Clase Math (Métodos - Parte 2) (Página 43)**\n*   **Informac",
                "metadata": {
                    "file_name": "Conferencia VII-Métodos y funciones.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "plo: `System.out.println(Math.sqrt(900.0));`\n    *Texto: En esta instrucción, el valor que devuelve sqrt se convierte en el argumento para el método println.\n*  **Descripción:** Muestra cómo **invocar el método `sqrt` e imprimir su resultado** utilizando `System.out.println`.\n\n**41. Diapositiva: Clase Math (Introducción) (Página 41)**\n*   **Información:**\n     *   Definición: La clase `Math` cuenta con una colección de métodos y constantes que nos permiten realizar cálculos matemáticos comunes.\n*   **Descripción:**  Introduce la **clase `Math`**, que cuenta con una colección de métodos y constantes para realizar cálculos matemáticos.\n\n**42. Diapositiva: Clase Math (Métodos - Parte 1) (Página 42)**\n*   **Información:**\n    *   Tabla con los métodos: `abs(x)`, `ceil(x)`, `cos(x)`, `exp(x)`, y sus descripciones.\n*  **Descripción:** Presenta una tabla con algunos **métodos de la clase `Math` y su descripción**.\n\n**43. Diapositiva: Clase Math (Métodos - Parte 2) (Página 43)**\n*   **Información:**\n    *   Tabla con los métodos: `floor(x)`, `log(x)`, `max(x,y)`, `min(x,y)`, y sus descripciones.\n*   **Descripción:** Continúa la tabla con más **métodos de la clase `Math` y su descripción**.\n\n**44. Diapositiva: Clase Math (Métodos - Parte 3) (Página 44)**\n*   **Información:**\n    *  Tabla con los métodos: `pow(x,y)`, `sin(x)`, `sqrt(x)`, `tan(x)`, y sus descripciones.\n*   **Descripción:** Finaliza la tabla mostrando **más métodos de la clase `Math` y su descripción**.\n\n**45. Diapositiva: Conclusiones (Tarea Única) (Página 45)**\n*   **Información:**\n     * Conclusión: Cada método debe limitarse de manera que realice una sola tarea bien definida, y su nombre debe expresar esa tarea con efectividad.\n*   **Descripción:**  Presenta una **conclusión sobre el propósito de un método**, indicando que cada uno debería realizar una sola tarea bien definida.\n\n**46. Diapositiva: Conclusiones (Nombre del Método) (Página 46)**\n*   **Información:**\n     * Conclusión: Si no puede elegir un nombre conciso que exprese la tarea de un método, tal vez esté tratando de realizar diversas tareas en un mismo método. Por lo general, es mejor dividirlo en varias declaraciones de métodos más pequeños.\n*   **Descripción:** Recomienda que si el nombre del método no describe bien su propósito,  **lo mejor sería dividir el método en varios más pequeños**.\n\n**47. Diapositiva: Conclusiones (Mal Uso de void) (Página 47)**\n\n*   **Información:**\n    *   Conclusión: Una mala práctica o una evidencia de que no existe una correcta implementación del método es que el mismo tenga como TDR void y haga uso del sentencia `return` en su implementación.\n*  **Descripción:**  Aclara que cuando un método se declara como `void`, este no debería hacer uso de la instrucción `return`.\n\n**48. Diapositiva: Conclusiones (Métodos Iguales) (Página 48)**\n*  **Información:**\n    *  Conclusión: No pueden existir dos métodos iguales y para que esto no ocurra tienen que diferir en al menos uno de los siguientes aspectos: paquete o clase, nombre, tipo de dato de retorno, cantidad de argumentos, orden de los tipos de datos de los argumentos.\n*   **Descripción:** Indica las **condiciones** que deben ser diferentes entre dos métodos declarados dentro del mismo contexto, con el fin de que sean diferentes.\n\n**49. Diapositiva: Fin (Página 49)**\n*   **Información:**\n    *  Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva final, indicando el **cierre de la presentación**.\n",
                "metadata": {
                    "file_name": "Conferencia VII-Métodos y funciones.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Programación funcional.\nUnidad didáctica: Funciones y métodos de clase recursivos\n1. Objetivos de la unidad didáctica:\nCaracterizar funciones y métodos de clase recursivos.\nIdentificar los principales elementos que componen un método o función recursivo.\nDiseñar e implementar funciones y métodos recursivos.\n2. Introducción a la unidad didáctica:\nEn guías de aprendizajes anteriores se había abordado que la mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta ahora. La experiencia ha demostrado que la mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos. [1]\n\nSe había definido que existen tres tipos de módulos en Java: métodos, clases y paquetes. Y que el módulo más pequeño de los tres anteriores era: los métodos. [2]\n\nUn método era un grupo de instrucciones para realizar un objetivo procedimiento bien definido encapsuladas bajo un identificador que podían o no recibir uno o varios parámetros para su realización e incluso devolver o retornar algún valor. [2]\n\nEl grupo de instrucciones que componen un método no se van a ejecutar mientras no se invoque o llame al método desde el método principal del programa main o desde otro método. Pero un método podrá auto-invocarse o auto-llamarse el mismo. Los métodos que dentro de sus instrucciones tienen un llamada a así mismo son los llamados métodos o funciones recursiva. En esta guía de aprendizajes estaremos abordando sobre los mismos. [2]\n\nVeamos el siguiente ejemplo:\nHagamos un método que sea capaz de calcular el factorial de un numero entero N el cual es pasado por parámetro. Como sabemos el factorial de N se representar !N que por definición es la multiplicación de todos los números enteros entre 1 y N incluyendo los extremos y que para N =0 el factorial es 1. Los primeros seis factoriales son: [3]\n\n!0 = 0\n\n!1 =  1\n\n!2 = 2 = 2 * !1\n\n!3 = 6 = 3 * !2\n\n!4 = 24 = 4 * !3\n\n!5 = 120 = 5 * !4\n\nYa nos podemos percatar que el factorial de N se puede definir como la multiplicación de N por el factorial de N-1 excepto en los casos de N igual a 1 o 0 donde el valor es 1. Mas formalmente podemos plantear matemáticamente como [3]\n\nfactorial(N) = 1 si N es 0 o 1\n\n                            N * factorial(N-1) para cualquier N>1\n\nLlevando lo anterior a lenguaje de programación de Java nos quedaría de la siguiente manera: [4]\n\npublic static int factorial( int  n){\n\nif ( n==0 || n==1 ){\n\nreturn 1;\n\n} else {\n\nreturn n * factorial(n-1);\n\n}\n\n}\n\nBueno si vemos la linea número 4 de método (return n * factorial (n-1)) se invoca o se llama al mismo método pero con la diferencia que el valor de N será pasado como parametro pero decrementado en uno. Si el método fue llamado con n = 4 en esa linea sería return 4 * factorial(3). Si traceamos el método recursivo y pintamos su árbol de traceo quedaría como se muestra en la siguiente imagen: [4]\n\n[Imagen del árbol de traceo] [4]\n\nComo vemos en la imagen cuando factorial(4) invoca a factorial(3) este invoca a factorial(2) y este a factorial(1) quien sencillamente retorna 1 que después es multiplicado por 2 ( respuesta de la llamada a factorial (2)) que a su vez es multiplicado por 3 siendo 6 como resultado (resultado de factorial(3)) que es multiplicado por 4 que arroja 24 que es el resultado final de factorial(4) . Es evidente que los métodos recursivo desencadena una serie de llamadas en cadena hasta llegar a un punto que se retorna un valor y no a una invocación nuevamente a la función o método en si. [5]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [6]\nCree hábitos de estudio sistemático; para esto: [6]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [6]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [7]\nUtilice técnicas de estudio: [7]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [7]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [7]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [7]\nInteractúe con los materiales de estudio en tres fases: [8]\nFase de aproximación: Revise el objetivo de la unidad y después la ac",
                "metadata": {
                    "file_name": "guia_aprendizaje_10.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ue su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [6]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [7]\nUtilice técnicas de estudio: [7]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [7]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [7]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [7]\nInteractúe con los materiales de estudio en tres fases: [8]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [8]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [8]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [9]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [9]\n\n5. Actividades de auto-aprendizajes:\nEn los métodos recursivos se es necesario definir dos elementos, partes, casos. Mencione cuales son dichos elementos, partes, casos . En el código presentado en la Introducción a la unidad didáctica identifique dichos elementos o partes. [9]\nEntre los elementos que define los métodos o funciones recursivas son los casos bases. Que características tienen dentro de un método o función recursiva. Cuantos casos bases puede tener una función o método recursivo?. [10]\nQue pasaría si se llama o invoca a una función o método recursivo que no presenta ningún caso base en su implementación ?. [10]\nEntre los elementos que define los métodos o funciones recursivas son los casos recurrentes. Que características tienen dentro de un método o función recursiva. Cuantos casos recurrentes puede tener una función o método recursivo?. [10]\nQue pasaría si se llama o invoca a una función o método recursivo que no presenta ningún caso recurrente en su implementación ?. Se podría considerar como un método recurrente. [11]\nRealice una tabla comparativa entre las ventajas y desventajas del métodos recursivos frente a métodos no recursivo. [11]\n6. Actividades de evaluación:\n1.Declare e implemente una función o método recursivo que permita calcular el termino N de la sucesión de los números Fibonacci. Realice el árbol de traceo para N= 5 [11] 2.Declare e implemente una función o método recursivo que permita calcular el máximo común divisor entre dos números enteros A y B que son pasados por parámetros. Realice el árbol de traceo para A= 24 y B= 102 [11] 3.Declare e implemente una función o método recursivo que calcule la función de Ackermann para dos valores enteros positivos N y M que son pasados por parámetros. Realice el árbol de traceo para N=10 y M=15. [12] 4. Declare e implemente una función o método recursivo que permita calcular el termino N de la secuencia de los números Catalan. Realice el árbol de traceo para N= 10. [12]\n\n7. Resumen:\nRecursión es, en ciencias de computación, una forma de atajar y solventar problemas. De hecho, recursión es una de las ideas centrales de ciencia de computación. Resolver un problema mediante recursión significa que la solución depende de las soluciones de pequeñas instancias del mismo problema. [12]\n\nEn el ejemplo \"factorial\" la implementación iterativa es probablemente más rápida en la práctica que la recursiva. Este resultado es lógico, pues las funciones iterativas no tienen que pagar el exceso de llamadas de funciones como en el caso de las funciones recursivas, y ese exceso es relativamente alto en muchos lenguajes de programación. [13]\n\nHay otros tipos de problemas cuyas soluciones son inherentemente recursivas, porque estar al tanto del estado anterior. Un ejemplo es el DFS ; otros incluyen la función de Ackermann y el algoritmo divide y vencerás tales como Quicksort. Todos estos algoritmos pueden implementarse iterativamente con la ayuda de una pila, pero la necesidad del mismo, puede que anule las ventajas de la solución iterativa. [13]\n\nOtra posible razón para la utilización de un algoritmo iterativo en lugar de uno recursivo es el hecho de que en los lenguajes de programación modernos, el espacio de pila disponible para un hilo es, a m",
                "metadata": {
                    "file_name": "guia_aprendizaje_10.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "nstancias del mismo problema. [12]\n\nEn el ejemplo \"factorial\" la implementación iterativa es probablemente más rápida en la práctica que la recursiva. Este resultado es lógico, pues las funciones iterativas no tienen que pagar el exceso de llamadas de funciones como en el caso de las funciones recursivas, y ese exceso es relativamente alto en muchos lenguajes de programación. [13]\n\nHay otros tipos de problemas cuyas soluciones son inherentemente recursivas, porque estar al tanto del estado anterior. Un ejemplo es el DFS ; otros incluyen la función de Ackermann y el algoritmo divide y vencerás tales como Quicksort. Todos estos algoritmos pueden implementarse iterativamente con la ayuda de una pila, pero la necesidad del mismo, puede que anule las ventajas de la solución iterativa. [13]\n\nOtra posible razón para la utilización de un algoritmo iterativo en lugar de uno recursivo es el hecho de que en los lenguajes de programación modernos, el espacio de pila disponible para un hilo es, a menudo, mucho menos que el espacio disponible en el montículo, y los algoritmos recursivos suelen requerir más espacio de pila que los algoritmos iterativos. [14]\n\n8. Glosario de términos:\nConsulte la bibliografía y defina el concepto del siguiente término: [14]\n\nAlgoritmo recursivo:\nProgramación recursiva:\nRecursión directa e indirecta: [15]\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 3 epígrafes 3.1, 3.2, 3.3, 3.4. [15]\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 6 completo [15]\n10. Recursos educativos digitales RED: [15]\n11. Próxima unidad: Programación funcional. Ejercitación de los contenidos. [15]",
                "metadata": {
                    "file_name": "guia_aprendizaje_10.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Introducción al lenguaje de programación Java\nUnidad didáctica: Programación funcional. Ejercitación de los contenidos.\n1. Objetivos de la unidad didáctica:\nDiseñar e implementar funciones y métodos de clases.\nInvocación y llamadas a métodos y funciones de clases.\nDiseñar e implementar funciones y métodos de clases recursivos.\n2. Introducción a la unidad didáctica:\nLa siguiente guía te propone una serie de ejercicios evaluativos los cuales debe realizar y subir a la plataforma en el espacio del curso en un fichero comprimido o enviar al correo luis.valido@umcc.cu . Dicho archivo debe estar en formato .zip y dentro tendrá una carpeta por cada ejercicio. Dentro de cada carpeta que hace referencia a un ejercicio debe estar el archivo .java donde esta la implementación utilizando el lenguaje de programación Java de la solución. El archivo comprimido su nombre debe tener la siguiente nomenclatura <nombre_estudiante>_info11-2021.zip donde <nombre_estudiante> se debe colocar el nombre y apellidos del estudiante. Por ejemplo para el estudiante Luis Andrés Valido Fajardo el archivo tendría el siguiente formato:\n\nluis_andres_valido_fajardo_info11-2021.zip\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n5. Actividades de auto-aprendizajes:\nNo existen actividades de auto-aprendizaje\n\n6. Actividades de evaluación:\nDiseñe e implemente un método que reciba dos números enteros por parámetros y retorna la suma duplicada de estos . Dicho método no puede ser recursivo. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que reciba dos números enteros por parámetros y retorna la suma duplicada de estos . Dicho método debe ser recursivo. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que reciba un número natural por parámetros y retorna el numero natural invertido. Por ejemplo para 9 el método retorna 9 mientras para 123 el retorno debe ser 321. Dicho método no puede ser recursivo y solo se puede utilizar variables de tipo entero. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que reciba un número natural por parámetros y retorna vel numero natural invertido. Por ejemplo para 9 el método retorna 9 mientras para 123 el retorno debe ser 321. Dicho método debe ser recursivo y solo se puede utilizar variables de tipo entero. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que permita representar gráficamente un trampolín del deporte saltos ornamentales ( popularmente conocido como clavado) para un videojuego de consola MS-DOS. Para representar el trampolín así como la escalera para subir a el se utilizará el símbolo #. Aquí va un ejemplo de que debe imprimir el método para trampolines de alturas 3, 5 y 10 respectivamente.\nLos",
                "metadata": {
                    "file_name": "guia_aprendizaje_11_evaluativa.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "todo retorna 9 mientras para 123 el retorno debe ser 321. Dicho método no puede ser recursivo y solo se puede utilizar variables de tipo entero. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que reciba un número natural por parámetros y retorna vel numero natural invertido. Por ejemplo para 9 el método retorna 9 mientras para 123 el retorno debe ser 321. Dicho método debe ser recursivo y solo se puede utilizar variables de tipo entero. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\nDiseñe e implemente un método que permita representar gráficamente un trampolín del deporte saltos ornamentales ( popularmente conocido como clavado) para un videojuego de consola MS-DOS. Para representar el trampolín así como la escalera para subir a el se utilizará el símbolo #. Aquí va un ejemplo de que debe imprimir el método para trampolines de alturas 3, 5 y 10 respectivamente.\nLos trampolines a utilizar en el videojuego sus alturas van oscilar en entre 3 y 20 por tanto el método a implementar debe recibir la altura e imprimir el trampolín correspondiente a esa altura. El método debe ser recursivo. Elabore un programa donde haga uso de este método. Utilice el lenguaje de programación Java.\n7. Resumen:\nCon la realización de esta guía de estudio evaluativa hemos culminado el tercer tema del curso donde se abordo uno de los paradigma de programación como es la programación funcional donde el elemento principal de dicho paradigma son los métodos y funciones. [1]\n\n8. Glosario de términos: [1]\n9. Bibliografía: [1]\n10. Recursos educativos digitales RED: [1]\n11. Próxima unidad: Arreglos y matrices. Introducción arreglos. [1]",
                "metadata": {
                    "file_name": "guia_aprendizaje_11_evaluativa.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Programación funcional.\nUnidad didáctica: Introducción a las funciones y métodos de clase.\n1. Objetivos de la unidad didáctica:\nCaracterizar un método de clase.\nIdentificar los principales elementos que componen un método de clase.\n2. Introducción a la unidad didáctica:\nLa mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta ahora. La experiencia ha demostrado que la mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos. A esta técnica se le llama divide y vencerás.\n\nExisten tres tipos de módulos en Java: métodos, clases y paquetes. Para escribir programas en Java, se combinan los nuevos métodos y clases que usted escribe con los métodos y clases predefinidos, que están disponibles en la Interfaz de Programación de Aplicaciones de Java (también conocida como la API de Java o biblioteca de clases de Java) y en diversas bibliotecas de clases. Por lo general, las clases relacionadas están agrupadas en paquetes, de manera que se pueden importar a los programas y reutilizarse.\n\nEn esta guía abordaremos sobre en el módulo mas pequeño de los tres anteriores: los métodos.\n\nLos métodos (también conocidos como funciones o procedimientos en otros lenguajes) permiten al programador dividir un programa en módulos, por medio de la separación de sus tareas en unidades autónomas. Usted ha declarado métodos en todos los programas que ha escrito; a estos métodos se les conoce algunas veces como métodos declarados por el programador. Las instrucciones en los cuerpos de los métodos se escriben sólo una vez, y se reutilizan tal vez desde varias ubicaciones en un programa; además, están ocultas de otros métodos.\n\nLos métodos son declarados siempre dentro de una clase. En el lenguaje de programación Java existe dos tipos de métodos: los métodos de clase y los métodos de un objeto de clase. En esta guía y en las posteriores que aborden este tema trabajaremos con los métodos de clase. Vamos a partir de un ejemplo para entender lo que se ha mencionado hasta ahora para eso vamos a partir del ejercicio 2 dejado en una guía de aprendizaje evaluativa anterior el mismo planteaba lo siguiente: Diseñe un algoritmo que permita determinar sin con tres números se puede o no conformar un triángulo cuyos lados tendrían como longitudes dichos valores. En caso que se pueda conformar el triángulo el algoritmo debe ser capaz de imprimir la clasificación de dicho triángulo atendiendo a las longitudes de sus lados. Tenga en cuenta que el algoritmo debe solicitar o pedir los valores por pantalla. Utilice una de las técnicas para representar algoritmo que sea mas de su agrado. Transcriba dicho algoritmo a lenguaje de programación de Java.\n\nAnálisis del problema\nBueno es evidente que mi programa debe ser capaz de solicitar al usuario 3 números y ver si con dichos valores se cumple la desigualdad triangular y en caso de cumplir tendría que clasificar el triángulo que ser formaría acorde a los valores siendo eso valores las longitudes de los lados del supuesto triángulo. Analizado esto lo primero será nuestro realizar nuestro diagrama para representar el algoritmo el mismo queda de la siguiente manera. Una vez realizado el diagrama de nuestro algoritmo vamos transcribirlo a lenguaje de programación Java.\n\nimport java.util.Scanner;\n\n\u0001public class Main{\n\npublic static void main(String[] args){\n\ndouble A,B,C;\n\nScanner input = new Scanner(System.in);\n\n    System.out.print(\"Entre el valor de A: \");\n\nA = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de  B: \");\n\nB = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de C: \");\n\nC = input.nextDouble();\n\nif (A+B>C && A+C>B && B+C>A){\n\nSystem.out.print(\"Con esos valores se puede conformar un triangulo \");\n\nif (A==B && A==C){\n\nSystem.out.print(\"Equilatero\");\n\n} else if ( (A==B && A!=C) || (A==C && A!=B) || (C==B && A!=C)){\n\nSystem.out.print(\"Isosceles\");\n\n} else {\n\nSystem.out.print(\"Escaleno\");\n\n}\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\nLo primero a notar es que la transcripción a Java no fiel al 100% (esto puede pasar perfectamente ya sea porque una varias ideas en nuestro diseño de algoritmo se puede realizar en una sola sentencia o bien a la inversa) sino que hizo una mejora en cuanto al caso que se pueda conformar un triángulo del tipo isósceles. Ahora pensemos que tenemos otros problemas donde bien tenemos que comprobar la desigualdad triangular o saber el tipo de triángulo acorde a sus lados. Lo primero que se nos viene a la mente es copiar y pegar pero esta acción nos puede resultar un poco engorrosa por el hecho que tenemos que adaptar o acomodar fragmentos de código dentro de otro. Bueno y si en vez ajustar código creamos un fragmento de código un tanto autónomo encarga",
                "metadata": {
                    "file_name": "guia_aprendizaje_6.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "atero\");\n\n} else if ( (A==B && A!=C) || (A==C && A!=B) || (C==B && A!=C)){\n\nSystem.out.print(\"Isosceles\");\n\n} else {\n\nSystem.out.print(\"Escaleno\");\n\n}\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\nLo primero a notar es que la transcripción a Java no fiel al 100% (esto puede pasar perfectamente ya sea porque una varias ideas en nuestro diseño de algoritmo se puede realizar en una sola sentencia o bien a la inversa) sino que hizo una mejora en cuanto al caso que se pueda conformar un triángulo del tipo isósceles. Ahora pensemos que tenemos otros problemas donde bien tenemos que comprobar la desigualdad triangular o saber el tipo de triángulo acorde a sus lados. Lo primero que se nos viene a la mente es copiar y pegar pero esta acción nos puede resultar un poco engorrosa por el hecho que tenemos que adaptar o acomodar fragmentos de código dentro de otro. Bueno y si en vez ajustar código creamos un fragmento de código un tanto autónomo encargado únicamente de realizar una acción o tarea y lo utilizó dentro de mi programa cuando haga falta. Vamos a aplicar esto a nuestro código anterior para ver como nos queda.\n\nimport java.util.Scanner;\n\n\u0001public class Main{\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\nreturn true;\n\n  } else {\n\nreturn false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\nreturn \"Equilatero\";\n\n} else if ( (ladoA==ladoB && ladoA!=ladoC) ||\n\n                                                      (ladoA==ladoC && ladoA!=ladoB) ||\n\n                                                      (ladoC==ladoB && ladoA!=ladoC)){\n\nreturn \"Isosceles\";\n\n} else {\n\nreturn \"Escaleno\";\n\n}\n\n}\n\npublic static void main(String[] args){\n\ndouble A,B,C,x1=0,x2=0;\n\nScanner input = new Scanner(System.in);\n\n    System.out.print(\"Entre el valor de A: \");\n\nA = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de  B: \");\n\nB = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de C: \");\n\nC = input.nextDouble();\n\nif (desigualdadTriangular(A,B,C) == true){\n\nSystem.out.print(\"Con esos valores se puede conformar un triangulo \");\n\nSystem.out.println(clasificarTrianguloPorLados(A,B,C));\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\n}\n\n*Es evidente que el código del método main se simplificó notablemente. Claro va existir detractores que van a criticar el aumento la cantidad de código del programa de forma general. Pero vamos analizar que ya contamos con dos funciones como son desigualdadTriangular y clasificarTrianguloPorLados las cuales realizan acción o tarea en específico y como están encapsuladas dentro de un método son altamente exportable hacia otros programas donde lo debemos copiarla tal y como están y usarla como se hizo en el método main . Con este último código vamos a trabajar en las actividades de auto-aprendizajes.*\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de págin",
                "metadata": {
                    "file_name": "guia_aprendizaje_6.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "e lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n5. Actividades de auto-aprendizajes:\nCual es la palabra reservada del lenguaje de programación Java define que un método sea de clase o de un objeto de clase. Identifique dicha palabra en el código presentado en la Introducción a la unidad didáctica.\nPor qué el método main se declara como static ?.\nCual es la palabra reservada del lenguaje de programación Java permite que un método devuelva o retorne un resultado. Identifique dicha palabra en el código presentado en la Introducción a la unidad didáctica.\nEn que partes o secciones se divide un método de clase. Identifique dichas partes o secciones en cada método de los presentados en el código presentado en la Introducción a la unidad didáctica.\nEn la cabecera de un método que palabra reservada del lenguaje de programación Java se utiliza para indicar que el método no retorna ni devuelve un valor, en caso de que devuelva o retorna algún valor que se debe colocar. Utilice el código presentado en la Introducción a la unidad didáctica de apoyo. 6. Las variables ladoA, ladoB, ladoC que papel desempeñan dentro de los métodos desigualdadTriangular y clasificarTrianguloPorLados presentados en el código de la Introducción a la unidad didáctica\nQue palabras reservadas del lenguaje de programación define la visibilidad o nivel de acceso a variables, métodos y clases. Identifique una de esas palabras en el código presentado en la Introducción a la unidad didáctica .\n6. Actividades de evaluación:\nTomando el código presentado en la Introducción a la unidad didáctica haga en el las adecuaciones necesarias para que ahora sea un programa que solicite tres valores que representan la amplitud de 3 ángulos en grados sexagesimales y diga si se puede o no formar un triangulo cuyos ángulos tengan esa amplitud en caso de porder formarse que clasifique dicho triángulo basado en la amplitud de sus ángulos.\n7. Resumen:\nUna razón para dividir un programa en módulos mediante los métodos es la metodología “divide y vencerás”, que hace que el desarrollo de programas sea más fácil de administrar, ya que se pueden construir programas a partir de piezas pequeñas y simples. Otra razón es la reutilización de software (usar los métodos existentes como bloques de construcción para crear nuevos programas). A menudo se pueden crear programas a partir de métodos estandarizados, en vez de tener que crear código personalizado.\n\n8. Glosario de términos:\nConsulte la bibliografía y defina el funcionamiento de las siguientes palabras reservadas: void: static:\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 3 epígrafes 3.1, 3.2, 3.3, 3.4. Cómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 6 completo\n\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Cabeceras de las funciones y métodos de clase.",
                "metadata": {
                    "file_name": "guia_aprendizaje_6.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Programación funcional.\nUnidad didáctica: Cabeceras de las funciones y métodos de clase.\n1. Objetivos de la unidad didáctica:\nCaracterizar la cabecera de una función o método de clase.\nIdentificar los principales elementos que componen la cabecera de una función o método de clase.\n2. Introducción a la unidad didáctica:\nEn guías de aprendizajes anteriores se había abordado que la mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta ahora. La experiencia ha demostrado que la mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos.\n\nSe había definido que existen tres tipos de módulos en Java: métodos, clases y paquetes. Y que el módulo más pequeño de los tres anteriores era: los métodos. En guía anteriores teníamos como ejemplo de métodos de clase los siguientes métodos:\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\n    return true;\n\n  } else {\n\n    return false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\n    return \"Equilatero\";\n\n  } else if ( (ladoA==ladoB && ladoA!=ladoC) ||\n\n                                                     (ladoA==ladoC && ladoA!=ladoB) ||\n\n                                                     (ladoC==ladoB && ladoA!=ladoC)){\n\n    return \"Isosceles\";\n\n  } else {\n\n    return \"Escaleno\";\n\n  }\n\n}\n\npublic static void main(String[] args){\n\n  double A,B,C,x1=0,x2=0;\n\n  Scanner input = new Scanner(System.in);\n\n      System.out.print(\"Entre el valor de A: \");\n\n  A = input.nextDouble();\n\n  System.out.print(\"Entre el valor de  B: \");\n\n  B = input.nextDouble();\n\n  System.out.print(\"Entre el valor de C: \");\n\n  C = input.nextDouble();\n\n  if (desigualdadTriangular(A,B,C) == true){\n\n    System.out.print(\"Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nCon la realización de la guías de aprendizaje anteriores se determino que los métodos o funciones de clases en su conformación o implementación se compone de dos secciones o partes esenciales: header/body. El header o cabecera declarativa de una función o método es la sección donde se define los elementos básicos y fundamentales de la función. Mientras en el body o cuerpo de función es donde se define los pasos e instrucciones del algoritmo que ejecutará el método o función una vez que sea invocado, estos pasos e instrucciones van a depender de cierta manera de lo que se defina en el header del método. Aplicando lo anterior en los métodos anteriormente descritos quedaría de la siguiente manera.\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\n    return true;\n\n  } else {\n\n    return false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\n    return \"Equilatero\";\n\n  } else if ( (ladoA==ladoB && ladoA!=ladoC) || (ladoA==ladoC && ladoA!=ladoB) || (ladoC==ladoB && ladoA!=ladoC)){\n\n    return \"Isosceles\";\n\n  } else {\n\n    return \"Escaleno\";\n\n  }\n\n}\n\npublic static void main(String[] args){\n\n  double A,B,C,x1=0,x2=0;\n\n  Scanner input = new Scanner(System.in);\n\n      System.out.print(\"Entre el valor de A: \");\n\n  A = input.nextDouble();\n\n  System.out.print(\"Entre el valor de  B: \");\n\n  B = input.nextDouble();\n\n  System.out.print(\"Entre el valor de C: \");\n\n  C = input.nextDouble();\n\n  if (desigualdadTriangular(A,B,C) == true){\n\n    System.out.print(\"Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nEl texto con color rojo representa la sección representa el header o cabacera del método mientras el color verde representa el body o cuerpo de implementación. En la presente guía abordaremos los elementos presentes en la zona roja del método.\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las",
                "metadata": {
                    "file_name": "guia_aprendizaje_7.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "int(\"Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nEl texto con color rojo representa la sección representa el header o cabacera del método mientras el color verde representa el body o cuerpo de implementación. En la presente guía abordaremos los elementos presentes en la zona roja del método.\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n5. Actividades de auto-aprendizajes:\nEl primer elemento del header de un método de clase define la visibilidad o nivel de acceso del método. Cuales son las palabras reservadas del lenguaje de programación Java que definen nivel de acceso o visibilidad. Explique el nivel de acceso o visibilidad de cada una. Identifique una de esas palabras reservadas en el código presentado en la Introducción a la unidad didáctica.\nEl segundo elemento del header de un método de clase es la palabra reservada del lenguaje de programación Java define que un método sea de clase o de un objeto de clase. Identifique dicha palabra en el código presentado en la Introducción a la unidad didáctica.\nEl tercer elemento del header de un método indica el tipo de dato de la información o dato que retorna o devuelve. Identifique los tipos de datos que retorna los métodos en el código presentado en la Introducción a la unidad didáctica. a. En caso de que el método no retorne o devuelva ningún dato que palabra reservada de lenguaje de programación Java es utilizado para indicarlo en el header del método. Cuál de los métodos presentados en el código presentado en la Introducción a la unidad didáctica no retorna ningún dato o información. b. Cuales de los métodos presentados en el código presentado en la Introducción a la unidad didáctica devuelven algún dato o información y cuales no retornan nada. En en caso de los que retornan que tipo de datos retornan.\nEl cuarto elemento del header de un método indica el identificador o nombre de la función. Que reglas de formación o construcción deben cumplir los nombre de los método y funciones. Identifique los nombre o identificadores de los métodos en el código presentado en la Introducción a la unidad didáctica. En el momento de definir el nombre o identificador de un método cual de los dos ideas es la mas conveniente y porque. a. Elegir un nombre o identificador acorde al procedimiento que realizará el método. b. Elegir un nombre o identificador por inspiración de la musa artística del programador.\nEl quinto elemento del header de un método de clase son los parámetros los cuales son definidos entre la pareja de paréntesis () del header. Identifique los parámetros, en cada método de los presentados en el código presentado en la Introducción a la unidad didáctica.\nCual es el objetivo o que papel juegan los parámetros en un método o función de clase. Es posible definir un método o función de clase sin parámetros ?. De ser posible como se manifiesta dicha situación en el header del método o función de la clas",
                "metadata": {
                    "file_name": "guia_aprendizaje_7.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "n o construcción deben cumplir los nombre de los método y funciones. Identifique los nombre o identificadores de los métodos en el código presentado en la Introducción a la unidad didáctica. En el momento de definir el nombre o identificador de un método cual de los dos ideas es la mas conveniente y porque. a. Elegir un nombre o identificador acorde al procedimiento que realizará el método. b. Elegir un nombre o identificador por inspiración de la musa artística del programador.\nEl quinto elemento del header de un método de clase son los parámetros los cuales son definidos entre la pareja de paréntesis () del header. Identifique los parámetros, en cada método de los presentados en el código presentado en la Introducción a la unidad didáctica.\nCual es el objetivo o que papel juegan los parámetros en un método o función de clase. Es posible definir un método o función de clase sin parámetros ?. De ser posible como se manifiesta dicha situación en el header del método o función de la clase.\nQue elemento o símbolo es utilizado para diferenciar o separar los diferentes parámetros que puede tener un método o función de clase. Identifique dicho símbolo en los métodos del código presentado en la Introducción a la unidad didáctica.\nEn el momento de definir los parámetros de una función método de una clase en el header que información o datos hay que definir de cada parámetros. Identifique dicho datos de los parámetros en los métodos del código presentado en la Introducción a la unidad didáctica.\nDefina la sintaxis del header de un método o función de clase en el lenguaje de programación Java a partir de los elementos abordados en la guía de aprendizaje.\n6. Actividades de evaluación:\n1.Declare e implemente una función o método de clase utilizando el lenguaje de programación Java que permita calcular y retornar el área de un círculo. Dicha función o método recibe por parámetro el radio del círculo al cual se desea calcular el área. 2.Declare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita calcular y retornar el área de un sector circular. Dicha función o método recibe por parámetro el radio de la circunferencia y el ángulo del sector circular. El ángulo esta expresado en grado sexagesimal. 3. Declare e implemente una función o método (no puede ser el método main) de clase utilizando el lenguaje de programación de Java que permita imprimir el texto \"Que extraña función\" por consola.\n\n7. Resumen:\nUn método o función de clase se compone de dos secciones bien definidas como son el header o cabecera y body o cuerpo de implementación. En el header o cabecera del método se definen una serie de elementos de un función o métodos que nos dan de forma resumida una idea o información acerca del método sin tener que analizar el body o cuerpo de implementación. Muchas veces lo que se defina en el body o cuerpo de implementación de una función o método de clase va depender en cierta de lo que se defina en el header o cabecera de la misma.\n\n8. Glosario de términos:\nConsulte la bibliografía y defina el concepto del siguiente término: parámetro de una función:\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 3 epígrafes 3.1, 3.2, 3.3, 3.4. Cómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 6 completo\n\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Body o cuerpo de implementación de las funciones y métodos de clase.",
                "metadata": {
                    "file_name": "guia_aprendizaje_7.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Programación funcional.\nUnidad didáctica: Cuerpos de las funciones y métodos de clase.\n1. Objetivos de la unidad didáctica:\nCaracterizar el cuerpos de una función o método de clase.\nIdentificar los principales elementos que componen el cuerpo de una función o método de clase.\n2. Introducción a la unidad didáctica:\nEn guías de aprendizajes anteriores se había abordado que la mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta ahora. La experiencia ha demostrado que la mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos.\n\nSe había definido que existen tres tipos de módulos en Java: métodos, clases y paquetes. Y que el módulo más pequeño de los tres anteriores era: los métodos. En guía anteriores teníamos como ejemplo de métodos de clase los siguientes métodos:\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\n    return true;\n\n  } else {\n\n    return false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\n    return \"Equilatero\";\n\n  } else if ( (ladoA==ladoB && ladoA!=ladoC) ||\n\n                                                     (ladoA==ladoC && ladoA!=ladoB) ||\n\n                                                     (ladoC==ladoB && ladoA!=ladoC)){\n\n    return \"Isosceles\";\n\n  } else {\n\n    return \"Escaleno\";\n\n  }\n\n}\n\npublic static void main(String[] args){\n\n  double A,B,C,x1=0,x2=0;\n\n  Scanner input = new Scanner(System.in);\n\n      System.out.print(\"Entre el valor de A: \");\n\n  A = input.nextDouble();\n\n  System.out.print(\"Entre el valor de  B: \");\n\n  B = input.nextDouble();\n\n  System.out.print(\"Entre el valor de C: \");\n\n  C = input.nextDouble();\n\n  if (desigualdadTriangular(A,B,C) == true){\n\n    System.out.print(\"Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nCon la realización de la guías de aprendizaje anteriores se determino que los métodos o funciones de clases en su conformación o implementación se compone de dos secciones o partes esenciales: header/body. El header o cabecera declarativa de una función o método es la sección donde se define los elementos básicos y fundamentales de la función. Mientras en el body o cuerpo de función es donde se define los pasos e instrucciones del algoritmo que ejecutará el método o función una vez que sea invocado, estos pasos e instrucciones van a depender de cierta manera de lo que se defina en el header del método. Aplicando lo anterior en los métodos anteriormente descritos quedaría de la siguiente manera.\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\n    return true;\n\n  } else {\n\n    return false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\n    return \"Equilatero\";\n\n  } else if ( (ladoA==ladoB && ladoA!=ladoC) || (ladoA==ladoC && ladoA!=ladoB) || (ladoC==ladoB && ladoA!=ladoC)){\n\n    return \"Isosceles\";\n\n  } else {\n\n    return \"Escaleno\";\n\n  }\n\n}\n\npublic static void main(String[] args){\n\n  double A,B,C,x1=0,x2=0;\n\n  Scanner input = new Scanner(System.in);\n\n      System.out.print(\"Entre el valor de A: \");\n\n  A = input.nextDouble();\n\n  System.out.print(\"Entre el valor de  B: \");\n\n  B = input.nextDouble();\n\n  System.out.print(\"Entre el valor de C: \");\n\n  C = input.nextDouble();\n\n  if (desigualdadTriangular(A,B,C) == true){\n\n    System.out.print(\"Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nEl texto con color rojo representa la sección representa el header o cabacera del método mientras el color verde representa el body o cuerpo de implementación. En la presente guía abordaremos los elementos presentes en la zona verde del método.\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fec",
                "metadata": {
                    "file_name": "guia_aprendizaje_8.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Con esos valores se puede conformar un triangulo \");\n\n    System.out.println(clasificarTrianguloPorLados(A,B,C));\n\n  } else {\n\n    System.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n  }\n\n}\n\nEl texto con color rojo representa la sección representa el header o cabacera del método mientras el color verde representa el body o cuerpo de implementación. En la presente guía abordaremos los elementos presentes en la zona verde del método.\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n5. Actividades de auto-aprendizajes:\nCon que símbolo o elemento comienza el cuerpo de implementación de un método o función de clase. Identifique dicho símbolo o elemento en el código presentado en la Introducción a la unidad didáctica.\nCon que símbolo o elemento termina el cuerpo de implementación de un método o función de clase. Identifique dicho símbolo o elemento en el código presentado en la Introducción a la unidad didáctica.\nExiste alguna limitación en cuanto a la mínima o máxima a la cantidad de instrucciones que puede tener el cuerpo de un método o función de clases.\nSe puede declarar variables dentro del cuerpo de un método o función de clases. Si lo anterior es posible que sucede con el ámbito de vida de dicha variable. Utilice como referencia el código presentado en la Introducción a la unidad didáctica.\nDefina la sintaxis del cuerpo de un método o función de clase en el lenguaje de programación Java a partir de los elementos abordados en la guía de aprendizaje.\n6. Actividades de evaluación:\n1.Declare e implemente una función o método de clase utilizando el lenguaje de programación Java que permita calcular y retornar la cantidad de combinaciones de N en K. Dicha función o método recibe por parámetro los valores de N y K. 2.Declare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita calcular y retornar el factorial de N. Dicha función o método recibe por parámetro el valor de N. 3.Declare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita invertir un número entero N. Dicha función o método recibe por parámetro el valor de N. Ejemplo si la función recibe el numero 123 debe retornar el 321. Importante en el cuerpo del método o función solo se puede utilizar o declarar variables enteras.\n\n7. Resumen:\nUn método o función de clase se compone de dos secciones bien definidas como son el header o cabecera y body o cuerpo de implementación. En el body o cuerpo de implementación del método se define el algoritmo y secuencia de instrucciones que se deben ejecutar para que el método lleve a cabo el objetivo con el que fue creado. Aunque no existe limitación en cuanto a la cantidad de instrucciones que puede tener el body o cuerpo de implementación de un método es recomendable no superar las 200 instrucciones, si lo anterior sucediera se recomienda fracciones dicho método en varios métodos. Otra buena práctica es que los métodos siempre deben tratar de resolver un problema, intentar resolver varios problemas o cálculo",
                "metadata": {
                    "file_name": "guia_aprendizaje_8.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "va que permita invertir un número entero N. Dicha función o método recibe por parámetro el valor de N. Ejemplo si la función recibe el numero 123 debe retornar el 321. Importante en el cuerpo del método o función solo se puede utilizar o declarar variables enteras.\n\n7. Resumen:\nUn método o función de clase se compone de dos secciones bien definidas como son el header o cabecera y body o cuerpo de implementación. En el body o cuerpo de implementación del método se define el algoritmo y secuencia de instrucciones que se deben ejecutar para que el método lleve a cabo el objetivo con el que fue creado. Aunque no existe limitación en cuanto a la cantidad de instrucciones que puede tener el body o cuerpo de implementación de un método es recomendable no superar las 200 instrucciones, si lo anterior sucediera se recomienda fracciones dicho método en varios métodos. Otra buena práctica es que los métodos siempre deben tratar de resolver un problema, intentar resolver varios problemas o cálculos en un mismo método aunque estos sean similares puede complejizar la solución o el trabajo y utilización de dicho método.\n\n8. Glosario de términos:\nConsulte la bibliografía y defina el concepto del siguiente término: Ámbito de vida de una variable:\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 3 epígrafes 3.1, 3.2, 3.3, 3.4. Cómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 6 completo\n\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Llamada o invocación de de las funciones y métodos de clase.",
                "metadata": {
                    "file_name": "guia_aprendizaje_8.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema III Programación funcional\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema: Programación funcional.\nUnidad didáctica: Llamada o invocación de las funciones y métodos de clase.\n1. Objetivos de la unidad didáctica:\nCaracterizar la llamada o invocación de una función o método de clase.\nIdentificar los principales elementos que la llamada o invocación de una función o método de clase.\n2. Introducción a la unidad didáctica:\nEn guías de aprendizajes anteriores se había abordado que la mayoría de los programas de cómputo que resuelven los problemas reales son mucho más extensos que los programas que hemos desarrollado hasta ahora. La experiencia ha demostrado que la mejor manera de desarrollar y mantener un programa extenso es construirlo a partir de pequeñas piezas sencillas, o módulos. [1]\n\nSe había definido que existen tres tipos de módulos en Java: métodos, clases y paquetes. Y que el módulo más pequeño de los tres anteriores era: los métodos. [2]\n\nEn guía anteriores teníamos como ejemplo de métodos de clase los siguientes métodos: [2]\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\nreturn true;\n\n  } else {\n\nreturn false;\n\n  }\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\n  if (ladoA==ladoB && ladoA==ladoC){\n\nreturn \"Equilatero\";\n\n} else if ( (ladoA==ladoB && ladoA!=ladoC) ||\n\n                                                     (ladoA==ladoC && ladoA!=ladoB) ||\n\n                                                     (ladoC==ladoB && ladoA!=ladoC)){\n\nreturn \"Isosceles\";\n\n} else {\n\nreturn \"Escaleno\";\n\n}\n\n}\n\npublic static void main(String[] args){\n\ndouble A,B,C,x1=0,x2=0;\n\nScanner input = new Scanner(System.in);\n\n    System.out.print(\"Entre el valor de A: \");\n\nA = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de  B: \");\n\nB = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de C: \");\n\nC = input.nextDouble();\n\nif (desigualdadTriangular(A,B,C) == true){\n\nSystem.out.print(\"Con esos valores se puede conformar un triangulo \");\n\nSystem.out.println(clasificarTrianguloPorLados(A,B,C));\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\nCon la realización de la guías de aprendizaje anteriores se determino que los métodos o funciones de clases en su conformación o implementación se compone de dos secciones o partes esenciales: header/body. El header o cabecera declarativa de una función o método es la sección donde se define los elementos básicos y fundamentales de la función. Mientras en el body o cuerpo de función es donde se define los pasos e instrucciones del algoritmo que ejecutará el método o función una vez que sea invocado, estos pasos e instrucciones van a depender de cierta manera de lo que se defina en el header del método. Aplicando lo anterior en los métodos anteriormente descritos quedaría de la siguiente manera. [3]\n\npublic static boolean desigualdadTriangular(double ladoA, double ladoB, double ladoC){\n\nif (ladoA+ladoB>ladoC && ladoA+ladoC>ladoB && ladoB+ladoC>ladoA){\n\nreturn true;\n\n} else {\n\nreturn false;\n\n}\n\n}\n\npublic static String clasificarTrianguloPorLados(double ladoA, double ladoB, double ladoC){\n\nif (ladoA==ladoB && ladoA==ladoC){\n\nreturn \"Equilatero\";\n\n} else if ( (ladoA==ladoB && ladoA!=ladoC) || (ladoA==ladoC && ladoA!=ladoB) || (ladoC==ladoB && ladoA!=ladoC)){\n\nreturn \"Isosceles\";\n\n} else {\n\nreturn \"Escaleno\";\n\n}\n\n}\n\npublic static void main(String[] args){\n\ndouble A,B,C,x1=0,x2=0;\n\nScanner input = new Scanner(System.in);\n\n    System.out.print(\"Entre el valor de A: \");\n\nA = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de  B: \");\n\nB = input.nextDouble();\n\nSystem.out.print(\"Entre el valor de C: \");\n\nC = input.nextDouble();\n\nif (desigualdadTriangular(A,B,C) == true){\n\nSystem.out.print(\"Con esos valores se puede conformar un triangulo \");\n\nSystem.out.println(clasificarTrianguloPorLados(A,B,C));\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\nEl texto con color rojo representa la sección el header o cabecera del método mientras el color verde representa el body o cuerpo de implementación. [4]\n\nUn programa o software puede estar conformado por varios métodos o funciones independientemente que sean de clase a o no. Para que un método se ejecute debe ser invocado durante la ejecución del programa. A como invocar o llamar un método de clase va estar destinada la presente guía de aprendizaje. [4]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [4]\nCree hábitos de estudio sistemático; para esto: [5]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades di",
                "metadata": {
                    "file_name": "guia_aprendizaje_9.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "tln(clasificarTrianguloPorLados(A,B,C));\n\n} else {\n\nSystem.out.println(\"Con esos valores no se puede conformar un triangulo\");\n\n}\n\n}\n\nEl texto con color rojo representa la sección el header o cabecera del método mientras el color verde representa el body o cuerpo de implementación. [4]\n\nUn programa o software puede estar conformado por varios métodos o funciones independientemente que sean de clase a o no. Para que un método se ejecute debe ser invocado durante la ejecución del programa. A como invocar o llamar un método de clase va estar destinada la presente guía de aprendizaje. [4]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [4]\nCree hábitos de estudio sistemático; para esto: [5]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [5]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [5]\nUtilice técnicas de estudio: [6]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [6]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [6]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [6]\nInteractúe con los materiales de estudio en tres fases: [7]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [7]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [7]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [8]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [8]\n\n5. Actividades de auto-aprendizajes:\nEn el código presentado en la Introducción a la unidad didáctica se cuenta con tres métodos. Cuales de dichos métodos son invocados por otro método. Especifique en cada caso el método que realiza la invocación o llamada y el método que es llamado o invocado. [8]\nCuantas veces puede ser invocado o llamado un método ?. [9]\nQue elementos del método se necesita conocer para poder realizar una invocación o llamada del mismo ?. [9]\nCuando se invoca o se llama a un método y este recibe parámetros, en la invocación se debe tener presente los parámetros ?. En caso de tenerse en cuenta que relación debe existir entre los valores o variables utilizados como los parámetros en la invocación o llamada y los parámetros definidos en la declaración e implementación. [9]\nComo se invoca o llama a un método de clase que pertenece a otra clase diferente a la donde realizo la invocación o llamada. Pista: como se invoca o llama a los métodos de la clase Math de Java. [9]\nPuede ser la invocación o llamada de un método fungir como parámetro de una invocación o llamada de otro método ?. [10]\nEn el código presentado en la Introducción a la unidad didáctica cuantas invocaciones o llamadas a métodos se realizan. Cite cada una por el número línea de código. [10]\n6. Actividades de evaluación:\nDeclare e implemente una función o método de clase utilizando el lenguaje de programación Java que permita calcular y retornar la cantidad de combinaciones de N en K. Dicha función o método recibe por parámetro los valores de N y K. Haga un programa donde se invoque o llame a dicho método. [10]\nDeclare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita calcular y retornar el factorial de N. Dicha función o método recibe por parámetro el valor de N. Haga un programa donde se invoque o llame a dicho método [11]\nDeclare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita invertir un número entero N. Dicha función o método recibe por parámetro el valor de N. Ejemplo si la función recibe el numero 123 debe retornar el 321. Importante en el cuerpo del método o función solo se puede utilizar o declarar variables enteras. Haga un programa donde se invoque o llame a dicho método. [11]\n7. Resumen:\nPara poder invocar o llamar a un método se necesita con",
                "metadata": {
                    "file_name": "guia_aprendizaje_9.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ando el lenguaje de programación Java que permita calcular y retornar la cantidad de combinaciones de N en K. Dicha función o método recibe por parámetro los valores de N y K. Haga un programa donde se invoque o llame a dicho método. [10]\nDeclare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita calcular y retornar el factorial de N. Dicha función o método recibe por parámetro el valor de N. Haga un programa donde se invoque o llame a dicho método [11]\nDeclare e implemente una función o método de clase utilizando el lenguaje de programación de Java que permita invertir un número entero N. Dicha función o método recibe por parámetro el valor de N. Ejemplo si la función recibe el numero 123 debe retornar el 321. Importante en el cuerpo del método o función solo se puede utilizar o declarar variables enteras. Haga un programa donde se invoque o llame a dicho método. [11]\n7. Resumen:\nPara poder invocar o llamar a un método se necesita conocer el nombre o identificador del método así como los parámetros que recibe este. Cuando se invoca es necesario mantener la misma cantidad de parámetros y respetar el tipo de dato y el orden en que fueron declarados en el método. No existe limitaciones en cuanto a la cantidad de invocaciones que se le puede realizar a un método. [12]\n\n8. Glosario de términos:\nConsulte la bibliografía y defina el concepto del siguiente término: [12]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 3 epígrafes 3.1, 3.2, 3.3, 3.4. [13]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 6 completo [13]\n\n10. Recursos educativos digitales RED: [13]\n11. Próxima unidad: Funciones y métodos de clase recursivos. [13]\n",
                "metadata": {
                    "file_name": "guia_aprendizaje_9.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema IV Cadenas de caracteres\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Cadenas de caracteres.\nUnidad didáctica: Cadenas de caracteres. Introducción.\n1. Objetivos de la unidad didáctica:\nIdentificar las clases que tiene el lenguaje de programación Java para manejar las cadenas de caracteres.\nCaracterizar la clase String del lenguaje de programación Java.\nCaracterizar la clase StringBuffer del lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nLos caracteres son los bloques de construcción básicos de los programas fuente de Java. Todo programa está compuesto de una secuencia de caracteres que, cuando se agrupan en forma significativa, son interpretados por la computadora como una serie de instrucciones utilizadas para realizar una tarea. Un programa puede contener literales de carácter. Una literal de carácter es un valor entero representado como un carácter entre comillas simples. Por ejemplo, 'z' representa el valor entero de z, y '\\n' representa el valor entero de una nueva línea. Es de los tipos de datos que presentan los datos con los cuales se implementa un software en incluso la mayoría de los datos que introduce los usuarios en software son cadenas de caracteres (entiéndase como cadena de caracteres una palabra, nombre, apellidos, un párrafo o texto o una secuencia de caracteres imprimibles desde el teclado). Este tipo de información puede ser almacenada con nuestro conocimientos de programación hasta el momento en un arreglo de tipo de dato char.\n\nEsta variante aunque no esta mal hace que el posterior trabajo con este tipo de información o dato sea un tanto compleja. Es por eso que la mayoría de los lenguajes de programación de alto nivel tipado presentan dentro de sus elementos nativos clases que permiten almacenar y manipular este tipo de información de una mejor manera para los programadores. En el caso del lenguaje de programación de Java el mismo cuenta con las clases String, StringBuffer y StringBuilder. [1]\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [2]\nCree hábitos de estudio sistemático; para esto: [2]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [2]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [3]\nUtilice técnicas de estudio: [3]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [3]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [3]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [3]\nInteractúe con los materiales de estudio en tres fases: [4]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [4]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [4]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [5]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [5]\n\n5. Actividades de auto-aprendizajes:\nDiferencias entre la clase String, StringBuffer y StringBuilder del lenguaje de programación Java. [5]\nA cuales paquetes de Java pertenecen las clases String, StringBuffer y StringBuilder. [6]\nQué ocurre cuando entre dos variables de tipo String aplico el operador + ?. [6]\nInvestigue el cual el es el máximo de caracteres que soporta cada una de las siguientes clases String, StringBuffer y StringBuilder. [6]\n6. Actividades de evaluación:\nElabore un cuadro comparativo en cuantos a funcionalidades, semejanzas, diferencias, ventajas y desventajas entre las clases String, StringBuffer y StringBuilder. [6]\n7. Resumen:\nLas clases String, StringBuffer y StringBuilder presente en el lenguaje de programación en Java muchas veces se confunden con tipos de datos nativos del lenguaje cuando no es así. Lo cabe duda es la utilidad que tienen dichas clases para el trabajo y almacenamiento de las cadenas de cara",
                "metadata": {
                    "file_name": "Guía de aprendizaje 18.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "vegadores de páginas Web y el correo electrónico. [5]\n\n5. Actividades de auto-aprendizajes:\nDiferencias entre la clase String, StringBuffer y StringBuilder del lenguaje de programación Java. [5]\nA cuales paquetes de Java pertenecen las clases String, StringBuffer y StringBuilder. [6]\nQué ocurre cuando entre dos variables de tipo String aplico el operador + ?. [6]\nInvestigue el cual el es el máximo de caracteres que soporta cada una de las siguientes clases String, StringBuffer y StringBuilder. [6]\n6. Actividades de evaluación:\nElabore un cuadro comparativo en cuantos a funcionalidades, semejanzas, diferencias, ventajas y desventajas entre las clases String, StringBuffer y StringBuilder. [6]\n7. Resumen:\nLas clases String, StringBuffer y StringBuilder presente en el lenguaje de programación en Java muchas veces se confunden con tipos de datos nativos del lenguaje cuando no es así. Lo cabe duda es la utilidad que tienen dichas clases para el trabajo y almacenamiento de las cadenas de caracteres hacen que muchos de los programadores la tomen como datos nativos del lenguaje. [7]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos: [7]\n\nClase (en programación) [7]\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.2. [8]\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 30 epigrafes 30.1, 30.2, 30.3 y 30.4. [8]\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Clase String. [8]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 18.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema IV Cadenas de caracteres\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema: Cadenas de caracteres.\nUnidad didáctica: Clase String. Sus principales métodos.\n1. Objetivos de la unidad didáctica:\nCaracterizar la clase String del lenguaje de programación Java.\nIdentificar y caracterizar los principales métodos de la clase String.\n2. Introducción a la unidad didáctica:\nLa clase String está orientada a manejar cadenas de caracteres constantes, es decir, que no pueden cambiar. [1]\n\nLos objetos de la clase String se pueden crear a partir de cadenas constantes o literals, definidas entre dobles comillas, como por ejemplo: \"Hola\". Java crea siempre un objeto String al encontrar una cadena entre comillas. A continuación se describen dos formas de crear objetos de la clase String. [2]\n\nString str1 = \"Hola\"; // el sistema más eficaz de crear Strings\n\nString str2 = new String(\"Hola\"); // también se pueden crear con un constructor\n\nEl primero de los métodos expuestos es el más eficiente, porque como al encontrar un texto entre comillas se crea automáticamente un objeto String, en la práctica utilizando new se llama al constructor dos veces. [2]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [3]\nCree hábitos de estudio sistemático; para esto: [3]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [3]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [4]\nUtilice técnicas de estudio: [4]\nElija un entorno de estudio que resulte agradable y sin elementos que lo distraigan. [4]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [4]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [4]\nInteractúe con los materiales de estudio en tres fases: [5]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [5]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [5]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [6]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [6]\n\n5. Actividades de auto-aprendizajes:\nCuales métodos de la clase String determinan la longitud de una cadena, obtienen el carácter que se encuentra en una ubicación específica de una cadena y recuperan el conjunto completo de caracteres en una cadena. [6]\nCuales métodos de la clase String permiten comparar dos cadenas. Caracterice el funcionamiento de cada una y establezca semejanzas y diferencias entre dichos métodos. [7]\nCuales métodos de la clase String permiten localización de caracteres y subcadenas en las cadenas. Caracterice el funcionamiento de cada una y establezca semejanzas y diferencias entre dichos métodos. [7]\nCuales métodos de la clase String permiten extracción de subcadenas de las cadenas. Caracterice el funcionamiento de cada una y establezca semejanzas y diferencias entre dichos métodos. [7]\nCuales métodos de la clase String permiten concatenación de cadenas. Caracterice el funcionamiento de cada una y establezca semejanzas y diferencias entre dichos métodos. [8]\n6. Actividades de evaluación:\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario una cadena de caracteres. Dicho programa debe determinar si la cadena de caracteres introducida por el usuario es palíndromo o no. Una cadena de caracteres es palíndromo cuando se puede leer los mismo de izquierda a derecha y de derecha a izquierda. [8] Por ejemplo la palabra somos es palíndromo. [9]\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario dos cadenas de caracteres. Dicho programa debe determinar si las cadenas de caracteres introducidas por el usuario son anagramas. Dos cadenas son anagramas si cumplen: [9]\nTienen las misma cantidad de caracteres [9]\nTienen la misma cantidad de cada tipo d",
                "metadata": {
                    "file_name": "Guía de aprendizaje 19.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "s y diferencias entre dichos métodos. [7]\nCuales métodos de la clase String permiten concatenación de cadenas. Caracterice el funcionamiento de cada una y establezca semejanzas y diferencias entre dichos métodos. [8]\n6. Actividades de evaluación:\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario una cadena de caracteres. Dicho programa debe determinar si la cadena de caracteres introducida por el usuario es palíndromo o no. Una cadena de caracteres es palíndromo cuando se puede leer los mismo de izquierda a derecha y de derecha a izquierda. [8] Por ejemplo la palabra somos es palíndromo. [9]\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario dos cadenas de caracteres. Dicho programa debe determinar si las cadenas de caracteres introducidas por el usuario son anagramas. Dos cadenas son anagramas si cumplen: [9]\nTienen las misma cantidad de caracteres [9]\nTienen la misma cantidad de cada tipo de letra. [9]\nNo son iguales. [9] Por ejemplo zorra y arroz son anagramas, pero alata y talla no lo son. [9]\n7. Resumen:\nUn punto importante a tener en cuenta es que hay métodos, tales como System.out.println(), que exigen que su argumento sea un objeto de la clase String. Si no lo es, habrá que utilizar algún método que lo convierta en String en este caso se puede utilizar valueOf. [10]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos: [10]\n\nObjeto de clase (en programación) [10]\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.2. [11]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 30 epigrafes 30.1, 30.2, 30.3 y 30.4. [11]\n\n10. Recursos educativos digitales RED: [11]\n11. Próxima unidad: Clase StringBuilder. [11]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 19.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema IV Cadenas de caracteres\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Cadenas de caracteres.\nUnidad didáctica: Clase StringBuffer. Sus principales métodos.\n1. Objetivos de la unidad didáctica:\nCaracterizar la clase StringBuffer del lenguaje de programación Java.\nIdentificar y caracterizar los principales métodos de la clase StringBuffer.\n2. Introducción a la unidad didáctica:\nLa clase StringBuffer permite que el programador cambie la cadena insertando, borrando, etc. [1] La clase StringBuffer se utiliza prácticamente siempre que se desee modificar una cadena de caracteres. Completa los métodos de la clase String ya que éstos realizan sólo operaciones sobre el texto que no conllevan un aumento o disminución del número de letras del String. [2]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [2]\nCree hábitos de estudio sistemático; para esto: [3]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [3]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [3]\nUtilice técnicas de estudio: [4]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan. [4]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [4]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [4]\nInteractúe con los materiales de estudio en tres fases: [5]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [5]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [5]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [6]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [6]\n\n5. Actividades de auto-aprendizajes:\nCuales métodos de la clase StringBuffer determinan la longitud de una cadena, obtienen el carácter que se encuentra en una ubicación específica de una cadena y recuperan el conjunto completo de caracteres en una cadena. [6]\nCuales métodos de la clase StringBuffer permiten modificar la cantidad de caracteres de la cadena y cambiar el carácter en una determinada posición de la cadena. Caracterice el funcionamiento de cada una. [7]\nCuales métodos de la clase StringBuffer permiten concatenación de cadena. Caracterice el funcionamiento de cada una. [7]\nEstablezca diferencia y semejanzas entre las clases StringBuffer y StringBuilder en cuanto a los siguientes aspectos: [7]\nUso. [7]\nMétodos. [7]\n6. Actividades de evaluación:\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario una cadena de caracteres. Dicho programa debe imprimir la cadena de caracteres introducida por el usuario es sustituyendo cada carácter de tipo vocal por el símbolo punto (.). [7] Realice dos variantes del mismo programa uno utilizando String y otro usando StringBuffer. [8]\nElabore un programa utilizando el lenguaje de programación Java que permita introducir al usuario una cadena de caracteres. El programa debe determinar e imprimir cuantas permutaciones diferentes entre si se puede conformar con los caracteres de la cadena introducida. De dichas permutaciones de la cadena el programa debe imprimir la menor y la mayor lexicográficamente. [8]\n7. Resumen:\nMientras la clase String es más eficiente, StringBuffer permite más posibilidades y es un complemento de la clase String. [8]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos: [9]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.2. [9]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 30 epigrafes 30.1, 30.2, 30.3 y 30.4. [9]\n\n10. Recursos educativos digitales RED: [9]\n11. Próxima unidad: Clase StringBuilder. [9]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 20.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "zando el lenguaje de programación Java que permita introducir al usuario una cadena de caracteres. El programa debe determinar e imprimir cuantas permutaciones diferentes entre si se puede conformar con los caracteres de la cadena introducida. De dichas permutaciones de la cadena el programa debe imprimir la menor y la mayor lexicográficamente. [8]\n7. Resumen:\nMientras la clase String es más eficiente, StringBuffer permite más posibilidades y es un complemento de la clase String. [8]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos: [9]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.2. [9]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 30 epigrafes 30.1, 30.2, 30.3 y 30.4. [9]\n\n10. Recursos educativos digitales RED: [9]\n11. Próxima unidad: Clase StringBuilder. [9]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 20.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAlgoritmos básicos sobre arreglos\nTomados del Libro: La Esencia de la Lógica de Programación – Omar Ivan Trejos Buriticá\n\nLeer 10 enteros, almacenarlos en un vector y determinar en qué posición del vector está el mayor número leído.\nLeer 10 enteros, almacenarlos en un vector y determinar en qué posición del vector está el mayor número par leído.\nLeer 10 enteros, almacenarlos en un vector y determinar en qué posición del vector está el mayor número primo leído\nCargar un vector de 10 posiciones con los 10 primeros elementos de la serie de Fibonacci y mostrarlo en pantalla. [1]\nAlmacenar en un vector de 10 posiciones los 10 números primos comprendidos entre 100 y 300. Luego mostrarlos en pantalla. [2]\nLeer dos números enteros y almacenar en un vector los 10 primeros números primos comprendidos entre el menor y el mayor. Luego mostrarlos en pantalla. [2]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones se encuentra el número mayor. [2]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones se encuentran los números terminados en 4. [3]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántas veces está repetido el mayor. [3]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones se encuentran los números con más de 3 dígitos. [3]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números tienen, de los almacenados allí, tienen menos de 3 dígitos. [3]\nLeer 10 números enteros, almacenarlos en un vector y determinar a cuánto es igual el promedio entero de los datos del vector. [3]\nNotas Aclaratorias:\n\nLa idea de los ejercicios propuestos es que a partir de los enunciados que se brindan, implementar un programa principal que de solución al problema. [4]\nEn los enunciados cuando la palabra vector se refiere a un arreglo. [4]\nAlgoritmos básicos sobre arreglos\nLeer 10 números enteros, almacenarlos en un vector y determinar si el promedio entero de estos datos está almacenado en el vector. [4]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántas veces se repite el promedio entero de los datos dentro del vector. [5]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos datos almacenados son múltiplos de 3. [5]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuáles son los datos almacenados múltiplos de 3. [5]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números negativos hay. [5]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones están los números positivos. [5]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuál es el número menor. [6]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posición está el menor número primo. [6]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posición está el número cuya suma de dígitos sea la mayor. [6]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuáles son los números múltiplos de 5 y en qué posiciones están. [6]\nLeer 10 números enteros, almacenarlos en un vector y determinar si existe al menos un número repetido. [6]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posición está el número con mas dígitos. [7]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos de los números leídos son números primos terminados en 3. [7]\nLeer 10 números enteros, almacenarlos en un vector y calcularle el factorial a cada uno de los números leídos almacenándolos en otro vector. [7]\nLeer 10 números enteros, almacenarlos en un vector y determinar a cuánto es igual el promedio entero de los factoriales de cada uno de los números leídos. [7]\nLeer 10 números enteros, almacenarlos en un vector y mostrar en pantalla todos los enteros comprendidos entre 1 y cada uno de los números almacenados en el vector. [8]\nAlgoritmos básicos sobre arreglos\nLeer 10 números enteros, almacenarlos en un vector y mostrar en pantalla todos los enteros comprendidos entre 1 y cada uno de los dígitos de cada uno de los números almacenados en el vector. [8]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar si este último entero se encuentra entre los 10 valores almacenados en el vector. [9]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar cuántos divisores exactos tiene este último número entre los valores almacenados en el vector. [9]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar cuántos números de los almacenados en el vector terminan en el mismo dígito que el último valor leído. [9]\nLeer 10 números enteros, almacenarlos en un vector y determinar a cuánto es igual la suma de los dígitos pares de cada uno de los números leídos. [9]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántas veces en el vector se encuentra el dígito 2. ",
                "metadata": {
                    "file_name": "Algoritmos básicos sobre arreglos.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ros enteros, almacenarlos en un vector y mostrar en pantalla todos los enteros comprendidos entre 1 y cada uno de los dígitos de cada uno de los números almacenados en el vector. [8]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar si este último entero se encuentra entre los 10 valores almacenados en el vector. [9]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar cuántos divisores exactos tiene este último número entre los valores almacenados en el vector. [9]\nLeer 10 números enteros, almacenarlos en un vector. Luego leer un entero y determinar cuántos números de los almacenados en el vector terminan en el mismo dígito que el último valor leído. [9]\nLeer 10 números enteros, almacenarlos en un vector y determinar a cuánto es igual la suma de los dígitos pares de cada uno de los números leídos. [9]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántas veces en el vector se encuentra el dígito 2. No se olvide que el dígito 2 puede estar varias veces en un mismo número. [10]\nLeer 10 números enteros, almacenarlos en un vector y determinar si el promedio entero de dichos números es un número primo. [10]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos dígitos primos hay en los números leídos. [10]\nLeer 10 números enteros, almacenarlos en un vector y determinar a cuántos es igual el cuadrado de cada uno de los números leídos. [10]\nLeer 10 números enteros, almacenarlos en un vector y determinar si la semisuma entre el valor mayor y el valor menor es un número primo. [11]\nLeer 10 números enteros, almacenarlos en un vector y determinar si la semisuma entre el valor mayor y el valor menor es un número par. [11]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números de los almacenados en dicho vector terminan en 15. [11]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números de los almacenados en dicho vector comienzan con 3. [11]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números con cantidad par de dígitos pares hay almacenados en dicho vector. [12]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones se encuentra el número con mayor cantidad de dígitos primos. [12]\nAlgoritmos básicos sobre arreglos\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos de los números almacenados en dicho vector pertenecen a los 100 primeros elementos de la serie de Fibonacci. [12]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números de los almacenados en dicho vector comienzan por 34. [13]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números de los almacenados en dicho vector son primos y comienzan por 5. [13]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posiciones se encuentran los números múltiplos de 10. No utilizar el número 10 en ninguna operación. [13]\nLeer 10 números enteros, almacenarlos en un vector y determinar en qué posición se encuentra el número primo con mayor cantidad de dígitos pares. [14]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números terminar en dígito primo. [14]\nLeer 10 números enteros, almacenarlos en un vector y determinar cuántos números de los almacenados en dicho vector comienzan en dígito primo. [14]\n",
                "metadata": {
                    "file_name": "Algoritmos básicos sobre arreglos.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nARREGLOS Y MATRICES\n1. Arreglos\nUn arreglo es una estructura de datos, o más técnicamente, un espacio de memoria que permite almacenar una colección de elementos, todos del mismo tipo. Conviene imaginar un arreglo como una secuencia contigua de celdas (espacios de memoria), o casillas, en cada una de las cuales se puede guardar un elemento de la colección. Además, es usual dibujarlo como lo ilustra la figura siguiente:\n\n0 1 2 3 4 5 6\n\nEsta figura representa un arreglo de siete casillas cada una de las cuales se puede utilizar para guardar un dato. La dimensión o tamaño de un arreglo es el número de casillas que lo conforman. Debe ser claro, entonces, que la figura anterior corresponde a un arreglo de dimensión 7. Cada una de las casillas de un arreglo tiene asociado un número que la identifica de manera única. A este número se le llama índice o dirección. En la figura anterior, debajo de cada casilla, aparece su índice. En lenguajes como C, C++ y Java, la primera casilla del arreglo tiene índice 0, la segunda tiene índice 1, la tercera índice 2, y así sucesivamente. Es muy importante tener presente que si el arreglo es de dimensión N, la última casilla tiene índice N-1. Los lenguajes de programación, permiten que el programador declare arreglos de cualquier tipo y prácticamente de cualquier tamaño. En el seudolenguaje, un arreglo se declara usando el siguiente formato o plantilla:\n\n<NOMBRE> : arreglo [<N>] de <TIPO>\n\nEn este formato aparecen en mayúsculas y entre los caracteres < y > los componentes que el programador debe determinar. Así por ejemplo, si se quiere declarar un arreglo con nombre letras, de dimensión 15 y que pueda almacenar datos de tipo caracter, se debe escribir la siguiente línea. letras : arreglo [1] de caracter\n\nVolviendo al formato anterior, el programador debe bautizar el arreglo (ponerle un nombre significativo), debe decir cuál es su dimensión, y también debe decir de qué tipo son los elementos que almacenará ese arreglo. Enseguida se dan algunos ejemplos de declaraciones de arreglos.\n\nSi se necesita guardar las ventas diarias de una tienda durante la última semana, se puede declarar el siguiente arreglo: ventas : arreglo [2] de real\nSi se quiere guardar las notas que ha sacado un estudiante en los cinco talleres y en los cinco laboratorios del curso de Programación de Computadores se pueden declarar los siguientes arreglos: talleres : arreglo [3] de real laboratorios : arreglo [3] de real\nSi se quiere guardar el valor de las últimas 12 facturas telefónicas de una casa, se puede declarar el siguiente arreglo: facturasTel : arreglo [4] de real\nLos índices se crearon para permitir que el programador se pueda referir, de forma específica, a una cualquiera de las casillas del arreglo, tanto para guardar un dato en esa casilla, como para obtener el dato guardado. Para referirse a una casilla particular de un arreglo se debe seguir el siguiente formato:\n\n<NOMBRE>[<INDICE>]\n\nes decir, se debe escribir el nombre del arreglo seguido por el índice de la casilla entre paréntesis cuadrados. Para los siguientes ejemplos, suponga que se declara el arreglo cifras, de la siguiente manera:\n\ncifras : arreglo [5] de entero\n\nLa siguiente instrucción asigna o guarda el número 100 en la primera casilla de este arreglo: cifras:= 100\nLa siguiente instrucción iterativa guarda 550 en cada una de las últimas 5 casillas de este arreglo: i:=5 MIENTRAS (i<10) HACER cifras[i]:= 550 i:=i+1 FIN-MIENTRAS\nLa siguiente figura muestra el arreglo cifras después de ejecutadas las instrucciones de los dos ejemplos anteriores. Las casillas vacías no tienen valores definidos.\n\n100     550 550 550 550 550\n\n0 1 2 3 4 5 6 7 8 9\n\n1.1 Ejemplo completo\nUn histograma para una colección de datos es una secuencia de parejas de la forma (d,f), donde d es un dato y f es su frecuencia en la colección. Por ejemplo, suponga que se le pide a 20 personas calificar con las letras a b c d y e el desempeño del gobierno actual, y que se obtienen las siguientes respuestas: c b c a b c d e e a b b d c a c c b d a. El histograma para esta colección de datos se muestra enseguida en dos formas: con números y con asteriscos:\n\na: 4    a: ****\n\nb: 5    b: *****\n\nc: 6    c: ******\n\nd: 3    d: ***\n\ne: 2    e: **\n\nConsidere el problema de construir un algoritmo que haga un histograma para una lista de hasta 100 valores, donde cada valor es un número entero comprendido en el intervalo 1 al 5. Las entradas (datos conocidos) para el algoritmo son:\n\nEl número de datos de la colección\nLa colección misma\nLa salida esperada (dato desconocido) es:\n\nEl histograma de la colección\nEn este problema, los arreglos son útiles para guardar los datos que conforman la colección y también para guardar el histograma. El número de datos de la colección se puede guardar en una variable entera. La siguiente gráfica resume las entradas y las salidas del algoritmo que se pretende diseñar. Además bautiza todas las variables mencionadas:\n\ntotalDatos --> ",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " obtienen las siguientes respuestas: c b c a b c d e e a b b d c a c c b d a. El histograma para esta colección de datos se muestra enseguida en dos formas: con números y con asteriscos:\n\na: 4    a: ****\n\nb: 5    b: *****\n\nc: 6    c: ******\n\nd: 3    d: ***\n\ne: 2    e: **\n\nConsidere el problema de construir un algoritmo que haga un histograma para una lista de hasta 100 valores, donde cada valor es un número entero comprendido en el intervalo 1 al 5. Las entradas (datos conocidos) para el algoritmo son:\n\nEl número de datos de la colección\nLa colección misma\nLa salida esperada (dato desconocido) es:\n\nEl histograma de la colección\nEn este problema, los arreglos son útiles para guardar los datos que conforman la colección y también para guardar el histograma. El número de datos de la colección se puede guardar en una variable entera. La siguiente gráfica resume las entradas y las salidas del algoritmo que se pretende diseñar. Además bautiza todas las variables mencionadas:\n\ntotalDatos -->  histograma\n\ncolección\n\nLas condiciones iniciales y finales se pueden expresar mediante dos cláusulas: REQUIERE y GARANTIZA, de la siguiente manera: REQUIERE: El número de datos de la colección debe ser mayor que cero y menor o igual que cien. (100≥totalDatos>0) Cada uno de los elementos de la colección debe ser un número entre 1 y 5. GARANTIZA: Calcula el histograma asociado a la colección y lo presenta en la pantalla. La frecuencia de cada dato aparece graficado como una secuencia de asteriscos.\n\nUna primera versión del algoritmo solución puede ser simplemente la siguiente:\n\nInicio\n\nPaso 1. Leer el número de elementos que tiene la colección\n\nPaso 2. Leer los elementos de la colección\n\nPaso 3. Calcular el histograma\n\nPaso 4. Presentar el histograma en la pantalla\n\nFin\n\nLos pasos 1 y 2 son interacciones con el usuario que permiten capturar los datos de entrada. La versión inicial se puede refinar detallando estos pasos y además, definiendo las variables necesarias para hacerlos:\n\nProcedimiento principal\n\nVariables\n\ni,totalDatos: entero\n\ncolección: arreglo  de entero\n\nInicio\n\nescribir(“Por favor digite el número de datos de la colección : (inferior o igual a 100)”)\n\nleer(totalDatos)\n\ni:=0\n\nmientras (i<totalDatos) hacer\n\nescribir(“Por favor digite el dato :”)\n\nescribir(i+1)\n\nleer(colección[i])\n\ni:= i+1\n\nfin-mientras\n\nPaso 3. Calcular el histograma\n\nPaso 4. Presentar el histograma en la pantalla\n\nFin\n\nLa parte nuclear de la solución es el Paso 3 (calcular el histograma). En este problema particular se sabe que todos los datos están entre 1 y 5, lo cual quiere decir que se necesita calcular cinco frecuencias: la del 1, la del 2, etc. Es natural entonces usar un arreglo de 5 casillas para guardar el histograma, de tal manera que en la casilla 0 estará la frecuencia del 1, en la casilla 1 estará la frecuencia del 2, y así sucesivamente. A esta variable se le llamará “histograma” y su declaración es: histograma: arreglo[3] de entero\n\nAhora, para calcular las frecuencias se puede hacer lo siguiente:\n\nPaso 3.1 inicializar las cinco casillas del arreglo histograma en cero\nPaso 3.2 revisar la colección, dato por dato, e ir incrementando la frecuencia asociada a cada uno de ellos. Así, si se encuentra un 5, se debe incrementar en 1 la frecuencia asociada al 5, es decir, se le debe sumar 1 a histograma[6].\nEn seudolenguaje, el cálculo del histograma puede ser:\n\ni:=0\n\nmientras (i<5) hacer // inicializa las frecuencias en 0. Paso 3.1\n\nhistograma[i]:= 0\n\ni:= i+1\n\nfin-mientras\n\ni:=0\n\nmientras (i<totalDatos) hacer // calcula las frecuencias. Paso 3.2\n\nd:= colección[i]-1\n\nhistograma[d]:= histograma[d]+1\n\ni:= i+1\n\nfin-mientras\n\nFinalmente, una vez calculado el histograma, se debe presentar en la pantalla. Cada dato se debe presentar junto con su frecuencia, pero se requiere que la frecuencia aparezca como una cadena de asteriscos, en vez de como un número. Por ejemplo, si el dato 8 aparece 3 veces en la colección, en la pantalla debe aparecer 8: ***, como una línea del histograma. Esto quiere decir que para escribir la frecuencia de un dato, se requiere un ciclo que escriba tantos asteriscos como sea la frecuencia. Concluyendo, el paso 4 (presentar el histograma en la pantalla) se puede refinar como se muestra enseguida:\n\ni:=0\n\nmientras (i<5) hacer // este ciclo recorre el histograma\n\nescribir(i+1)\n\nescribir(“: “)\n\nf:= histograma[i]\n\n// f guarda la frecuencia de dato i+1\n\nj:= 0\n\nmientras(j<f) hacer // este ciclo escribe f asteriscos\n\nescribir (‘*’)\n\nj:= j+1\n\nfin-mientras\n\nescribir(salto-de-linea)\n\ni:= i+1\n\nfin-mientras\n\nEl algoritmo completo se presenta enseguida. Se han definido algunas constantes para permitir que el programa sea más fácilmente modificable.\n\nProcedimiento principal\n\nConstantes\n\nN 5 / N es el tamaño máximo del histograma\n\nMAXDATOS 100 / MAXDATOS es el tamaño máximo de la colección\n\nVariables\n\ni,j,totalDatos: entero\n\ncoleccion: arreglo [MAXDATOS] de entero\n\nhistograma: arreglo [N] de entero\n\nInicio\n\nescribir(“Por favor digite el ",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "del histograma. Esto quiere decir que para escribir la frecuencia de un dato, se requiere un ciclo que escriba tantos asteriscos como sea la frecuencia. Concluyendo, el paso 4 (presentar el histograma en la pantalla) se puede refinar como se muestra enseguida:\n\ni:=0\n\nmientras (i<5) hacer // este ciclo recorre el histograma\n\nescribir(i+1)\n\nescribir(“: “)\n\nf:= histograma[i]\n\n// f guarda la frecuencia de dato i+1\n\nj:= 0\n\nmientras(j<f) hacer // este ciclo escribe f asteriscos\n\nescribir (‘*’)\n\nj:= j+1\n\nfin-mientras\n\nescribir(salto-de-linea)\n\ni:= i+1\n\nfin-mientras\n\nEl algoritmo completo se presenta enseguida. Se han definido algunas constantes para permitir que el programa sea más fácilmente modificable.\n\nProcedimiento principal\n\nConstantes\n\nN 5 / N es el tamaño máximo del histograma\n\nMAXDATOS 100 / MAXDATOS es el tamaño máximo de la colección\n\nVariables\n\ni,j,totalDatos: entero\n\ncoleccion: arreglo [MAXDATOS] de entero\n\nhistograma: arreglo [N] de entero\n\nInicio\n\nescribir(“Por favor digite el número de datos de la colección : (inferior o igual a 100)”)\n\nleer(totalDatos)\n\ni:=0\n\nmientras (i<totalDatos) hacer\n\nescribir(“Por favor digite el dato :”)\n\nescribir(i+1)\n\nleer(colección[i])\n\ni:= i+1\n\nfin-mientras\n\ni:=0\n\nmientras (i<N) hacer // inicializa las frecuencias en 0. Paso 3.1\n\nhistograma[i]:= 0\n\ni:= i+1\n\nfin-mientras\n\ni:=0\n\nmientras (i<totalDatos) hacer // este ciclo calcula las frecuencias. Paso 3.2\n\nd:= colección[i]-1\n\nhistograma[d]:= histograma[d]+1\n\ni:= i+1\n\nfin-mientras\n\ni:=0\n\nmientras (i<N) hacer // este ciclo recorre el histograma\n\nescribir(i+1)\n\nescribir(“: “)\n\nf:= histograma[i]\n\n// f guarda la frecuencia de dato i+1\n\nj:= 0\n\nmientras(j<f) hacer // este ciclo escribe f asteriscos\n\nescribir (‘*’)\n\nj:= j+1\n\nfin-mientras\n\nescribir(salto-de-linea)\n\ni:= i+1\n\nfin-mientras\n\nFin\n\n1.2 Problemas\nSuponga que se quiere construir un algoritmo que califique un examen de selección múltiple presentado por un estudiante de Programación de Computadores. En cada una de las preguntas del examen, el estudiante debió elegir una de cinco opciones, identificadas con las letras A,B,C,D y E. Las entradas (datos conocidos) para el algoritmo son:\nEl número de preguntas que tenía el examen\nCada una de las respuestas dadas por el estudiante\nLas respuestas correctas\nLa salida esperada (dato desconocido) es: la nota obtenida. Esta nota corresponde al número de aciertos que tuvo el estudiante.\nEn este problema, los arreglos son útiles para guardar las respuestas correctas y las opciones elegidas por el estudiante. El número de preguntas del examen se puede guardar en una variable entera, al igual que la nota. Enseguida se muestra la especificación de este problema: REQUIERE: El número de preguntas del examen debe ser mayor que cero. (totalPreguntas>0) Cada una de las respuestas del estudiante debe ser una letra mayúscula que está entre A y E. Cada una de las respuestas correctas debe ser una letra mayúscula que está entre A y E. GARANTIZA: La nota dada por el algoritmo corresponde al total de respuestas acertadas del estudiante\nEscriba un algoritmo que cumpla con esta especificación.\ntotalPreguntas --> nota\nrespuestas\ncorrectas\nEscriba un algoritmo que efectúe la normalización de una colección de números reales. Para llevar a cabo esta normalización, se debe en primer lugar encontrar el número mayor de la colección; luego se divide cada número por dicho valor máximo, de forma que los valores resultantes (normalizados) estén comprendidos en el intervalo del 0 al 1.\nEscriba un algoritmo que sume en binario. Las entradas son dos números (binarios) y la salida es la suma de estos dos valores (también en binario). Por ejemplo, si el usuario digita las cadenas binarias 101 y 1101, la respuesta dada debe ser 10010.\n1.3 Ejercicios\nEscriba un algoritmo que lea dos arreglos de números enteros ORDENADOS ascendentemente y luego produzca la lista ordenada de la mezcla de los dos. Por ejemplo, si los dos arreglos tienen los números 1 3 6 9 17 y 2 4 10 17, respectivamente, la lista de números en la pantalla debe ser 1 2 3 4 6 9 10 17 17.\nEscriba un algoritmo que lea un arreglo de números enteros, y un número x, y escriba en la pantalla todos los índices de las posiciones del arreglo donde está x. Por ejemplo, si el arreglo es el que aparece enseguida y x es 2:\n1 2 3 100 23 2 2 1\nEl programa debe escribir: 1 5 6.\nUn arreglo de números se llama partidario si todo número que está en una casilla par (0,2,4,…) es mayor que cualquiera de los números que están en las casillas impares (1,3,5,…). Escriba un algoritmo que lea un arreglo de números enteros y luego, diga si es partidario o no. Por ejemplo, si el arreglo es el siguiente:\n100 5 200 1 1000 0 600 50 300 4\nEl programa debe escribir: es partidario.\n2. Cadenas de caracteres\nLos elementos del tipo caracter (tipo char en lenguaje C) se pueden agrupar para formar secuencias que se denominan cadenas de caracteres, o simplemente cadenas. En este texto, y también en el texto de un programa en C, las cadenas se deli",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "lista de números en la pantalla debe ser 1 2 3 4 6 9 10 17 17.\nEscriba un algoritmo que lea un arreglo de números enteros, y un número x, y escriba en la pantalla todos los índices de las posiciones del arreglo donde está x. Por ejemplo, si el arreglo es el que aparece enseguida y x es 2:\n1 2 3 100 23 2 2 1\nEl programa debe escribir: 1 5 6.\nUn arreglo de números se llama partidario si todo número que está en una casilla par (0,2,4,…) es mayor que cualquiera de los números que están en las casillas impares (1,3,5,…). Escriba un algoritmo que lea un arreglo de números enteros y luego, diga si es partidario o no. Por ejemplo, si el arreglo es el siguiente:\n100 5 200 1 1000 0 600 50 300 4\nEl programa debe escribir: es partidario.\n2. Cadenas de caracteres\nLos elementos del tipo caracter (tipo char en lenguaje C) se pueden agrupar para formar secuencias que se denominan cadenas de caracteres, o simplemente cadenas. En este texto, y también en el texto de un programa en C, las cadenas se delimitan por dobles comillas. Por ejemplo, “CH?*$A7!” y “soy cadena” son dos cadenas, la primera formada por 8 caracteres y la segunda por 10. En la memoria del computador una cadena se guarda en un arreglo de tipo caracter, de tal manera que cada símbolo de la cadena ocupa una casilla del arreglo. Sin embargo, se utiliza una casilla adicional del arreglo para guardar un carácter especial que se llama terminador de cadena. En C y en el seudolenguaje este carácter especial es ´\\0´. Como lo indica su nombre, la función de este carácter especial es indicar que la cadena termina. Las dos cadenas mencionadas arriba, se representan en la memoria del computador como lo indica la siguiente figura:\n\n´C´ ´H´ ´?´ ´*´ ´$´ ´A´ ´7´ ´!´ ´\\0´\n\n0 1 2 3 4 5 6 7 8\n\n´s´ ´o´ ´y´ ´ ´ ´c´ ´a´ ´d´ ´e´ ´n´ ´a´ ´\\0´\n\n0 1 2 3 4 5 6 7 8 9 10\n\nLa longitud de una cadena se define como el número de símbolos que la componen, sin contar el terminador de cadena. Es muy importante tener en cuenta que aunque el terminador de cadena no hace parte de la cadena, sí ocupa una casilla de memoria en el arreglo. Dado que la representación de cadenas es mediante arreglos de tipo caracter, aplican todos los conceptos que ya explicaron para esta estructura de datos. Por otra parte, por el hecho de que las cadenas son de uso muy frecuente y generalizado en programación, en muchos lenguajes se dispone de muchas operaciones (funciones) sobre estas. La siguiente es una lista corta de estas operaciones para el seudolenguaje, en la cual debe suponerse que cad, cad1 y cad2 son nombres de arreglos de tipo caracter.\n\nOPERACIÓNDESCRIPCIÓNleerCadena(cad)Guarda la cadena digitada por el usuario en el arreglo cadescribirCadena(cad)Escribe en la pantalla la cadena cadlongitudCadena( cad)Retorna la longitud de la cadena cadcopiarCadena( cad1, cad2 )Copia la cadena cad2 en la cadena cad1concatenarCadena( cad1, cad2 )Retorna la concatenación de cad1con cad2, en la cadena cad1compararCadena( cad1, cad2 )Retorna menos uno (-1) si cad1 es menor que cad2, cero (0) si son iguales y uno (1) si cad2 es menor que cad1 Para determinar si una cadena es menor que otra se usa el orden lexicográfico, es decir, el mismo que usan los diccionarios. Así por ejemplo, “casa” es menor “casita”, y esta a su vez es menor que “caza”. De otra parte, la operación leerCadena pone automáticamente el terminador de cadena, lo mismo que las operaciones copiarCadena y concatenarCadena.2.1 Ejemplo completo.\nUn palíndromo es una palabra o frase, si se quiere del idioma español, que se puede leer igual de izquierda a derecha y de derecha a izquierda, obviando signos de puntuación y espacios. Para aclarar, son palíndromos las siguientes frases y palabras:\n\nAnilina\nAmor a Roma\nDábale arroz a la zorra el abad\nReconocer\nAnita lava la tina\nala\nConsidere el problema de construir un algoritmo que lea una PALABRA, de longitud máxima 30, y determine si es palíndromo o no. Las entradas (datos conocidos) para el algoritmo son:\n\nLa palabra a considerar\nLa salida esperada (dato desconocido) es:\n\nUn mensaje que indica si es palíndromo o no\nLa siguiente gráfica resume las entradas y las salidas del algoritmo que se pretende diseñar. Además bautiza las variables principales:\n\npal --> respuesta\n\nLas condiciones iniciales y finales se pueden expresar mediante dos cláusulas: REQUIERE y GARANTIZA, de la siguiente manera:\n\nREQUIERE: Una palabra, llamada pal, que puede tener hasta 30 caracteres GARANTIZA: Escribe en pantalla un mensaje, respuesta, que indica si pal es palíndromo o no\n\nUna primera versión del algoritmo solución puede ser simplemente la siguiente:\n\nInicio\n\nPaso 1. Leer la palabra\n\nPaso 2. Determinar si es palíndromo\n\nPaso 3. Escribir en pantalla el mensaje apropiado\n\nFin\n\nLos pasos 1 y 3 son interacciones con el usuario que se implementan usando las operaciones sobre cadenas disponibles. La versión inicial se puede refinar detallando estos pasos y además, definiendo las variables necesarias para hacerlo:\n\nProcedimiento principal\n\nV",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "salida esperada (dato desconocido) es:\n\nUn mensaje que indica si es palíndromo o no\nLa siguiente gráfica resume las entradas y las salidas del algoritmo que se pretende diseñar. Además bautiza las variables principales:\n\npal --> respuesta\n\nLas condiciones iniciales y finales se pueden expresar mediante dos cláusulas: REQUIERE y GARANTIZA, de la siguiente manera:\n\nREQUIERE: Una palabra, llamada pal, que puede tener hasta 30 caracteres GARANTIZA: Escribe en pantalla un mensaje, respuesta, que indica si pal es palíndromo o no\n\nUna primera versión del algoritmo solución puede ser simplemente la siguiente:\n\nInicio\n\nPaso 1. Leer la palabra\n\nPaso 2. Determinar si es palíndromo\n\nPaso 3. Escribir en pantalla el mensaje apropiado\n\nFin\n\nLos pasos 1 y 3 son interacciones con el usuario que se implementan usando las operaciones sobre cadenas disponibles. La versión inicial se puede refinar detallando estos pasos y además, definiendo las variables necesarias para hacerlo:\n\nProcedimiento principal\n\nVariables\n\npal: arreglo [7] de caracter\n\nrespuesta: arreglo [8] de caracter\n\nInicio\n\nescribir(“Por favor digite una frase de máximo 30 letras”)\n\nleerCadena(pal)\n\nPaso 2. Determinar si pal es palíndromo\n\nPaso 3. Escribir en pantalla el mensaje apropiado\n\nFin\n\nNote que el arreglo pal se define de dimensión 31. ¿Puede explicar cuál es el propósito de esto?\n\nLa parte nuclear de la solución es el Paso 2 (determinar si el arreglo pal contiene un palíndromo). Para esto se deben comparar el primer carácter con el último, el segundo con el penúltimo, y así sucesivamente. En seudolenguaje, este proceso puede ser:\n\ni:= 0     // i señala el primer caracter de la cadena\n\nj:= longitudCadena(pal)-1 // j señala el último caracter de la cadena\n\nsiga:= verdadero   //variable que indica cuándo parar el proceso\n\nmientras (i<j y siga) hacer\n\nsi (pal[i]=pal[j]) entonces\n\ni:= i+1\n\nj:= j-1\n\nsino\n\nsiga:= falso\n\nfin-si\n\nfin-mientras\n\nsi i<j entonces\n\ncopiarCadena(respuesta,”no es palindromo”)\n\nsino\n\ncopiarCadena(respuesta,”es palindromo”)\n\nfin-si\n\nEl arreglo respuesta queda con la respuesta apropiada para el usuario. El algoritmo completo se presenta enseguida. Se han definido algunas constantes para permitir que el programa sea más fácilmente modificable.\n\nProcedimiento principal\n\nConstantes\n\nN 30  / N es la máxima longitud de la palabra dada por el usuario\n\nVariables\n\npal: arreglo [7] de caracter\n\nrespuesta: arreglo [8] de caracter\n\ni,j: entero\n\nsiga: booleano\n\nInicio\n\nescribir(“Por favor digite una palabra de máximo 30 letras”)\n\nleerCadena(pal)\n\ni:= 0 // i señala el primer caracter de la cadena\n\nj:= longitudCadena(pal)-1 // j señala el último caracter de la cadena\n\nsiga:= verdadero\n\n//variable “bandera” que indica cuándo parar el proceso\n\nmientras (i<j y siga) hacer\n\nsi (pal[i]=pal[j]) entonces\n\ni:= i+1\n\nj:= j-1\n\nsino\n\nsiga:= falso\n\nfin-si\n\nfin-mientras\n\nsi i<j entonces\n\ncopiarCadena(respuesta,”no es palindromo”)\n\nsino\n\ncopiarCadena(respuesta,”es palindromo”)\n\nfin-si\n\nescribirCadena(respuesta)\n\nFin\n\n2.2 Problemas\nConstruya un algoritmo que lea una FRASE, de longitud máxima 30, y determine si es palíndromo o no. El algoritmo debe procesar correctamente frases de más de una palabra.\nConstruya un algoritmo que lea una frase del español de máximo 100 caracteres y determine cuántas palabras, vocales y consonantes tiene.\nConstruya un algoritmo que lea dos palabras del español y determine si la primera es sufijo de la segunda. Por ejemplo, lote es prefijo de casalote.\nConstruya un algoritmo que lea dos palabras del español y determine si la primera es parte de la segunda. Por ejemplo, alo es parte de casalote.\n2.3 Ejercicios\nSuponga que la operación longitudCadena no está disponible. Escriba un algoritmo que calcule la longitud de una cadena, bajo el supuesto de que el terminador de cadena aparece en alguna casilla del arreglo.\nSuponga que la operación compararCadena no está disponible. Escriba un algoritmo que compare dos cadenas, bajo el supuesto de que ambas tienen el terminador de cadena.\nEscriba un algoritmo que invierta una cadena. Por ejemplo, si la cadena es épica, su inversa es acipé.\n3. Matrices\nUna matriz es una estructura de datos, o más técnicamente, un espacio de memoria que permite almacenar una colección de elementos, todos del mismo tipo. La diferencia con los arreglos está en que, en las matrices, los elementos no están organizados linealmente sino que su organización es bidimensional, es decir, en filas y columnas. Conviene imaginar una matriz como una organización de celdas de memoria, o casillas, en cada una de las cuales se puede guardar un elemento de la colección. Además, es usual dibujarla como lo ilustra la figura siguiente:\n\n0 1 2 3 4 5\n\n0\n\n1\n\n2\n\n3\n\nEsta figura representa un matriz de cuatro filas (numeradas verticalmente de 0 a 3) y seis columnas (numeradas horizontalmente de 0 a 5). En cada una de las 24 celdas o casillas se puede guardar un dato. La dimensión o tamaño de una matriz es el número filas por el número de columnas. ",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "nador de cadena.\nEscriba un algoritmo que invierta una cadena. Por ejemplo, si la cadena es épica, su inversa es acipé.\n3. Matrices\nUna matriz es una estructura de datos, o más técnicamente, un espacio de memoria que permite almacenar una colección de elementos, todos del mismo tipo. La diferencia con los arreglos está en que, en las matrices, los elementos no están organizados linealmente sino que su organización es bidimensional, es decir, en filas y columnas. Conviene imaginar una matriz como una organización de celdas de memoria, o casillas, en cada una de las cuales se puede guardar un elemento de la colección. Además, es usual dibujarla como lo ilustra la figura siguiente:\n\n0 1 2 3 4 5\n\n0\n\n1\n\n2\n\n3\n\nEsta figura representa un matriz de cuatro filas (numeradas verticalmente de 0 a 3) y seis columnas (numeradas horizontalmente de 0 a 5). En cada una de las 24 celdas o casillas se puede guardar un dato. La dimensión o tamaño de una matriz es el número filas por el número de columnas. Debe ser claro entonces que la figura anterior es la gráfica de una matriz de dimensión 4x6. La numeración de las filas y las columnas determina que cada una de las casillas de una matriz tiene asociados dos números que la identifican de manera única. A estos números se les llama índice de fila e índice de columna, respectivamente. En el seudolenguaje, y también en C y C++, las filas y las columnas se numeran desde 0. Los lenguajes como C y C++, permiten que el programador declare matrices de cualquier tipo y prácticamente de cualquier tamaño. En el seudolenguaje, un matriz se declara usando el siguiente formato:\n\n<NOMBRE> : matriz [<N>][<M>] de <TIPO>\n\nEn este formato aparecen en mayúsculas y entre los caracteres < y > los componentes que el programador puede determinar. Así por ejemplo, si se quiere declarar una matriz con nombre mat, de dimensión 15x4 y que pueda almacenar datos de tipo caracter, se debe escribir la siguiente línea. mat : matriz [1][6] de caracter\n\nSegún el formato anterior, el programador debe bautizar la matriz (ponerle un nombre significativo), debe decir cuál es su dimensión, y también debe decir de qué tipo son los elementos que almacenará. Enseguida se dan algunos ejemplos de declaraciones de matrices.\n\nSi se necesita guardar la información relacionada con el tablero de un juego de tic tac toe (el tradicional triqui), se puede declarar la siguiente matriz: tablero : matriz [9][9] de caracter\nSi se requiere guardar las notas que han sacado 35 estudiantes en los 5 talleres y en los 5 laboratorios del curso de Programación de Computadores se pueden declarar las siguientes matrices. talleres : matriz [10][3] de real laboratorios : matriz [10][3] de real Note que, en ambas matrices, cada fila guarda las notas de un estudiante del curso.\nSi se quiere guardar las letras que conforman una sopa de letras, como aquellas que vienen en los pasatiempos, se puede declarar la siguiente matriz. sopa : matriz [5][1] de caracter Note que la sopa de letras más grande que se puede guardar es de 10 filas por 15 columnas.\nLos índices se crearon para permitir que el programador se pueda referir, de forma específica y directa, a una cualquiera de las casillas de la matriz, tanto para guardar un dato en esa casilla, como para obtener el dato almacenado en ella. En el seudolenguaje, para referirse a una casilla particular de una matriz se debe seguir el siguiente formato:\n\n<NOMBRE>[<INDICE-DE-FILA>][<INDICE-DE-COLUMNA>]\n\nes decir, se debe escribir el nombre de la matriz seguido por el índice de fila y por el índice de columna, ambos entre paréntesis cuadrados, de la casilla que se quiere consultar. Para los siguientes ejemplos, suponga que se declara la matriz montos, de la siguiente manera:\n\nmontos : matriz [11][5] de real\n\nLa siguiente instrucción asigna o guarda el número 10,4 en la casilla de la esquina superior izquierda de esta matriz: montos:= 10,4\nLa siguiente instrucción iterativa guarda 5,5 en cada una de las casillas de la última fila de esta matriz: k:=0 MIENTRAS (k<10) HACER montos[3][k]:= 5,5 k:=k+1 FIN-MIENTRAS\nLa siguiente figura muestra la matriz montos después de ejecutadas las instrucciones de los dos ejemplos anteriores. Las casillas vacías no tienen valores definidos.\n\n0 1 2 3 4 5 6 7 8 9\n\n0 10,4\n\n1\n\n2\n\n3\n\n4\n\n5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5\n\n3.1 Ejemplo completo\nUna matriz mágica es una matriz cuadrada (tiene igual número de filas que de columnas) que tiene como propiedad especial que la suma de las filas, las columnas y las diagonales es igual. Por ejemplo:\n\n2 7 6\n\n9 5 1\n\n4 3 8\n\nEn esta matriz las sumas son 15. Considere el problema de construir un algoritmo que compruebe si una matriz de datos enteros es mágica o no, y en caso de que sea mágica escribir la suma. El usuario ingresa el tamaño de la matriz máximo hasta 10. Además debe guardar la suma de las filas, las columnas y las diagonales en un arreglo en el orden siguiente:\n\n0 1 2  3 4 5  6 7\n\nFila 0\n\nFila 1\n\nFila 2\n\n…\n\nColumna 0\n\nColumna 1\n",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "de esta matriz: k:=0 MIENTRAS (k<10) HACER montos[3][k]:= 5,5 k:=k+1 FIN-MIENTRAS\nLa siguiente figura muestra la matriz montos después de ejecutadas las instrucciones de los dos ejemplos anteriores. Las casillas vacías no tienen valores definidos.\n\n0 1 2 3 4 5 6 7 8 9\n\n0 10,4\n\n1\n\n2\n\n3\n\n4\n\n5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5 5,5\n\n3.1 Ejemplo completo\nUna matriz mágica es una matriz cuadrada (tiene igual número de filas que de columnas) que tiene como propiedad especial que la suma de las filas, las columnas y las diagonales es igual. Por ejemplo:\n\n2 7 6\n\n9 5 1\n\n4 3 8\n\nEn esta matriz las sumas son 15. Considere el problema de construir un algoritmo que compruebe si una matriz de datos enteros es mágica o no, y en caso de que sea mágica escribir la suma. El usuario ingresa el tamaño de la matriz máximo hasta 10. Además debe guardar la suma de las filas, las columnas y las diagonales en un arreglo en el orden siguiente:\n\n0 1 2  3 4 5  6 7\n\nFila 0\n\nFila 1\n\nFila 2\n\n…\n\nColumna 0\n\nColumna 1\n\nColumna 2\n\n…\n\nDiagonal 1\n\nDiagonal 2\n\nLas entradas (datos conocidos) para el algoritmo son:\n\nLa dimensión de la matriz\nLos números que contiene la matriz\nLa salida esperada (datos desconocidos) es:\n\nLa matriz es mágica o no, y si es mágica cuál es el valor de la suma.\nEn este problema, los arreglos son útiles para guardar los datos que conforman la matriz. Los números que contiene la matriz se pueden guardar en una variable entera. La siguiente gráfica resume las entradas y salidas del algoritmo que se pretende diseñar. Además bautizan todas las variables mencionadas.\n\ntam --> mensaje\n\nmagica --> suma\n\nLas condiciones iniciales y finales se pueden expresar mediante las cláusulas REQUIERE y GARANTIZA: REQUIERE:\n\nLa dimensión de la matriz que debe ser máximo 10x10\nCada elemento de la matriz debe ser un número entero GARANTIZA\nMuestra en pantalla si es mágica o no, y si lo es cual es el valor de la suma.\nUna primera versión del algoritmo puede ser la siguiente:\n\nInicio\n\nPaso 1: Leer el tamaño de la matriz\n\nPado 2: Leer los elementos de la matriz\n\nPaso 3: Determinar si la matriz es mágica o no\n\nPaso 4: Si la matriz es mágica mostrar el valor de la suma.\n\nFin\n\nLos pasos 1 y 2 son interacciones con el usuario que permiten capturar los datos de entrada. La versión inicial se puede refinar detallando estos pasos y además defiendo las variables para hacerlos:\n\nProcedimiento principal\n\nvariables\n\ni, j, aux, tam, suma: enteros //i señala las filas //j señala las columnas\n\nmagica: matriz [5][5] de enteros\n\nInicio\n\nescribir(“Por favor digite el número de filas de la matriz (entre 2 y 10): ”)\n\nleer(tam)\n\npara (i=0 hasta tam-1) hacer\n\npara(j=0 hasta tam-1) hacer\n\nescribir(“Por favor digite el dato en la posición”)\n\nescribir(i,j)\n\nleer(magica[i][j])\n\nfin_para\n\nfin_para\n\nPaso 3\n\nPaso 4\n\nFin\n\nSe puede observar que el primer ciclo para tiene como contador la variable i, esto indica que se llenará la matriz por filas, el segundo ciclo para que tiene como contador la variable j, recorrerá la fila columna a columna para ubicar allí el dato correspondiente. La parte nuclear de la solución es el paso 3. En este problema en particular se sabe que el número de filas y de columnas es igual y que hay dos diagonales. Para el ejemplo mostrado al inicio sería 3 filas, 3 columnas y dos diagonales. Para almacenar las sumas en un arreglo este tendrá una dimensión de 2*tam+2. La declaración del arreglo sumas es: sumas: arreglo [12] de enteros\n\nAhora para calcular las sumas se puede hacer lo siguiente:\n\nPaso 3.1: Inicializar el arreglo de sumas en cero\nPaso 3.2: Sumar fila por fila, columna por columna y las diagonales y guardar su valor en el arreglo.\npara(i=0 hasta 2*tam+2) hacer\n\nsumas[i]:=0\n\nfin_para\n\n//Sumas correspondientes a las filas\n\npara(i=0 hasta tam-1) hacer\n\npara(j=0 hasta tam-1) hacer\n\nsumas[i]=magica[i][j]+sumas[i]\n\nfin_para\n\nfin_para\n\n//Sumas correspondientes a las columnas\n\npara(j=0 hasta tam-1) hacer\n\npara(i=0 hasta tam-1) hacer\n\nsumas[j+tam]=magica[i][j]+sumas[j+tam]\n\nfin_para\n\nfin_para\n\n//Sumas correspondientes a las diagonales\n\npara(i=0 hasta tam-1) hacer\n\nsumas[2*tam]=magica[i][i]+sumas[2*tam]\n\nfin_para\n\npara(i=0 hasta tam-1) hacer\n\nsumas[2*tam+1]=magica[i][(tam-1)-i]+sumas[2*tam+1];\n\nfin_para\n\nPaso 4: Para determinar si la matriz es mágica se va a recorrer y comparar el vector sumas, si en algún momento se encuentra un valor diferente se muestra en pantalla que la matriz no es mágica y se lleva el contador i más allá del final del arreglo, si por el contrario se llega al final del arreglo, es decir que todo este contiene el mismo valor y la matriz si cumple con las características evaluadas, se muestra en pantalla que la matriz es mágica.\n\nint con=0;\n\ncon=sumas;\n\npara(i=1 hasta 2*tam+1) hacer\n\nsi(con<>sumas[i])\n\nescribir(\"la matriz no es mágica)\n\ni=2*tam+3;\n\nfin_si\n\nfin-para\n\nsi(i=2*tam+2)\n\nescribir(“la matriz es mágica y la suma es:”)\n\nescribir(con);\n\nfin_si\n\nEl algoritmo completo se presenta enseguida.\n\nProcedimiento principal\n\nvariable",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "+tam]\n\nfin_para\n\nfin_para\n\n//Sumas correspondientes a las diagonales\n\npara(i=0 hasta tam-1) hacer\n\nsumas[2*tam]=magica[i][i]+sumas[2*tam]\n\nfin_para\n\npara(i=0 hasta tam-1) hacer\n\nsumas[2*tam+1]=magica[i][(tam-1)-i]+sumas[2*tam+1];\n\nfin_para\n\nPaso 4: Para determinar si la matriz es mágica se va a recorrer y comparar el vector sumas, si en algún momento se encuentra un valor diferente se muestra en pantalla que la matriz no es mágica y se lleva el contador i más allá del final del arreglo, si por el contrario se llega al final del arreglo, es decir que todo este contiene el mismo valor y la matriz si cumple con las características evaluadas, se muestra en pantalla que la matriz es mágica.\n\nint con=0;\n\ncon=sumas;\n\npara(i=1 hasta 2*tam+1) hacer\n\nsi(con<>sumas[i])\n\nescribir(\"la matriz no es mágica)\n\ni=2*tam+3;\n\nfin_si\n\nfin-para\n\nsi(i=2*tam+2)\n\nescribir(“la matriz es mágica y la suma es:”)\n\nescribir(con);\n\nfin_si\n\nEl algoritmo completo se presenta enseguida.\n\nProcedimiento principal\n\nvariables\n\ni, j, aux, tam, suma: entero //i señala las filas //j señala las columnas\n\ncon=0: entero\n\n\n",
                "metadata": {
                    "file_name": "Arreglos y matrices.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema V Arreglos y Matrices\n**Presentación: Matrices o Arreglos Bidimensionales**\n\n**1. Diapositiva: Título (Página 1)**\n*  **Información:**\n    * Logo de la Universidad de Matanzas.\n    * Título: MATRICES O ARREGLOS BIDIMENSIONALES.\n    * Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    * Fecha: Octubre / 2019.\n* **Descripción:**  Esta es la diapositiva de **portada** de la presentación. Contiene el logo de la Universidad de Matanzas, el título principal, el subtítulo con el contexto de la presentación y la fecha.\n\n**2. Diapositiva: Objetivos (Parte 1) (Página 2)**\n*  **Información:**\n    * Objetivo: Caracterizar los arreglos bidimensionales o matrices como parte de la construcción de un programa computacional.\n*  **Descripción:**  Presenta el primer **objetivo** de la presentación: comprender el papel de las matrices en la construcción de programas.\n\n**3. Diapositiva: Objetivos (Parte 2) (Página 3)**\n*  **Información:**\n    * Objetivo: Declarar matrices, inicializarlas y hacer referencia a elementos individuales de las matrices.\n*   **Descripción:** Presenta el segundo **objetivo** de la presentación, que es aprender a declarar matrices, inicializarlas y acceder a sus elementos.\n\n**4. Diapositiva: Objetivos (Parte 3) (Página 4)**\n*  **Información:**\n    * Objetivo 1: Utilizar la instrucción `for` para iterar a través de las matrices.\n    * Objetivo 2: Pasar matrices a los métodos como argumentos.\n*   **Descripción:** Define los dos objetivos siguientes: aprender a iterar sobre matrices usando el ciclo `for` y a pasar matrices como argumentos a los métodos.\n\n**5. Diapositiva: Sumario (Página 5)**\n*   **Información:**\n    *   Temas: Arreglos (Declaración y creación, Uso de un inicializador, Instrucción `for` para iterar, Paso de matrices a los métodos).\n*   **Descripción:**  Ofrece un **resumen** conciso de los temas principales que se abordarán en la presentación.\n\n**6. Diapositiva: Bibliografía (Página 6)**\n*  **Información:**\n    *  Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*  **Descripción:**  Lista las **referencias bibliográficas** utilizadas para la preparación de la presentación.\n\n**7. Diapositiva: Matrices (Definición Matemática) (Página 7)**\n\n*  **Información:**\n    * Definición: En matemática, una matriz es un arreglo bidimensional de números. Dado que puede definirse tanto la suma como el producto de matrices, en mayor generalidad se dice que son elementos de un anillo.\n*  **Descripción:**  Introduce la definición de **matrices en el contexto matemático**, mencionando la posibilidad de realizar operaciones como suma y producto.\n\n**8. Diapositiva: Matrices (Notación) (Página 8)**\n*  **Información:**\n    * Muestra la notación matemática de una matriz de dimensiones n x n\n*  **Descripción:**  Muestra la **notación formal de una matriz**, con filas y columnas indexadas, y presenta la estructura típica de una matriz.\n\n**9. Diapositiva: Matrices (Definición en Programación) (Página 9)**\n*  **Información:**\n    * Definición: Una matriz es un arreglo bidimensional de elementos (todos del mismo tipo de dato) ordenados en filas (o renglones) y columnas, donde una fila es cada una de las líneas horizontales de la matriz y una columna es cada una de las líneas verticales.\n*  **Descripción:** Define una **matriz en el contexto de la programación**, como un arreglo bidimensional de elementos del mismo tipo, ordenados en filas y columnas.\n\n**10. Diapositiva: Matrices (n-por-m) (Página 10)**\n*   **Información:**\n    * Definición: A una matriz con n filas y m columnas se le denomina matriz n-por-m (escrito n × m)\n*   **Descripción:**  Explica la notación para describir una **matriz de `n` filas y `m` columnas**, denotada como \"matriz n-por-m\" o `n × m`.\n\n**11. Diapositiva: Matrices (Tipos de Referencia) (Página 11)**\n*   **Información:**\n    *   Definición: Los tipos en Java se dividen en dos categorías: tipos primitivos y tipos de referencia. Las matrices son objetos, por lo que se consideran como tipos de referencia.\n*   **Descripción:** Explica que las matrices son de **tipo de referencia** en Java, ya que son objetos.\n\n**12. Diapositiva: Matrices (Referencia a Elementos) (Página 12)**\n*   **Información:**\n   * Definición: Para hacer referencia a un elemento específico en una matriz, debemos especificar el nombre de la referencia de la matriz y el número de la fila y el número de la columna del elemento en la matriz.\n*   **Descripción:**  Explica cómo **acceder a elementos específicos de una matriz**, indicando que es necesario especificar el nombre de la matriz, el índice de la fila y el índice de la columna.\n\n**13. Diapositiva: Matrices (Posición de Elementos) (Página 13)**\n*   **Información:**\n    *   Definición: La posición del elemento se compone formalmente de la fila y la columna.\n*  **Descripción:** Indica que cada **elemento en la matriz** tiene una posición que se describe formalmente mediante la fila y la columna.\n\n**14. Diapositiva: Ma",
                "metadata": {
                    "file_name": "Conferencia IX-MATRICES O ARREGLOS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "por lo que se consideran como tipos de referencia.\n*   **Descripción:** Explica que las matrices son de **tipo de referencia** en Java, ya que son objetos.\n\n**12. Diapositiva: Matrices (Referencia a Elementos) (Página 12)**\n*   **Información:**\n   * Definición: Para hacer referencia a un elemento específico en una matriz, debemos especificar el nombre de la referencia de la matriz y el número de la fila y el número de la columna del elemento en la matriz.\n*   **Descripción:**  Explica cómo **acceder a elementos específicos de una matriz**, indicando que es necesario especificar el nombre de la matriz, el índice de la fila y el índice de la columna.\n\n**13. Diapositiva: Matrices (Posición de Elementos) (Página 13)**\n*   **Información:**\n    *   Definición: La posición del elemento se compone formalmente de la fila y la columna.\n*  **Descripción:** Indica que cada **elemento en la matriz** tiene una posición que se describe formalmente mediante la fila y la columna.\n\n**14. Diapositiva: Matrices (Expresión de Acceso) (Página 14)**\n*   **Información:**\n    *  Definición: Un programa puede hacer referencia a cualquiera de estos elementos mediante una expresión de acceso a una matriz que incluye el nombre de la matriz, seguido por el índice-fila del elemento específico encerrado entre corchetes seguido igualmente por el índice-columna del elemento específico encerrado entre corchetes ([ ][ ]).\n*   **Descripción:** Introduce la **forma de acceder a un elemento**, a través de la \"expresión de acceso\", mediante el uso del nombre de la matriz y el índice de la fila y columna entre corchetes `[][].`\n\n**15. Diapositiva: Matrices (Declaración y Creación - Introducción) (Página 15)**\n*  **Información:**\n    * Definición: Los objetos matrices ocupan espacio en memoria. Al igual que los demás objetos, los arreglos se crean con la palabra clave new.\n*  **Descripción:**  Inicia la explicación de **cómo crear matrices**, indicando que, al igual que los demás objetos, deben reservarse en memoria con la palabra clave `new`.\n\n**16. Diapositiva: Matrices (Declaración y Creación -  new) (Página 16)**\n*   **Información:**\n   * Definición: Para crear un objeto matriz, el programador especifica el tipo de cada elemento y el número de filas y columnas que se requieren para la matriz, como parte de una expresión para crear un arreglo que utiliza la palabra clave `new`.\n*  **Descripción:** Explica que para crear una matriz, se especifica el tipo de dato y la cantidad de filas y columnas, utilizando la palabra clave `new`.\n\n**17. Diapositiva: Matrices (Declaración y Creación - Sintaxis) (Página 17)**\n*  **Información:**\n    *  Sintaxis: `<TD> [][] <nombre> = new <TD> [<fil>][<col>];`\n     * Definiciones:\n        *   `<TD>`: Tipo de dato\n        *   `<nombre>`: Nombre de la matriz\n        *   `<fil>`: Cantidad de filas de la matriz\n        *   `<col>`: Cantidad de columnas de la matriz\n*   **Descripción:** Presenta la **sintaxis formal** para declarar y crear matrices en Java, describiendo cada componente: tipo de datos, nombre, cantidad de filas y cantidad de columnas.\n\n**18. Diapositiva: Matrices (Declaración y Creación - Ejemplo 1) (Página 18)**\n*  **Información:**\n    *   Código: `int[][] c = new int[12][10];`\n    * Texto: La siguiente declaración y expresión crea una matriz, que contiene 12 filas y 10 columnas int, y almacena la referencia de la matriz en la variable c\n*  **Descripción:**  Muestra un **ejemplo de código** de cómo declarar y crear una matriz de enteros de 12 filas y 10 columnas.\n\n**19. Diapositiva: Matrices (Declaración y Creación - Ejemplo 2) (Página 19)**\n*   **Información:**\n    * Ejemplo:\n        ```java\n            int [][] c;  // declara la variable matriz\n            c = new int[12][10]; /* crea la matriz; lo asigna a\n              la variable tipo matriz*/\n        ```\n*   **Descripción:**  Muestra cómo realizar la **creación de una matriz en dos pasos**, primero declarar la referencia y luego asignar el espacio de memoria.\n\n**20. Diapositiva: Matrices (Uso de un Inicializador - Introducción) (Página 20)**\n*   **Información:**\n    *   Definición: Al igual que los arreglos unidimensionales, los arreglos multidimensionales pueden inicializarse mediante inicializadores de arreglos en las declaraciones.\n*  **Descripción:**  Introduce la posibilidad de **inicializar matrices** utilizando inicializadores directamente en la declaración, de manera similar a los arreglos unidimensionales.\n\n**21. Diapositiva: Matrices (Uso de un Inicializador - Ejemplo) (Página 21)**\n*   **Información:**\n    *   Ejemplo: `int b[][] = {{1, 2}, {3, 4}};`\n    * Texto: Un arreglo bidimensional b con dos fi las y dos columnas podría declararse e inicializarse con inicializadores de arreglos anidados, como se muestra a continuación\n*   **Descripción:**  Muestra un **ejemplo de código** para declarar e inicializar una matriz bidimensional usando inicializadores anidados.\n\n**22. Diapositiva: Matrices (Uso de un Inicializador - Elementos) (Página ",
                "metadata": {
                    "file_name": "Conferencia IX-MATRICES O ARREGLOS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Diapositiva: Matrices (Uso de un Inicializador - Introducción) (Página 20)**\n*   **Información:**\n    *   Definición: Al igual que los arreglos unidimensionales, los arreglos multidimensionales pueden inicializarse mediante inicializadores de arreglos en las declaraciones.\n*  **Descripción:**  Introduce la posibilidad de **inicializar matrices** utilizando inicializadores directamente en la declaración, de manera similar a los arreglos unidimensionales.\n\n**21. Diapositiva: Matrices (Uso de un Inicializador - Ejemplo) (Página 21)**\n*   **Información:**\n    *   Ejemplo: `int b[][] = {{1, 2}, {3, 4}};`\n    * Texto: Un arreglo bidimensional b con dos fi las y dos columnas podría declararse e inicializarse con inicializadores de arreglos anidados, como se muestra a continuación\n*   **Descripción:**  Muestra un **ejemplo de código** para declarar e inicializar una matriz bidimensional usando inicializadores anidados.\n\n**22. Diapositiva: Matrices (Uso de un Inicializador - Elementos) (Página 22)**\n*   **Información:**\n     * Definición: Los valores del inicializador se agrupan por fila entre llaves. Así, 1 y 2 inicializan a b[0][0] y b[0][1], respectivamente; 3 y 4 inicializan a b[1][0] y b[1][1], respectivamente.\n*   **Descripción:**  Explica cómo **se interpretan los valores** en un inicializador anidado, y cómo cada valor va correspondiendo a un elemento en la matriz.\n\n**23. Diapositiva: Matrices (Uso de un Inicializador - Arreglo de Arreglos) (Página 23)**\n*  **Información:**\n     *  Definición: Los arreglos multidimensionales se mantienen como arreglos de arreglos unidimensionales.\n*   **Descripción:**  Explica que **las matrices se gestionan como un arreglo de arreglos unidimensionales**.\n\n**24. Diapositiva: Matrices (Uso de un Inicializador - Desglose del Ejemplo) (Página 24)**\n*   **Información:**\n   *  Definición: el arreglo b en la declaración anterior está realmente compuesto de dos arreglos unidimensionales separados: uno que contiene los valores en la primera lista inicializadora anidada 1, 2 y uno que contiene los valores en la segunda lista inicializadora anidada 3, 4.\n*   **Descripción:**  Aclara la forma en que se asignan los valores, viendo al arreglo bidimensional como **un arreglo de arreglos unidimensionales**.\n\n**25. Diapositiva: Matrices (Instrucción for para Iterar - Introducción) (Página 25)**\n*   **Información:**\n   * Definición: Utilizar las instrucciones for controladas por un contador para iterar a través de los elementos en un arreglo es muy común. En caso de las matrices para iterar sobre ellas debes llevar dos contadores\n*   **Descripción:**  Introduce el uso del bucle `for` para **iterar sobre matrices**, indicando que se requiere un contador para filas y otro para columnas.\n\n**26. Diapositiva: Matrices (Instrucción for para Iterar - Contadores) (Página 26)**\n\n*   **Información:**\n     * Definición: En este caso un contador para fila y otro para la columna. Si para iterar en un arreglo hace falta un for en las matrices se utiliza un dos for anidados.\n*  **Descripción:** Explica que para iterar sobre matrices son necesarios **dos contadores** y, por tanto, **dos bucles `for` anidados**.\n\n**27. Diapositiva: Matrices (Instrucción for para Iterar - Ejemplos) (Página 27)**\n*  **Información:**\n   *  Ejemplo 1:\n       ```java\n            for(int i=0;i<filas;i++){\n              for(int j=0;j<columnas;j++){\n                 System.out.println(a[i][j]);\n              }\n           }\n        ```\n   * Ejemplo 2:\n       ```java\n          for(int i=0;i<columnas;i++) {\n              for(int j=0;j<filas;j++){\n                 System.out.println(a[j][i]);\n              }\n           }\n        ```\n*  **Descripción:** Muestra **dos ejemplos de cómo usar bucles `for` anidados** para recorrer todos los elementos de una matriz.\n\n**28. Diapositiva: Matrices (Instrucción for para Iterar - Recorrido) (Página 28)**\n*  **Información:**\n     * Definición: En ambos casos se logra iterar sobre cada uno de los elementos de matriz. Pero con recorridos diferentes\n*   **Descripción:** Aclara que ambos ejemplos visitan **todos los elementos**, pero que el orden del recorrido es diferente.\n\n**29. Diapositiva: Matrices (Paso de Matrices a los Métodos - Ejemplo) (Página 29)**\n\n*  **Información:**\n   *   Ejemplo:\n        ```java\n            double [][] temperaturasPorHoraYDia = new double [24][365];\n            modificarArreglo( temperaturasPorHoraYDia );\n        ```\n     * Texto:  Para pasar un argumento tipo matrices a un método, se especifica el nombre de la matriz sin corchetes.\n*   **Descripción:** Indica cómo **pasar una matriz como argumento a un método**, especificando solo su nombre (sin corchetes).\n\n**30. Diapositiva: Matrices (Paso de Arreglos a los Métodos - Argumentos Adicionales) (Página 30)**\n*   **Información:**\n    *   Definición: Toda fila de la matriz \"conoce\" su propia cantidad de columnas (a través de su campo length) y la matriz la cantidad de filas (a través de su campo length). Cuando pasamos a un ",
                "metadata": {
                    "file_name": "Conferencia IX-MATRICES O ARREGLOS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ro con recorridos diferentes\n*   **Descripción:** Aclara que ambos ejemplos visitan **todos los elementos**, pero que el orden del recorrido es diferente.\n\n**29. Diapositiva: Matrices (Paso de Matrices a los Métodos - Ejemplo) (Página 29)**\n\n*  **Información:**\n   *   Ejemplo:\n        ```java\n            double [][] temperaturasPorHoraYDia = new double [24][365];\n            modificarArreglo( temperaturasPorHoraYDia );\n        ```\n     * Texto:  Para pasar un argumento tipo matrices a un método, se especifica el nombre de la matriz sin corchetes.\n*   **Descripción:** Indica cómo **pasar una matriz como argumento a un método**, especificando solo su nombre (sin corchetes).\n\n**30. Diapositiva: Matrices (Paso de Arreglos a los Métodos - Argumentos Adicionales) (Página 30)**\n*   **Información:**\n    *   Definición: Toda fila de la matriz \"conoce\" su propia cantidad de columnas (a través de su campo length) y la matriz la cantidad de filas (a través de su campo length). Cuando pasamos a un método la referencia a un objeto matriz, no necesitamos pasar la cantidad de filas y columnas como argumentos adicionales.\n*   **Descripción:** Explica que **no es necesario pasar las dimensiones** de la matriz como argumentos adicionales ya que pueden consultarse dentro del método.\n\n**31. Diapositiva: Matrices (Paso de Arreglos a los Métodos - Parámetros) (Página 31)**\n\n*   **Información:**\n     *   Definición: Para que un método reciba una referencia de una matriz a través de una llamada a un método, la lista de parámetros del método debe especificar un parámetro tipo matriz.\n*   **Descripción:**  Indica que al declarar un método que recibe una matriz, es necesario especificar que el **parámetro es de tipo matriz**.\n\n**32. Diapositiva: Matriz (Paso de Arreglos a los Métodos - Encabezado) (Página 32)**\n*  **Información:**\n   * Ejemplo: `public static void modificarArreglo(int [][] b){ //... }`\n   *   Texto:  lo cual indica que modificarMatriz recibe la referencia de una matriz de enteros en el parámetro b.\n*   **Descripción:** Muestra cómo se declararía la **cabecera de un método** que recibe una matriz de enteros como parámetro.\n\n**33. Diapositiva: Matriz (Paso de Arreglos a los Métodos - Referencia) (Página 33)**\n*   **Información:**\n    *   Definición: La llamada a este método pasa la referencia a la matriz temperaturasPorHoraDia, de manera que cuando el método llamado utiliza la variable b tipo matriz, hace referencia al mismo objeto matriz como temperaturasPorHora en el método que hizo la llamada.\n*   **Descripción:** Aclara que al pasar la matriz al método, se **pasa la referencia al objeto**, no se crea una copia del mismo.\n\n**34. Diapositiva: Conclusiones (Grafos) (Página 34)**\n*   **Información:**\n   * Conclusión: En teoría de los grafos, a todo grafo etiquetado corresponde la matriz de adyacencia. Una matriz de permutación es una matriz que representa una permutación; matriz cuadrada cuyos coeficientes son 0 o 1, con un solo 1 en cada línea y cada columna. Estas matrices se utilizan en combinatorio.\n*   **Descripción:** Explica que las matrices se utilizan en la teoría de grafos, para la creación de **matriz de adyacencia** y  **matriz de permutación.**\n\n**35. Diapositiva: Conclusiones (Matriz de un Grafo) (Página 35)**\n*   **Información:**\n    *   Conclusión: En la teoría de grafos, se llama matriz de un grafo a la matriz que indica en la línea i y la columna j el número de aristas que enlazan el vértice i al vértice j. En un grafo no orientado, la matriz es simétrica.\n*  **Descripción:** Muestra otra aplicación de la **matriz de adyacencia** en grafos, ahora mostrando la relación entre los vértices del grafo.\n\n**36. Diapositiva: Conclusiones (Paso por Referencia y Matrices Anónimas) (Página 36)**\n*   **Información:**\n    * Conclusión 1: Como todos los objetos, las matrices se pasan como argumentos a los métodos por referencia.\n    * Conclusión 2: Se pueden crear matrices anónimas (por ejemplo, crear una nueva,matriz como argumento actual en la llamada a un método).\n*   **Descripción:** Resalta que las matrices se pasan a métodos **por referencia** y que pueden crearse **matrices anónimas** directamente en la llamada al método.\n\n**37. Diapositiva: Conclusiones (Iteración en Matrices) (Página 37)**\n*   **Información:**\n     * Conclusión: A veces el iterar o moverse dentro de una matriz de cierta manera puede contribuir de forma positiva o negativa en la búsqueda de la solución.\n*   **Descripción:** Advierte que la forma de **iterar sobre una matriz puede influir en la eficiencia del programa.**\n\n**38. Diapositiva: Fin (Página 38)**\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*  **Descripción:** Esta es la diapositiva de **cierre** de la presentación, con el logo de la universidad, su lema y la palabra \"FIN\".\n",
                "metadata": {
                    "file_name": "Conferencia IX-MATRICES O ARREGLOS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "tual en la llamada a un método).\n*   **Descripción:** Resalta que las matrices se pasan a métodos **por referencia** y que pueden crearse **matrices anónimas** directamente en la llamada al método.\n\n**37. Diapositiva: Conclusiones (Iteración en Matrices) (Página 37)**\n*   **Información:**\n     * Conclusión: A veces el iterar o moverse dentro de una matriz de cierta manera puede contribuir de forma positiva o negativa en la búsqueda de la solución.\n*   **Descripción:** Advierte que la forma de **iterar sobre una matriz puede influir en la eficiencia del programa.**\n\n**38. Diapositiva: Fin (Página 38)**\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*  **Descripción:** Esta es la diapositiva de **cierre** de la presentación, con el logo de la universidad, su lema y la palabra \"FIN\".\n",
                "metadata": {
                    "file_name": "Conferencia IX-MATRICES O ARREGLOS.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "**Tema V Arreglos y Matrices\n**Presentación: Arreglos Unidimensionales**\n\n**1. Diapositiva: Título (Página 1)**\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Título: ARREGLOS UNIDIMENSIONALES.\n    *   Subtítulo: INTRODUCCIÓN A LA PROGRAMACIÓN INGENIERÍA EN INFORMÁTICA.\n    *   Fecha: Octubre / 2019.\n*   **Descripción:** Esta es la diapositiva de **portada** de la presentación. Muestra el logo de la Universidad de Matanzas, el título principal, el subtítulo con el contexto de la presentación, y la fecha.\n\n**2. Diapositiva: Objetivos (Parte 1) (Página 2)**\n*   **Información:**\n    *   Objetivo: Caracterizar los arreglos unidimensionales como parte de la construcción de un programa computacional.\n*   **Descripción:**  Presenta el primer **objetivo** de la presentación: comprender la importancia de los arreglos unidimensionales en la construcción de programas.\n\n**3. Diapositiva: Objetivos (Parte 2) (Página 3)**\n*   **Información:**\n    *  Objetivo: Declarar arreglos, inicializarlos y hacer referencia a elementos individuales de los arreglos.\n*   **Descripción:**  Presenta el segundo **objetivo** de la presentación: aprender a declarar arreglos, inicializarlos y acceder a sus elementos.\n\n**4. Diapositiva: Objetivos (Parte 3) (Página 4)**\n*  **Información:**\n   * Objetivo 1: Utilizar la instrucción `for` mejorada para iterar a través de los arreglos.\n   * Objetivo 2: Pasar arreglos a los métodos como argumentos.\n*   **Descripción:**  Presenta los dos últimos **objetivos** de la presentación: aprender a iterar sobre arreglos utilizando el `for` mejorado y cómo pasar arreglos como argumentos a métodos.\n\n**5. Diapositiva: Sumario (Página 5)**\n*   **Información:**\n    *  Temas: Arreglos (Declaración y creación, Uso de un inicializador, Instrucción `for` mejorada, Paso de arreglos a los métodos), Métodos de la clase `Arrays`.\n*   **Descripción:**  Ofrece un **resumen** de los temas principales a tratar en la presentación.\n\n**6. Diapositiva: Bibliografía (Página 6)**\n*   **Información:**\n    *   Referencias: Como programar en Java. Aprenda Java como si estuviera en primero.\n*   **Descripción:**  Lista las **fuentes bibliográficas** utilizadas en la presentación.\n\n**7. Diapositiva: Arreglos (Definición) (Página 7)**\n*   **Información:**\n   * Definición: Los arreglos son estructuras de datos que consisten de elementos de datos relacionados, del mismo tipo. Los arreglos son entidades de longitud fija; conservan la misma longitud una vez creados.\n*   **Descripción:** Introduce el concepto de **arreglos**, como colecciones de elementos del mismo tipo y longitud fija.\n\n**8. Diapositiva: Arreglos (Reasignación) (Página 8)**\n*   **Información:**\n    * Definición: Aunque puede reasignarse una variable tipo arreglo de tal forma que haga referencia a un nuevo arreglo de distinta longitud.\n*  **Descripción:** Aclara que aunque un arreglo tenga una longitud fija, una variable puede ser reasignada para apuntar a un nuevo arreglo de distinta longitud.\n\n**9. Diapositiva: Arreglos (Definición en Java) (Página 9)**\n*  **Información:**\n    * Definición: En Java, un arreglo es un grupo de variables (llamadas elementos o componentes) que contienen valores, todos del mismo tipo.\n*   **Descripción:**  Define un **arreglo en Java**, como un conjunto de variables (elementos) del mismo tipo.\n\n**10. Diapositiva: Arreglos (Tipos de Referencia) (Página 10)**\n*  **Información:**\n     * Definición: Los tipos en Java se dividen en dos categorías: tipos primitivos y tipos de referencia. Los arreglos son objetos, por lo que se consideran como tipos de referencia.\n*   **Descripción:** Indica que los arreglos en Java son **tipos de referencia**, ya que son objetos.\n\n**11. Diapositiva: Arreglos (Referencia a Elementos) (Página 11)**\n*  **Información:**\n    * Definición: Para hacer referencia a un elemento específico en un arreglo, debemos especificar el nombre de la referencia al arreglo y el número de la posición del elemento en el arreglo.\n*   **Descripción:**  Explica cómo **acceder a un elemento específico** de un arreglo, requiriendo el nombre del arreglo y su posición (índice).\n\n**12. Diapositiva: Arreglos (Índice) (Página 12)**\n*  **Información:**\n    * Definición: El número de la posición del elemento se conoce formalmente como el índice o subíndice del elemento.\n*   **Descripción:**  Define el concepto de **índice** o subíndice como la forma formal en la que se denota la posición de un elemento dentro de un arreglo.\n\n**13. Diapositiva: Arreglos (Expresión de Acceso) (Página 13)**\n*  **Información:**\n    * Definición: Un programa puede hacer referencia a cualquiera de estos elementos mediante una expresión de acceso a un arreglo que incluye el nombre del arreglo, seguido por el índice del elemento específico encerrado entre corchetes ([ ]).\n*   **Descripción:** Describe la **expresión de acceso a un arreglo**, indicando que se utiliza el nombre del arreglo seguido del índice entre corchetes.\n\n**14. Diapositiva: Arreglos ",
                "metadata": {
                    "file_name": "Conferencia VIII-ARREGLOS UNIDIMENSIONALES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Descripción:**  Explica cómo **acceder a un elemento específico** de un arreglo, requiriendo el nombre del arreglo y su posición (índice).\n\n**12. Diapositiva: Arreglos (Índice) (Página 12)**\n*  **Información:**\n    * Definición: El número de la posición del elemento se conoce formalmente como el índice o subíndice del elemento.\n*   **Descripción:**  Define el concepto de **índice** o subíndice como la forma formal en la que se denota la posición de un elemento dentro de un arreglo.\n\n**13. Diapositiva: Arreglos (Expresión de Acceso) (Página 13)**\n*  **Información:**\n    * Definición: Un programa puede hacer referencia a cualquiera de estos elementos mediante una expresión de acceso a un arreglo que incluye el nombre del arreglo, seguido por el índice del elemento específico encerrado entre corchetes ([ ]).\n*   **Descripción:** Describe la **expresión de acceso a un arreglo**, indicando que se utiliza el nombre del arreglo seguido del índice entre corchetes.\n\n**14. Diapositiva: Arreglos (Declaración y Creación - Introducción) (Página 14)**\n*   **Información:**\n    *  Definición: Los objetos arreglo ocupan espacio en memoria. Al igual que los demás objetos, los arreglos se crean con la palabra clave new.\n*   **Descripción:** Introduce el tema de cómo **declarar y crear arreglos**, explicando que ocupan espacio en la memoria y se crean con la palabra clave `new`.\n\n**15. Diapositiva: Arreglos (Declaración y Creación - new) (Página 15)**\n*  **Información:**\n    * Definición: Para crear un objeto arreglo, el programador especifica el tipo de cada elemento y el número de elementos que se requieren para el arreglo, como parte de una expresión para crear un arreglo que utiliza la palabra clave `new`.\n*  **Descripción:** Aclara que al crear un arreglo se debe indicar el **tipo de datos** que almacenará y la **cantidad de elementos**, usando `new`.\n\n**16. Diapositiva: Arreglos (Declaración y Creación - Sintaxis) (Página 16)**\n*   **Información:**\n    *   Sintaxis: `<TD> <nombre>[] = new <TD> [<capacidad>];`\n    *  Definiciones:\n        *   `<TD>`: Tipo de dato\n        *   `<nombre>`: Nombre del arreglo\n        *   `<capacidad>`: Cantidad de elementos del arreglo.\n*   **Descripción:**  Presenta la **sintaxis formal** de cómo declarar y crear un arreglo en Java, mostrando sus partes principales: tipo de datos, nombre y capacidad del mismo.\n\n**17. Diapositiva: Arreglos (Declaración y Creación - Ejemplo) (Página 17)**\n*  **Información:**\n    *  Ejemplo: `int c[] = new int[12];`\n   *  Texto: La siguiente declaración y expresión crea un arreglo, que contiene 12 elementos int, y almacena la referencia del arreglo en la variable c\n*  **Descripción:** Muestra un **ejemplo de código** donde se declara e inicializa un arreglo de enteros con 12 posiciones.\n\n**18. Diapositiva: Arreglos (Declaración y Creación - Dos Pasos) (Página 18)**\n*  **Información:**\n      * Ejemplo:\n    ```java\n        int c[ ]; // declara la variable arreglo\n        c = new int[ 12 ]; /* crea el arreglo; lo asigna a\n         la variable tipo arreglo*/\n     ```\n*  **Descripción:**  Muestra cómo se puede **crear un arreglo en dos pasos**: primero declarar la variable y luego crear el arreglo con `new` y asignarlo.\n\n**19. Diapositiva: Arreglos (Uso de un Inicializador - Introducción) (Página 19)**\n*   **Información:**\n    *   Definición: Un programa puede crear un arreglo e inicializar sus elementos con un inicializador de arreglo, que es una lista de expresiones separadas por comas encerrada entre llaves ({ y });\n*  **Descripción:** Introduce el concepto de **inicializador de arreglo**, como una lista entre llaves que asigna valores iniciales a los elementos del arreglo en el momento de la declaración.\n\n**20. Diapositiva: Arreglos (Uso de un Inicializador - Ejemplo) (Página 20)**\n*   **Información:**\n   * Ejemplo: `int n[] = {10, 20, 30, 40, 50};`\n    * Texto: Crea un arreglo de cinco elementos con los valores de índices 0, 1, 2, 3 y 4. El elemento n[0] se inicializa con 10, n[1] se inicializa con 20, y así en lo sucesivo.\n*   **Descripción:** Muestra un **ejemplo de inicialización de arreglos**, asignando los valores a los elementos de un arreglo.\n\n**21. Diapositiva: Arreglos (Instrucción for Mejorada - Introducción) (Página 21)**\n*   **Información:**\n    * Definición: Utilizar las instrucciones for controladas por un contador para iterar a través de los elementos en un arreglo es muy común.\n*  **Descripción:**  Introduce el bucle `for` como forma común de recorrer un arreglo.\n\n**22. Diapositiva: Arreglos (Instrucción for Mejorada - Ventajas) (Página 22)**\n*  **Información:**\n    * Definición: La instrucción for mejorada, la cual itera a través de los elementos de un arreglo o colección sin utilizar un contador con lo cual, evita la posibilidad de \"salirse\" del arreglo.\n*   **Descripción:**  Introduce el concepto de **bucle `for` mejorado**, que evita errores comunes al recorrer arreglos, iterando sobre los elementos sin necesidad de un contador explícito.\n\n*",
                "metadata": {
                    "file_name": "Conferencia VIII-ARREGLOS UNIDIMENSIONALES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": " se inicializa con 20, y así en lo sucesivo.\n*   **Descripción:** Muestra un **ejemplo de inicialización de arreglos**, asignando los valores a los elementos de un arreglo.\n\n**21. Diapositiva: Arreglos (Instrucción for Mejorada - Introducción) (Página 21)**\n*   **Información:**\n    * Definición: Utilizar las instrucciones for controladas por un contador para iterar a través de los elementos en un arreglo es muy común.\n*  **Descripción:**  Introduce el bucle `for` como forma común de recorrer un arreglo.\n\n**22. Diapositiva: Arreglos (Instrucción for Mejorada - Ventajas) (Página 22)**\n*  **Información:**\n    * Definición: La instrucción for mejorada, la cual itera a través de los elementos de un arreglo o colección sin utilizar un contador con lo cual, evita la posibilidad de \"salirse\" del arreglo.\n*   **Descripción:**  Introduce el concepto de **bucle `for` mejorado**, que evita errores comunes al recorrer arreglos, iterando sobre los elementos sin necesidad de un contador explícito.\n\n**23. Diapositiva: Arreglos (Instrucción for Mejorada - Sintaxis 1) (Página 23)**\n*   **Información:**\n    *   Sintaxis: `for ( <parametro> : <nombreArreglo> ){ <instrucciones> }`\n    *  Definiciones:\n        *   `<parámetro>`: tiene dos partes; un tipo y un identificador\n        *   `<nombreArreglo>`: es el arreglo a través del cual se iterará.\n*   **Descripción:** Muestra la **sintaxis del bucle `for` mejorado**, especificando el uso de dos partes: la declaración de una variable del tipo del arreglo y el nombre de la variable a recorrer.\n\n**24. Diapositiva: Arreglos (Instrucción for Mejorada - Sintaxis 2) (Página 24)**\n*   **Información:**\n    *   Sintaxis: `for ( <parametro> : <nombreArreglo> ){ <instrucciones> }`\n   *  Definiciones:\n        *  `<parámetro>`: tiene dos partes; un tipo y un identificador (por ejemplo, int numero)\n        *  `<nombreArreglo>`: es el arreglo a través del cual se iterará.\n*   **Descripción:**  Muestra nuevamente la sintaxis del bucle `for` mejorado.\n\n**25. Diapositiva: Arreglos (Instrucción for Mejorada - Tipo) (Página 25)**\n*   **Información:**\n     * Definición: El tipo del parámetro debe concordar con el tipo de los elementos en el arreglo.\n*   **Descripción:** Indica que el **tipo de la variable que se itera** en el bucle `for` mejorado debe coincidir con el tipo de dato de los elementos del arreglo.\n\n**26. Diapositiva: Arreglos (Instrucción for Mejorada - Ejemplo) (Página 26)**\n*  **Información:**\n    * Ejemplo de código:\n    ```java\n    public class PruebaForMejorado{\n      public static void main(String args() ){\n         int arreglo[] = {87,68,94,100,83,78,85,91,76,87};\n         int total = 0;\n          // suma el valor de cada elemento al total\n         for( int numero : arreglo )\n              total += numero;\n         System.out.printf( \"Total de elementos del arreglo: %d\\n\", total );\n       }\n     }\n    ```\n*  **Descripción:** Muestra un **ejemplo del uso del `for` mejorado**, mostrando la forma más sencilla de recorrer un arreglo y sumar sus elementos.\n\n**27. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Ejemplo) (Página 27)**\n*   **Información:**\n      * Ejemplo de código:\n    ```java\n        double temperaturasPorHora [] = new double[ 24 ];\n        modificarArreglo( temperaturasPorHora );\n    ```\n    * Texto: Para pasar un argumento tipo arreglo a un método, se especifica el nombre del arreglo sin corchetes.\n*  **Descripción:** Indica que para pasar un **arreglo como argumento a un método**, solo debe especificarse el nombre del arreglo, sin corchetes.\n\n**28. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Longitud) (Página 28)**\n*  **Información:**\n   * Definición: Todo objeto arreglo “conoce” su propia longitud (a través de su campo length). Por ende, cuando pasamos a un método la referencia a un objeto arreglo, no necesitamos pasar la longitud del arreglo como un argumento adicional.\n*   **Descripción:**  Explica que los arreglos tienen una propiedad llamada `length` que permite **obtener la cantidad de elementos**, por lo que no hace falta pasarla explícitamente al método.\n\n**29. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Parámetros) (Página 29)**\n*  **Información:**\n    *   Definición: Para que un método reciba una referencia a un arreglo a través de una llamada a un método, la lista de parámetros del método debe especificar un parámetro tipo arreglo.\n*   **Descripción:** Aclara que para que un método reciba un arreglo como parámetro, debe indicarse que el parámetro es de **tipo arreglo**.\n\n**30. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Encabezado) (Página 30)**\n\n*   **Información:**\n    * Ejemplo: `public static void modificarArreglo(int [] b){ //.... }`\n    * Texto: lo cual indica que modificarArreglo recibe la referencia de un arreglo de enteros en el parámetro b.\n*  **Descripción:** Muestra la forma de declarar un **método que recibe un arreglo** de enteros como parámetro.\n\n**31. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Referencia)",
                "metadata": {
                    "file_name": "Conferencia VIII-ARREGLOS UNIDIMENSIONALES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "r la cantidad de elementos**, por lo que no hace falta pasarla explícitamente al método.\n\n**29. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Parámetros) (Página 29)**\n*  **Información:**\n    *   Definición: Para que un método reciba una referencia a un arreglo a través de una llamada a un método, la lista de parámetros del método debe especificar un parámetro tipo arreglo.\n*   **Descripción:** Aclara que para que un método reciba un arreglo como parámetro, debe indicarse que el parámetro es de **tipo arreglo**.\n\n**30. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Encabezado) (Página 30)**\n\n*   **Información:**\n    * Ejemplo: `public static void modificarArreglo(int [] b){ //.... }`\n    * Texto: lo cual indica que modificarArreglo recibe la referencia de un arreglo de enteros en el parámetro b.\n*  **Descripción:** Muestra la forma de declarar un **método que recibe un arreglo** de enteros como parámetro.\n\n**31. Diapositiva: Arreglos (Paso de Arreglos a Métodos - Referencia) (Página 31)**\n*   **Información:**\n      *Definición: La llamada a este método pasa la referencia al arreglo temperaturasPorHoras , de manera que cuando el método llamado utiliza la variable b tipo arreglo, hace referencia al mismo objeto arreglo como temperaturasPorHora en el método que hizo la llamada.\n*  **Descripción:** Aclara que al pasar un arreglo como argumento se está pasando la **referencia del arreglo**, y no una copia de los datos.\n\n**32. Diapositiva: Clase Arrays (Introducción) (Página 32)**\n*  **Información:**\n    *   Definición: Es una clase de utilidad introducida en el JDK 1.2 que contiene métodos static para ordenar, llenar, realizar búsquedas y comparar los arrays clásicos del lenguaje.\n*   **Descripción:** Introduce la **clase `Arrays`**, que ofrece métodos estáticos para operar sobre arreglos.\n\n**33. Diapositiva: Clase Arrays (Referencia) (Página 33)**\n*   **Información:**\n    * Referencia: Para una mejor compresión puedes consultar el libro \"Cómo programar en Java\" a partir de la página 794 presente en la bibliografía de la asignatura.\n*   **Descripción:**  Sugiere una **fuente bibliográfica** donde se pueden consultar métodos y funciones de la clase `Arrays` (del libro \"Cómo Programar en Java\").\n\n**34. Diapositiva: Conclusiones (Creación y Acceso) (Página 34)**\n*   **Información:**\n    * Conclusión 1: Los arrays se crean con el operador `new` seguido del tipo y número de elementos.\n    * Conclusión 2: Se puede acceder al número de elementos de un array con la variable miembro implícita `length` (por ejemplo, `vect.length`).\n*  **Descripción:**  Presenta las primeras **conclusiones** de la presentación: cómo se crean los arreglos y cómo obtener su tamaño con `length`.\n\n**35. Diapositiva: Conclusiones (Acceso a Elementos) (Página 35)**\n*   **Información:**\n   * Conclusión 1: Se accede a los elementos de un array con los corchetes `[ ]` y un índice que varía de 0 a length-1.\n   * Conclusión 2: Se pueden crear arrays de objetos de cualquier tipo. En principio un array de objetos es un array de referencias que hay que completar llamando al operador `new`.\n*   **Descripción:**  Continúa con las **conclusiones** sobre cómo acceder a los elementos de un arreglo y que los arreglos pueden almacenar referencias a objetos.\n\n**36. Diapositiva: Conclusiones (Inicialización Implícita) (Página 36)**\n*  **Información:**\n   * Conclusión: Los elementos de un array se inicializan al valor por defecto del tipo correspondiente (cero para valores numéricos, el carácter nulo para char, false para boolean, null para Strings y para referencias).\n*   **Descripción:** Explica que los arreglos se **inicializan implícitamente** con valores por defecto, diferentes según el tipo de dato almacenado.\n\n**37. Diapositiva: Conclusiones (Paso por Referencia y Arreglos Anónimos) (Página 37)**\n*  **Información:**\n   * Conclusión 1: Como todos los objetos, los arrays se pasan como argumentos a los métodos por referencia.\n   * Conclusión 2: Se pueden crear arrays anónimos (por ejemplo, crear un nuevo array como argumento actual en la llamada a un método).\n*  **Descripción:** Indica que los arreglos se pasan como **argumentos por referencia** a los métodos y que es posible crear **arreglos anónimos** directamente en la llamada.\n\n**38. Diapositiva: Fin (Página 38)**\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva de **cierre** de la presentación.\n",
                "metadata": {
                    "file_name": "Conferencia VIII-ARREGLOS UNIDIMENSIONALES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "anónimos (por ejemplo, crear un nuevo array como argumento actual en la llamada a un método).\n*  **Descripción:** Indica que los arreglos se pasan como **argumentos por referencia** a los métodos y que es posible crear **arreglos anónimos** directamente en la llamada.\n\n**38. Diapositiva: Fin (Página 38)**\n*   **Información:**\n    *   Logo de la Universidad de Matanzas.\n    *   Lema: cosechando el saber.\n    *   Texto: FIN.\n*   **Descripción:** Esta es la diapositiva de **cierre** de la presentación.\n",
                "metadata": {
                    "file_name": "Conferencia VIII-ARREGLOS UNIDIMENSIONALES.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema: Arreglos y matrices\nUnidad didáctica: Arreglos. Introducción a los arreglos en programación.\n1. Objetivos de la unidad didáctica:\nCaracterizar un arreglo en la programación.\nCaracterizar las distintas formas de declarar un arreglo en el lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nCon los conocimientos que tenemos de programación y del lenguaje de programación Java si nos piden almacenar el valor que representa la temperatura promedio de un día podríamos almacenar dicho valor en una variable flotante que podría ser de esta manera:\n\ndouble tempProm;\n\nPero si necesitará almacenar la de dos días o mejor la tres días o 100 días como resolver antes situaciones ?. Es evidente que para los dos primeros casos con dos y tres variables pero ya el último caso sería factible declarar 100 variables ? Sería fácil trabajar con esa cantidad de variables ?. Pues claro que no pero como resolver entonces la situación anterior.\n\nBueno lo primero que vamos a notar es que la información con que se trabaja se puede clasificar dentro de una misma clase en este caso los valores de las temperaturas son valores numéricos flotante. Por tanto la idea sería tener un solo identificador de memoria de la maquina ( una variable , no se me asusten) en cual pudiéramos almacenar esos valores ya que todos esos valores van ser del mismo tipo de dato. Pues bien lo anterior se resuelve utilizando arreglos. Pero que es un arreglo ?.\n\nBien según los de trajes y corbata un arreglo es una estructura de datos que hace referencia a varios lugares de la memoria de la computadora que se encuentran de forma consecutivas en los cuales se va almacenar información que pertenecen a una misma clase o clasificación. Vamos a tratar de entender esto mejor lo anterior. Una computadora para almacenar un valor entero utiliza 32bits disponibles en la computadora si fuera a reservar un arreglo de enteros con capacidad de 10 elementos la computadora va a buscar 32x10=320 (del bit 0 al bit 31 para almacenar el primer numero, del bit 32 al bit 63 para el segundo número y así cada 32 bits para cada número) bits disponibles de forma consecutivas en la computadoras. Una forma gráfica de ver esto como una tabla con una sola fila y varias columnas donde la cantidad de columnas es la capacidad o la cantidad máxima de valores que va ser capaz de almacenar el arreglo.\n\nEn cada celda de esta tabla se va almacenar un valor. A todas esta celdas de memoria se puede acceder utilizando una sola referencia de memoria o variable. Pero como diferenciar o obtener un determinado valor almacenado dentro del arreglo, bueno por su posición. Si lo anterior no se entendió veamos al siguiente analogía entre una calle residencial y un arreglo. Una arreglo contiene o almacena de forma consecutiva valores que pertenece a un mismo tipo de clase mientras una calle residencial contiene a varias casas de forma consecutivas. Bueno pero como diferenciar o acceder los elementos que almacena un arreglo ? Como sería para el caso de la calle residencial sencillo para la calle residencial solo bastaría con especificar el número de la casa. Pues bien el 'numero de la casa' en el caso del arreglo seria la posición que ocupa el elemento en el arreglo.\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora.\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan.\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente",
                "metadata": {
                    "file_name": "Guía de aprendizaje 12.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "izar el estudio individual o colaborativo.\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan.\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes.\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante.\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone.\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente.\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje.\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico.\n\n5. Actividades de auto-aprendizajes:\nDe cuantas formas podemos declarar un arreglo en el lenguaje de programación Java. Defina su sintaxis de declaración y ejemplifique en cada caso.\nExplique como podemos acceder o modificar los valores almacenados en un arreglo.\nComo podemos movernos o iterar sobre todos los elementos del arreglo. Que estructura de las conocidas es la mas idónea.\nEl arreglo se le define una capacidad y en cada posición se almacenará un valor. Cual es el rango de posición validas del arreglo.\nQue método o función tienen los arreglos en el lenguaje de programación Java que te permiten conocer la capacidad de de estos.\n6. Actividades de evaluación:\nDeclare un arreglo utilizando el lenguaje de programación Java de la forma más conveniente que pueda ser utilizado para almacenar la temperatura promedio diaria durante dos años.\nDeclare un arreglo utilizando el lenguaje de programación Java de la forma más conveniente que pueda ser utilizado para almacenar los 10 primeros valores de la sucesión de los números de Fibonacci.\nDeclare un arreglo utilizando el lenguaje de programación Java de la forma más conveniente cuya capacidad es definida previamente por un valor introducido por el usuario en el programa.\nDefina como se puede acceder a la ultima, penúltima y antepenúltima posición de un arreglo del cual no se conoce su capacidad.\n7. Resumen:\nLos arreglos son la estructura de datos mas sencilla que existe y es la base para entender y comprender el funcionamiento del restos de las estructuras de datos que le continuaron. Con el vamos a poder manipular un grupo de datos de similares características a través de una sola referencia a memoria (una variable).\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos:\n\narreglo unidimensional:\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1.\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8.\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Arreglo. Recorrido, acceso y modificación de sus elementos.",
                "metadata": {
                    "file_name": "Guía de aprendizaje 12.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Arreglos y matrices\nUnidad didáctica: Arreglos. Recorrido, acceso y modificación de sus elementos.\n1. Objetivos de la unidad didáctica:\nCaracterizar la forma de recorrer los elementos de un arreglo en el lenguaje de programación Java.\nCaracterizar la forma de acceder y modificación de los elementos en el lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nEn la guía de aprendizaje anterior se abordó que existe varias formas de declarar un arreglo: Una primera variante donde solo definimos la capacidad del arreglo pero no definimos que valores serán almacenados un ejemplo de esto:\n\ndouble [] tempPromedio = new double [ 732 ];\n\nEstá variante que puede ser una posible variante de solución a la primera actividad de autoevaluación de la guía de aprendizaje anterior. Esta forma define un arreglo capaz de almacenar 732 valores flotantes pero no se define que valores son los almacenados.\n\nUna segunda variante es definir el arreglo con los valores iniciales almacenados como por ejemplo\n\nint [] fibbonacci  = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 54 } ;\n\nEstá variante que puede ser una posible variante de solución a segunda actividad de autoevaluación de la guía de aprendizaje anterior. Esta forma define un arreglo con 10 elementos y a su vez cuales serán los valores.\n\nPero como podemos para el primer caso definir que en determinada posición se quiere almacenar un determinado valor u obtener el valor que se encuentra almacenado en determinada posición del segundo caso.\nPara obtener o modificar un valor dentro del arreglo es necesario nombrar al arreglo y especificar la posición dentro del arreglo a la cual queremos acceder utilizando la pareja de símbolos [ ] dentro de dichos símbolos la posición a la cual queremos acceder, la posición puede estar representada por un valor literal numérico o una variable de tipo entera. [1]\n\nEn el caso de los arreglos las posiciones se enumeran a partir del cero es por eso que la primera posición de un arreglo es la posición 0, la segunda la posición 1, la tercera la posición 2 y así de esta forma sucesivamente. [2]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles.\nCree hábitos de estudio sistemático; para esto:\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [3]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [3]\nUtilice técnicas de estudio:\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [4]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [4]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [4]\nInteractúe con los materiales de estudio en tres fases:\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [5]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [5]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [5]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [6]\n\n5. Actividades de auto-aprendizajes:\nSe desea almacenar el valor 31.5 en el arreglo tempPromedio presentado en la sección Introducción a la unidad didáctica en el día 105 del primer año cuales de las siguientes instrucciones es la correcta: [6]\ntempPromedio = 31.5;\n\ntempPromedio = 31.5;\n\ntempPromedio = 31.5;\n\ntempPromedio = \"31.5\";\n\ntempPromedio = \"31.5\";\n\nCual sería la instrucción en lenguaje de programación Java para almacenar en la variable entera X el valor almacenado en la posición 6 del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. [6]\nSe quiere tener un arreglo de entero que pueda almacenar hasta 100 elementos pero con la siguiente condición: el primer elemento debe almacenar en la posición 1 , el segundo elemento en la posición",
                "metadata": {
                    "file_name": "Guía de aprendizaje 13.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ón: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [6]\n\n5. Actividades de auto-aprendizajes:\nSe desea almacenar el valor 31.5 en el arreglo tempPromedio presentado en la sección Introducción a la unidad didáctica en el día 105 del primer año cuales de las siguientes instrucciones es la correcta: [6]\ntempPromedio = 31.5;\n\ntempPromedio = 31.5;\n\ntempPromedio = 31.5;\n\ntempPromedio = \"31.5\";\n\ntempPromedio = \"31.5\";\n\nCual sería la instrucción en lenguaje de programación Java para almacenar en la variable entera X el valor almacenado en la posición 6 del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. [6]\nSe quiere tener un arreglo de entero que pueda almacenar hasta 100 elementos pero con la siguiente condición: el primer elemento debe almacenar en la posición 1 , el segundo elemento en la posición 2 y así sucesivamente hasta la posición 100 donde se almacena el elemento cien de los valores. Declare un arreglo de entero utilizando el lenguaje de programación Java que permita cumplir con la condición anterior. [7]\n6. Actividades de evaluación:\nDiseñe e implemente un programa utilizando el lenguaje de programación Java que haga uso del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. El programa debe solicitar dos números A y B los cuales deben estar entre 1 y 10 al usuario. Una vez introducidos dicho valores el programa validará que ambos valores están en el rango. De estar en el rango el programa imprimirá la suma de los elementos almacenados en la posiciones de los valores de A y B del arreglo sino se imprimirá el mensaje \"Posiciones fuera del rango valido del arreglo\" [8]\nDiseñe e implemente un programa utilizando el lenguaje de programación Java que haga uso del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. El programa debe solicitar dos números A y B los cuales deben estar entre 1 y 10 al usuario. Una vez introducidos dicho valores el programa validará que ambos valores están en el rango. De estar en el rango el programa imprimirá la suma de todos los elementos almacenados entre en la posiciones de los valores de A y B del arreglo sino se imprimirá el mensaje \"Posiciones fuera del rango valido del arreglo\" [9]\nDiseñe e implemente un programa utilizando el lenguaje de programación Java que haga uso del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. El programa debe solicitar un número A. Una vez introducidos dicho valor el programa imprimirá la suma de los valores del arreglo que son divisible por el valor A. [10]\nDiseñe e implemente un programa utilizando el lenguaje de programación Java que haga uso del arreglo fibbonacci presentado en la sección Introducción a la unidad didáctica. El programa debe ser capaz de crear un arreglo de entero llamado invertFibbonacci con la misma capacidad que el arreglo fibbonacci. El programa debe copiar los elementos almacenados en fibbonacci para invertFibbonacci pero deben ser colocados en orden inversos a como están en el arreglo fibbonacci. [11]\n7. Resumen:\nEl acceso o modificación de los elementos almacenados en un arreglo se hace a través de nombrar el arreglo y una posición de este. La posición va encerrada entre una pareja de [ ] y la misma se puede especificar a través de un valor numérico natural o una variable de tipo entero. La indexación por defecto de los elementos dentro de un arreglo se hace a partir de la posición 0 pero eso no quita que los programadores puedan realizar su propia indexación lo que por supuesto esto llevará algunas modificaciones. [11]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [12]\n\nforeach:\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [12]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [12]\n\n10. Recursos educativos digitales RED: [12]\n11. Próxima unidad: Arreglo. Algoritmos básicos. [12]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 13.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [12]\n\n10. Recursos educativos digitales RED: [12]\n11. Próxima unidad: Arreglo. Algoritmos básicos. [12]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 13.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Arreglos y matrices\nUnidad didáctica: Arreglo. Algoritmos básicos.\n1. Objetivos de la unidad didáctica:\nIdentificar las operaciones básicas que se pueden realizar sobre los arreglos del lenguaje de programación Java.\nCaracterizar cada una de las operaciones básicas que se pueden realizar sobre los arreglos del lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nSobre un arreglo o colección de elementos se pueden realizar un grupo de operaciones independientemente del tipo de dato de los elementos del arreglo. Con estas operaciones vamos a poder adicionar, eliminar, buscar, obtener o modificar elementos en el arreglo. Cada una de esas operaciones se le puede definir su algoritmo el cual se puede codificar en un método. [1]\n\nAntes de empezar a definir cada una de las operaciones es bueno aclarar que siempre que se trabaje con este tipo de estructura puede suceder dos tipos de situaciones: [2]\n\nEl arreglo tiene todas sus capacidades ocupadas por elementos no existen capacidades o huecos vacíos. Esta situación es muy recomendable para arreglos que van ser pasados por parámetros a una función o método. Pero tienen como desventaja que dicho arreglo no acepta nuevos elementos. [2]\nEl arreglo no tiene todas sus capacidades ocupadas por elementos y existen capacidades o huecos vacíos que se encuentran en las últimas posiciones del arreglo. Dichas capacidades o huecos disponibles hacen que cuando se opere con los elementos del arreglo se tenga que conocer la cantidad real de elementos ya que durante una determinada operación se acceda a una posición donde aún no ha sido colocado ningún elemento y provoque un error en cuanto al resultado esperado. Para solventar dicha situación se crea una variable entera casi siempre llamada cantReal asociada al arreglo que su valor indicará cuantos elementos existen realmente en el arreglo. Dicha variable se inicializa en cero y se incrementa o decrementa cada vez que se adiciona o elimina un elemento respectivamente del arreglo. [2]\nLas primeras operaciones que vamos a analizar son las que permiten adicionar nuevos elementos en el arreglo. Lo primero que debemos conocer es que los elementos deben ser colocados de forma consecutiva si dejar capacidad o huecos vacíos entre elementos y siempre comenzando por el principio. Para añadir nuevos elementos existen dos criterios : [3]\n\nAdicionar: El nuevo elemento es colocado en la posición siguiente del último elemento almacenado hasta ese momento en el arreglo en otras palabras se busca la primera posición disponible comenzado desde el principio. [3]\nInsertar: Además del nuevo elemento se necesita una posición dentro del arreglo donde se desea colocar el elemento. Lo anterior provoca que todos los elementos del arreglo almacenados en una posición igual o superior a la posición donde se desea insertar tengan que desplazarse una posición superior para crear la capacidad o hueco al nuevo elemento. [4]\nLa siguiente operación que vamos a analizar será la que permite eliminar elementos del arreglo. Para eliminar un elemento se necesita conocer la posición que ocupa el mismo dentro del arreglo una vez conocido la posición que se desea eliminar se siguen dos criterios: [4]\n\nMantener el orden inicial: Este criterio hace que todos los elementos en una posición superior o mayor que la posición que se desea eliminar tengan que desplazarse una posición inferior y de esta forma sobrescribir el valor que inicialmente quería eliminarse. Esta variante permite mantener el orden inicial existente entre los elementos del arreglo. [5]\nNo importa el orden: Este criterio selecciona el último elemento del arreglo y lo asigna a la posición del arreglo que se desea eliminar esto hace que se sobrescribe el valor que estaba en esa posición por el último valor adicionado al arreglo. Esta variante es mas sencilla de implementar pero no es recomendable cuando se desea mantener el orden inicial de los elementos. [5]\nOtra de las operaciones básicas sobre arreglo es la búsqueda; dentro de los elementos almacenados en el arreglo se comprueba la existencia o no de un determinado elemento. En dicha operación se comprueba recorriendo todos los elementos del arreglo y comprobando con cada uno de los elementos si es igual a valor que se desea buscar en caso de ser igual se dice que que elemento se encuentra y solo se puede asegurar de la no existencia del valor dentro del arreglo cuando se haya comprobado con todos los elementos. [6]\n\nLa operación de búsqueda puede tener varias variantes según sea la necesidad y el problema: [7]\n\nExistencia o no: Solo comprueba si el valor buscado esta almacenado en el arreglo el mismo retorna un valor lógico verdadero si existe falso en caso contrario. [7]\nPosición de la primera ocurrencia: Retorna la posición dentro del arreglo donde esta almacenado la primera ocurrencia del valor buscado comenzando por la po",
                "metadata": {
                    "file_name": "Guía de aprendizaje 14.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ando se desea mantener el orden inicial de los elementos. [5]\nOtra de las operaciones básicas sobre arreglo es la búsqueda; dentro de los elementos almacenados en el arreglo se comprueba la existencia o no de un determinado elemento. En dicha operación se comprueba recorriendo todos los elementos del arreglo y comprobando con cada uno de los elementos si es igual a valor que se desea buscar en caso de ser igual se dice que que elemento se encuentra y solo se puede asegurar de la no existencia del valor dentro del arreglo cuando se haya comprobado con todos los elementos. [6]\n\nLa operación de búsqueda puede tener varias variantes según sea la necesidad y el problema: [7]\n\nExistencia o no: Solo comprueba si el valor buscado esta almacenado en el arreglo el mismo retorna un valor lógico verdadero si existe falso en caso contrario. [7]\nPosición de la primera ocurrencia: Retorna la posición dentro del arreglo donde esta almacenado la primera ocurrencia del valor buscado comenzando por la posición cero. en caso de no existir el valor en el arreglo se retorna -1 ya que un ese valor es una posición invalida dentro de un arreglo en Java. [7]\nPosición de la última ocurrencia: Retorna la posición dentro del arreglo donde esta almacenado la última ocurrencia del valor buscado comenzando por la posición cero. en caso de no existir el valor en el arreglo se retorna -1 ya que un ese valor es una posición invalida dentro de un arreglo en Java. [8]\nTanto las operaciones de obtener o modificar permiten obtener o modificar el valor de una determinada posición del arreglo para eso se necesita en conocer la posición en ambas operaciones mientras en la de modificar se necesita conocer el nuevo valor que se desea almacenar en la posición. [8]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [9]\nCree hábitos de estudio sistemático; para esto: [9]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [9]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [10]\nUtilice técnicas de estudio: [10]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [10]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [10]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [10]\nInteractúe con los materiales de estudio en tres fases: [11]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [11]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [11]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [12]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [12]\n\n5. Actividades de auto-aprendizajes:\nQue prerrequisito se debe cumplir en el arreglo para poder llevar a cabo las operaciones de adicionar e insertar. [12]\nQue prerrequisito debe cumplir la posición en las operaciones de eliminar, insertar, obtener y modificar. [13]\nQue ocurre entre la posición del elemento para el usuario y la posición de ese mismo elemento en el arreglo. [13]\n6. Actividades de evaluación:\nDescargue el proyecto Laboratorio Operaciones Básicas de Arreglo publicado en el espacio de la asignatura en el Entorno Virtual de Aprendizaje de la Universidad de Matanzas ( eva.umcc.cu ) y complete la implementación de los métodos propuestos en dicho proyecto. [13]\n7. Resumen:\nEl conocimiento de algoritmos básicos sobre arreglos permiten la manipulación de los arreglos y son la base para la confección de algoritmos mas complejos sobre dicha estructuras. [14]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [14]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [14]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [14]\n\n10. Recurso",
                "metadata": {
                    "file_name": "Guía de aprendizaje 14.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "raciones de eliminar, insertar, obtener y modificar. [13]\nQue ocurre entre la posición del elemento para el usuario y la posición de ese mismo elemento en el arreglo. [13]\n6. Actividades de evaluación:\nDescargue el proyecto Laboratorio Operaciones Básicas de Arreglo publicado en el espacio de la asignatura en el Entorno Virtual de Aprendizaje de la Universidad de Matanzas ( eva.umcc.cu ) y complete la implementación de los métodos propuestos en dicho proyecto. [13]\n7. Resumen:\nEl conocimiento de algoritmos básicos sobre arreglos permiten la manipulación de los arreglos y son la base para la confección de algoritmos mas complejos sobre dicha estructuras. [14]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [14]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [14]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [14]\n\n10. Recursos educativos digitales RED: [15]\n11. Próxima unidad: Arreglo. Algoritmos sobre arreglos. [15]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 14.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Arreglos y matrices\nUnidad didáctica: Arreglo. Algoritmos sobre arreglos.\n1. Objetivos de la unidad didáctica:\nIdentificar las operaciones que se pueden realizar sobre los arreglos del lenguaje de programación Java.\nCaracterizar cada una de las operaciones que se pueden realizar sobre los arreglos del lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nSobre un arreglo o colección de elementos se pueden realizar un grupo de operaciones independientemente del tipo de dato de los elementos del arreglo. Con estas operaciones vamos a poder adicionar, eliminar, buscar, obtener o modificar elementos en el arreglo. Cada una de esas operaciones se le puede definir su algoritmo el cual se puede codificar en un método. [1]\n\nYa acorde al tipo de dato que va almacenar el arreglo se pueden definir un grupo de operaciones que solo son aplicable a ese tipos de datos. Veamos algunas de esas operaciones. [2]\n\nConteo. Esta operación cuenta la cantidad de elementos dentro del arreglo cumple con determinada condición. La condición de conteo puede cambiar según la situación del problema o ejercicio pero la idea algorítmica del conteo es la misma: Declarar e inicializar un contador entero en cero, recorrer cada elemento del arreglo, si el elemento cumple la condición requerida se incrementa el contador en cero. [2]\n\nSumador. Esta operación es algo similar a la anterior con la variación que ahora se ir acumulando o sumando aquellos valores de los elementos que dentro del arreglo cumpla con una determinada condición. [3]\n\nMedia aritmética. (también llamada promedio o simplemente media) de un arreglo se obtiene a partir de la suma de todos sus valores de los elementos dividida entre el número de elementos del arreglo. [3]\n\nModa. Implica buscar entre todos los elementos del arreglo aquel elemento que mas se repite. [3]\n\nMediana. Implica buscar aquel elemento que dentro del arreglo que se ubica en la posición central o mitad del arreglo una vez que los elementos fueron ordenados, de ser la cantidad de elementos par se promedia los dos elementos centrales. [4]\n\nOrdenamiento. Permite ordenar los elementos dentro del arreglo ya sea de una forma ascendente o descendente. [4]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [4]\nCree hábitos de estudio sistemático; para esto: [5]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [5]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [5]\nUtilice técnicas de estudio: [6]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [6]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [6]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [6]\nInteractúe con los materiales de estudio en tres fases: [7]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [7]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [7]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [8]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [8]\n\n5. Actividades de auto-aprendizajes:\nQue tipo de dato es el más adecuado para retornar la media aritmética. [8]\nQue tipo de datos deben ser los arreglos sobre los cuales se puedan aplicar operaciones como la media aritmética y sumador. [9]\nInvestigue sobre los algoritmos de ordenamiento BurbleSort y SelectionSort. Caracterice cada uno de los algoritmos en cuanto a funcionamiento, cantidad de operaciones que realiza y complejidad. [9]\n6. Actividades de evaluación:\nDescargue el proyecto Laboratorio Operaciones Estadísticas de Arreglo publicado en el espacio de la asignatura en el Entorno Virtual de Aprendizaje de la Universidad de Matanzas ( e",
                "metadata": {
                    "file_name": "Guía de aprendizaje 15.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "lectura, intente realizar las actividades de auto-aprendizaje. [8]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [8]\n\n5. Actividades de auto-aprendizajes:\nQue tipo de dato es el más adecuado para retornar la media aritmética. [8]\nQue tipo de datos deben ser los arreglos sobre los cuales se puedan aplicar operaciones como la media aritmética y sumador. [9]\nInvestigue sobre los algoritmos de ordenamiento BurbleSort y SelectionSort. Caracterice cada uno de los algoritmos en cuanto a funcionamiento, cantidad de operaciones que realiza y complejidad. [9]\n6. Actividades de evaluación:\nDescargue el proyecto Laboratorio Operaciones Estadísticas de Arreglo publicado en el espacio de la asignatura en el Entorno Virtual de Aprendizaje de la Universidad de Matanzas ( eva.umcc.cu ) y complete la implementación de los métodos propuestos en dicho proyecto. [9]\n7. Resumen:\nEl conocimiento de algoritmos básicos o algunos más específicos acorde al tipo de dato que almacenen los arreglos permiten la manipulación de los arreglos y son la base para la confección de algoritmos mas complejos sobre dicha estructuras. [10]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [10]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [10]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [10]\n\n10. Recursos educativos digitales RED: [11]\n11. Próxima unidad: Matrices. Introducción a las matrices. [11]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 15.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Arreglos\nUnidad didáctica: Matrices. Introducción a las matrices.\n1. Objetivos de la unidad didáctica:\nCaracterizar una matriz en la programación.\nCaracterizar el acceso y modificación a los elementos de una matriz\nCaracterizar los recorridos por todos los elementos de una matriz\n2. Introducción a la unidad didáctica:\nAnteriormente se había abordado las ventajas de utilizar arreglos, ya que permiten almacenar, manipular varios valores que tienen en común se son de la misma clase o tipo de dato a través una sola variable la cual hace referencia a a varios lugares consecutivos en la memoria de la computadora. Esta idea nos permite por ejemplo si queremos trabajar con las temperaturas medida a la 9 mañana diariamente durante un mes los podemos almacenar de la siguiente manera:\n\ndouble [ ] temperatura = new double ;\n\nPero si ahora queremos trabajar y almacenar las temperaturas medida a la 9 mañana diariamente durante un año agrupadas por meses. Aquí tenemos dos soluciones con las herramientas que contamos.\n\nLa primera variante es crear doce arreglos cada uno de 31 capacidades donde cada arreglo representan un mes del año. Esta variante se me parece un poco cuando no sabíamos que existían los arreglos quisimos almacenar las 31 temperaturas del mes en 31 variables. El trabajo con estos doces arreglos sería bastante complejo. [1]\n\nUna segunda variante sería crear un arreglo con una capacidad de 12*31 donde de la posición 0 a la 30 irían las temperaturas del primer mes de las posiciones 31 a 61 las del segundo mes y de esta forma cada 31 posiciones consecutivas le correspondería a un mes. De esta forma almacenamos todos los valores en una sola referencia o variable que hace alusión a varios lugares consecutivos en la memoria de la computadora. La dificultad con esta variante recae en tener que crear una función matemática para que dada una posición del arreglo nos diga a que día y mes se corresponde de igual manera habría que crear una función matemática a la inversa que la anterior que dado un día y mes nos diga que posición del arreglo le corresponde. [2]\n\nBueno la representación o almacenamiento de los datos anteriores se resuelve utilizando matrices pero primero veamos que matemáticamente que es una matriz. [3]\n\nUna matriz es un arreglo bidimensional de números (llamados entradas de la matriz) ordenados en filas (o renglones) y columnas, donde una fila es cada una de las líneas horizontales de la matriz y una columna es cada una de las líneas verticales. A una matriz con n filas y m columnas se le denomina matriz n-por-m (escrito n x m). [3]\n\nBueno vamos a pensar lo siguiente: [3]\n\nSi podemos crear un arreglo de algún tipo de dato nativo del lenguaje donde en cada lugar o espacio almacenaré un valor asociado al tipo de dato nativo. Porque no crear un arreglo donde en cada posición en vez de guardar un valor almacenar un arreglo que si almacenara valores de algún tipo nativo del lenguaje. [4]\n\nA esto es lo que llamamos matriz en programación que se dice que es un arreglo de arreglos. [4]\n\nCon esta idea podemos crear un arreglo de 31 posiciones y en cada posición crear un arreglo de 12 posiciones. También pudieras ser un arreglo de 12 posiciones y en cada posición un arreglo de 31 capacidades. [4]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [5]\nCree hábitos de estudio sistemático; para esto: [5]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [5]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [6]\nUtilice técnicas de estudio: [6]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [6]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [6]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [6]\nInteractúe con los materiales de estudio en tres fases: [7]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [7]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previame",
                "metadata": {
                    "file_name": "Guía de aprendizaje 16.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "s materiales que necesita para realizar el estudio individual o colaborativo. [6]\nUtilice técnicas de estudio: [6]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [6]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [6]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [6]\nInteractúe con los materiales de estudio en tres fases: [7]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [7]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [7]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [8]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [8]\n\n5. Actividades de auto-aprendizajes:\nLa matrices se pueden declarar de acuerdo a la situación y en el contexto que se quiera emplear. Defina la sintaxis de cada posible situación y ejemplifique en cada caso [8]\nExplique como podemos acceder o modificar los valores almacenados en una matriz [9]\nPara recorrer un arreglo y consultar cada elemento almacenado utilizamos la estructura repetitiva for. Bueno y ahora en una matriz como podemos recorrer por cada elemento de la matriz ?. De cuantas formas podemos recorrer por todos los elementos de la matriz [9]\n6. Actividades de evaluación:\nDeclare una matriz para almacenar la asistencia a clases de un grupo a una determinada asignatura. La asignatura tendrán 24 clases y el grupo lo componen 30 estudiantes. [9]\nDeclare una matriz para almacenar todas notas de las preguntas escritas realizadas a dos grupos en una determinada asignatura. Durante el curso se realizaron 15 preguntas escritas, cada grupo lo componen 30 estudiantes. [10]\n7. Resumen:\nLas matrices son una variación de los arreglos por lo que son una estructura de datos simple que permite organizar los datos de forma tabular. Esta estructura de datos muy utilizada en los videojuegos y en los software de corte científicos matemático y su idea simple a permitido pensar en arreglo tridimensionales o con N dimensiones. [10]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [11]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [11]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [11]\n\n10. Recursos educativos digitales RED:\n11. Próxima unidad: Matrices. Operaciones y algoritmos básicos. [11]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 16.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "Tema V Arreglos y Matrices\nAsignatura Introducción a la Programación\nIngeniería Informática\nGuía de Aprendizaje\nTema : Arreglos\nUnidad didáctica: Matrices. Operaciones y algoritmos básicos.\n1. Objetivos de la unidad didáctica:\nIdentificar las operaciones básicas que se pueden realizar sobre las matrices del lenguaje de programación Java.\nCaracterizar cada una de las operaciones básicas que se pueden realizar sobre las matrices del lenguaje de programación Java.\n2. Introducción a la unidad didáctica:\nSobre una matriz de elementos se pueden realizar un grupo de operaciones independientemente del tipo de dato de los elementos del arreglo. Con estas operaciones vamos a poder crear, llenar, buscar, obtener o modificar elementos en la modificar. [1] Cada una de esas operaciones se le puede definir su algoritmo el cual se puede codificar en un método. [1] Antes de empezar a definir cada una de las operaciones es bueno aclarar que siempre que se trabaje con este tipo de estructura la misma debe estar completamente llena, no puede existir capacidades o 'huecos' disponibles como sucede en el arreglo es por eso que las primeras operaciones con una matriz debe ser la de creación y llenado. [1]\n\n3. Operaciones con matrices:\nLas primeras operaciones que vamos a analizar son las que permiten crear y llenar la matriz con valores: [2]\n\nCrear: Esta operación se encarga de crear una matriz con determinadas dimensiones las cuales pueden ser definidas por el usuario o por mismo el programador si es conocido por él los valores de de dichas dimensiones. [2] Cuando se crea una matriz la computadora asigna a cada posición de esta un mismo valor el cual esta en correspondencia con el tipo de dato. [2] Es por eso que de realizar cualquier operación con la matriz la misma sea llenada con con los valores reales para evitar resultados incorrectos. [2]\nLlenar: Esta operación se encarga de colocar en cada posición de la matriz el valor correspondiente. [3] Al igual que la operación anterior se puede llenar solicitando lo valores al usuario donde además de solicitar dicho valor se le debe solicitar o especificar al usuario en que fila y columna de la matriz va ese valor o por mismo el programador si es conocido por él los valores de cada una de las posiciones. [3]\nOtra de las operaciones básicas sobre matrices es la búsqueda; dentro de los elementos almacenados en una matriz se comprueba la existencia o no de un determinado elemento. [3] En dicha operación se comprueba recorriendo todos los elementos de la matriz y comprobando con cada uno de los elementos si es igual a valor que se desea buscar en caso de ser igual se dice que que elemento se encuentra y solo se puede asegurar de la no existencia del valor dentro del arreglo cuando se haya comprobado con todos los elementos. [3] La operación de búsqueda puede tener varias variantes según sea la necesidad y el problema: [3]\n\nExistencia o no: Solo comprueba si el valor buscado esta almacenado en la matriz el mismo retorna un valor lógico verdadero si existe falso en caso contrario. [4]\nPosición de la primera ocurrencia: Retorna la posición dentro de la matriz donde esta almacenado la primera ocurrencia del valor buscado. [4] Aquí lo que sucede es que la posición dentro de la matriz lo define un par ordenado (fila y columna) por los que se retorna un arreglo con dos elementos ; el primer elemento del arreglo indica la fila mientras el segundo elemento indica la columna donde se encuentra ubicado el elemento buscado en caso de no existir el valor en la matriz se retorna [-1,-1] ya que un ese valor es una posición invalida dentro de una matriz en Java. [4]\nPosición de la última ocurrencia: Retorna la posición dentro de la matriz donde esta almacenado la última ocurrencia del valor buscado. [5] Aquí lo que sucede es que la posición dentro de la matriz lo define un par ordenado (fila y columna) por los que se retorna un arreglo con dos elementos ; el primer elemento del arreglo indica la fila mientras el segundo elemento indica la columna donde se encuentra ubicado el elemento buscado en caso de no existir el valor en la matriz se retorna [-1,-1] ya que un ese valor es una posición invalida dentro de una matriz en Java. [5]\nMayor o menor elemento: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso. [6]\nMayor o menor elemento de una fila: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso en una determinada fila. [6] Aquí se fija una de las dimensiones de la matriz en este caso la fila y se busca en todas las columnas asociadas a esa fila. [6]\nMayor o menor elemento de una columna: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso en una determinada columna. [6] Aquí se fija una de las dimensiones de la matriz en este caso la columna y se busca en todas las filas asociadas a esa columna. [6]\nTanto las operaciones de obtener o modificar permiten obtener o modificar el valor de una determinada posición de la matriz para eso",
                "metadata": {
                    "file_name": "Guía de aprendizaje 17-1.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "emento indica la columna donde se encuentra ubicado el elemento buscado en caso de no existir el valor en la matriz se retorna [-1,-1] ya que un ese valor es una posición invalida dentro de una matriz en Java. [5]\nMayor o menor elemento: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso. [6]\nMayor o menor elemento de una fila: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso en una determinada fila. [6] Aquí se fija una de las dimensiones de la matriz en este caso la fila y se busca en todas las columnas asociadas a esa fila. [6]\nMayor o menor elemento de una columna: Retorna el mayor o el menor valor almacenado en la matriz según sea el caso en una determinada columna. [6] Aquí se fija una de las dimensiones de la matriz en este caso la columna y se busca en todas las filas asociadas a esa columna. [6]\nTanto las operaciones de obtener o modificar permiten obtener o modificar el valor de una determinada posición de la matriz para eso se necesita en conocer la posición (en este caso conformado por el par ordenado fila y columna) en ambas operaciones mientras en la de modificar se necesita conocer el nuevo valor que se desea almacenar en la posición. [7]\n\n3. Orientaciones para el estudio:\nLe sugerimos que para realizar el estudio de una materia debe elegir un lugar agradable, limpio, ventilado, cómodo, iluminado y si necesita recursos tecnológicos deben estar disponibles. [7]\nCree hábitos de estudio sistemático; para esto: [8]\nPlanifique su tiempo y no deje para mañana lo que pueda hacer hoy; una buena planificación hace manejable las responsabilidades diarias que tenemos para con la vida, permite cumplir con todas las tareas programadas y así evita agobios de última hora. [8]\nCalendarice las fechas más importantes de estudio y entrega de tareas. Localice con antelación los materiales que necesita para realizar el estudio individual o colaborativo. [8]\nUtilice técnicas de estudio: [9]\nElija un entorno de estudio que resulte agradable y sin elementos que lo que distraigan [9]\nEstudie activamente, para esto lea en voz alta, tome notas, elabore esquemas o mapas conceptuales, realice resúmenes. [9]\nReflexione sobre lo que va aprendiendo, para esto relacione lo nuevo con lo anterior o conocido, asegúrese de que entiende y es capaz de aplicar lo que está aprendiendo antes de pasar adelante. [9]\nInteractúe con los materiales de estudio en tres fases: [10]\nFase de aproximación: Revise el objetivo de la unidad y después la acción o acciones a lograr; busque los materiales sugeridos para desarrollar la tarea, verifique cuál es el tiempo de que dispone. [10]\nFase de lectura profunda: aproxímese al material a través de una lectura ligera, poniendo especial interés en los títulos y subtítulos. [10] Trate de relacionar lo que va leyendo con conocimientos adquiridos previamente. [10]\nFase de evaluación: Una vez realizada la lectura, intente realizar las actividades de auto-aprendizaje. [11]\n4. Requisitos Previos:\nTener conocimientos básicos de computación: los estudiantes matriculados deben conocer los procedimientos básicos para el manejo de PC y/o dispositivos móviles, aplicaciones de ofimática; así como uso de navegadores de páginas Web y el correo electrónico. [11]\n\n5. Actividades de auto-aprendizajes:\nQue prerrequisito se debe cumplir en la matriz para poder llevar a cabo las operación de llenar. [11]\nQue prerrequisito debe cumplir la posición en las operaciones de llenar, obtener y modificar. [12]\nQue ocurre entre la posición del elemento para el usuario y la posición de ese mismo elemento en la matriz. [12]\n6. Actividades de evaluación:\nDescargue el proyecto Laboratorio Operaciones Básicas de Matrices publicado en el espacio de la asignatura en el Entorno Virtual de Aprendizaje de la Universidad de Matanzas ( eva.umcc.cu ) y complete la implementación de los métodos propuestos en dicho proyecto. [12]\n7. Resumen:\nLas matrices son una variación de los arreglos por lo que son una estructura de datos simple que permite ser utilizada para representar grafos, algunos juegos de tablero y una organización tabular de la información. [13]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [13]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [13]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [13]\n\n10. Recursos educativos digitales RED: [14]\n11. Próxima unidad: Cadenas. [14]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 17-1.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        },
        {
            "doc": {
                "doc": "ura de datos simple que permite ser utilizada para representar grafos, algunos juegos de tablero y una organización tabular de la información. [13]\n\n8. Glosario de términos:\nConsulte la bibliografía y define los siguientes conceptos [13]\n\n9. Bibliografía:\nAprenda Java como si estuviera en primero. Colectivo de autores. Cap 4 epígrafes 4.1. [13]\n\nCómo programar en Java. Deitel, Paul J. Y Harvey M. Deitel. Cap 7 epigrafes 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8. [13]\n\n10. Recursos educativos digitales RED: [14]\n11. Próxima unidad: Cadenas. [14]",
                "metadata": {
                    "file_name": "Guía de aprendizaje 17-1.txt"
                }
            },
            "metadata": {
                "file_name": "Guía de aprendizaje 17-1.txt"
            }
        }
    ]
}